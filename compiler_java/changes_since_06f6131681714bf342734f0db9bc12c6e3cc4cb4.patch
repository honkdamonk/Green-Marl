+
diff --git a/src/inc/gm_backend_cpp.h b/src/inc/gm_backend_cpp.h
index 59eae0c..ea28fd3 100644
--- a/src/inc/gm_backend_cpp.h
+++ b/src/inc/gm_backend_cpp.h
@@ -56,15 +56,63 @@ public:
     virtual void generate_foreach_header(ast_foreach* fe, gm_code_writer& Body);
 
 private:
+    //map sizes
+    static const int SMALL = 0;
+    static const int MEDIUM = 1;
+    static const int LARGE = 2;
+
+    char str_buf[1024 * 8];
+    gm_cpp_gen* main;
+
     virtual void generate_expr_builtin_field(ast_expr_builtin_field* builtinExpr, gm_code_writer& body);
     const char* get_function_name_graph(int methodId);
     const char* get_function_name_nset(int methodId, bool in_parallel = false);
     const char* get_function_name_nseq(int methodId);
     const char* get_function_name_norder(int methodId);
+    const char* get_function_name_map(int methodId, bool in_parallel = false);
+    const char* get_function_name_map_seq(int methodId);
+    const char* get_function_name_map_par(int methodId);
     void add_arguments_and_thread(gm_code_writer& body, ast_expr_builtin* builtinExpr, bool addThreadId);
+    const char* getMapDefaultValueForType(int type);
+    const char* getMapTypeString(int mapType);
+    const char* getAdditionalMapParameters(int mapType);
+
+    static const char* get_primitive_type_string(int type_id) {
+        switch (type_id) {
+            case GMTYPE_BYTE:
+                return "int8_t";
+            case GMTYPE_SHORT:
+                return "int16_t";
+            case GMTYPE_INT:
+                return "int32_t";
+            case GMTYPE_LONG:
+                return "int64_t";
+            case GMTYPE_FLOAT:
+                return "float";
+            case GMTYPE_DOUBLE:
+                return "double";
+            case GMTYPE_BOOL:
+                return "bool";
+            default:
+                assert(false);
+                return "??";
+        }
+    }
+
+    static const char* getTypeString(int type) {
+        if (gm_is_prim_type(type)) {
+            return get_primitive_type_string(type);
+        } else if (gm_is_node_type(type)) {
+            return NODE_T;
+        } else if (gm_is_edge_type(type)) {
+            return EDGE_T;
+        } else {
+            assert(false);
+        }
+        return NULL;
+    }
+
 
-    char str_buf[1024 * 8];
-    gm_cpp_gen* main;
 };
 
 //-----------------------------------------------------------------
diff --git a/src/inc/gm_defs.h b/src/inc/gm_defs.h
index f4a6aa4..e58f727 100644
--- a/src/inc/gm_defs.h
+++ b/src/inc/gm_defs.h
@@ -278,18 +302,22 @@ inline static bool gm_is_sequence_collection_type(int i) {
 
 inline static bool gm_is_sequential_collection_type(int i) {
     return gm_is_sequence_collection_type(i) || gm_is_order_collection_type(i);
 }
 
+inline static bool gm_is_map_type(int i) {
+    return i == GMTYPE_MAP;
+}
+
 // node set -> nodeset iter
 // edge set -> edgeset iter ...
 inline int gm_get_natural_collection_iterator(int src_type) {
@@ -429,46 +488,67 @@ inline static bool gm_is_iteration_on_property(int iterType) {
 inline static bool gm_is_iteration_on_neighbors_compatible(int itype) {
     return gm_is_any_nbr_node_iter_type(itype);
 }
 
+inline static bool gm_can_be_key_type(GMTYPE_T type) {
+    return gm_is_prim_type(type) || gm_is_nodeedge_type(type);
+}
+
+inline static bool gm_can_be_value_type(GMTYPE_T type) {
+    return gm_is_prim_type(type) || gm_is_nodeedge_type(type);
+}
+
 enum GM_ACCESS_T
 {   // 16 bit bitmap
     GMACCESS_NONE = 0x0000,
