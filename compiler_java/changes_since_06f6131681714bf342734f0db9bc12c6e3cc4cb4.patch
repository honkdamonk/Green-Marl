diff --git a/src/backend_cpp/gm_cpp_gen.cc b/src/backend_cpp/gm_cpp_gen.cc
index f7735c4..b6ce23c 100644
--- a/src/backend_cpp/gm_cpp_gen.cc
+++ b/src/backend_cpp/gm_cpp_gen.cc
@@ -350,6 +350,13 @@ const char* gm_cpp_gen::get_type_string(ast_typedecl* t) {
         } else {
             assert(false);
         }
+    } else if (t->is_map()) {
+        char temp[256];
+        ast_maptypedecl* mapType = (ast_maptypedecl*)t;
+        const char* keyType = get_type_string(mapType->get_key_type());
+        const char* valueType = get_type_string(mapType->get_value_type());
+        sprintf(temp, "gm_map<%s, %s>", keyType, valueType);
+        return gm_strdup(temp);
     } else
         return get_lib()->get_type_string(t);
 
@@ -483,6 +486,14 @@ void gm_cpp_gen::generate_sent_vardecl(ast_vardecl* v) {
         return;
     }
 
+    if (t->is_map()) {
+        ast_maptypedecl* map = (ast_maptypedecl*) t;
+        ast_idlist* idl = v->get_idlist();
+        assert(idl->get_length() == 1);
+        get_lib()->add_map_def(map, idl->get_item(0));
+        return;
+    }
+
     Body.push_spc(get_type_string(t));
 
     if (t->is_property()) {
@@ -504,15 +515,61 @@ void gm_cpp_gen::generate_sent_vardecl(ast_vardecl* v) {
     }
 }
 
+const char* gm_cpp_gen::get_function_name_map_reduce_assign(int reduceType) {
+
+    switch (reduceType) {
+        case GMREDUCE_PLUS:
+            return "changeValueAtomicAdd";
+        default:
+            assert(false);
+            return "ERROR";
+    }
+}
+
+void gm_cpp_gen::generate_sent_map_assign(ast_assign_mapentry* a) {
+    ast_mapaccess* mapAccess = a->to_assign_mapentry()->get_lhs_mapaccess();
+    ast_id* map = mapAccess->get_map_id();
+
+    char buffer[256];
+    if (a->is_under_parallel_execution()) {
+        if (a->is_reduce_assign() && a->get_reduce_type() == GMREDUCE_PLUS) {
+            sprintf(buffer, "%s.%s(", map->get_genname(), get_function_name_map_reduce_assign(a->get_reduce_type()));
+        } else {
+            sprintf(buffer, "%s.setValue_par(", map->get_genname());
+        }
+    } else {
+        if (a->is_reduce_assign() && a->get_reduce_type() == GMREDUCE_PLUS) {
+            //TODO do this without CAS overhead
+            sprintf(buffer, "%s.%s(", map->get_genname(), get_function_name_map_reduce_assign(a->get_reduce_type()));
+        } else {
+            sprintf(buffer, "%s.setValue_seq(", map->get_genname());
+        }
+    }
+    Body.push(buffer);
+
+    ast_expr* key = mapAccess->get_key_expr();
+    generate_expr(key);
+    Body.push(", ");
+    generate_expr(a->get_rhs());
+    Body.pushln(");");
+}
+
 void gm_cpp_gen::generate_sent_assign(ast_assign* a) {
 
     if (a->is_target_scalar()) {
         ast_id* leftHandSide = a->get_lhs_scala();
         if (leftHandSide->is_instantly_assigned()) { //we have to add the variable declaration here
             Body.push(get_lib()->get_type_string(leftHandSide->getTypeSummary()));
+            if(a->is_reference()) {
+                Body.push("& ");
+            } else {
             Body.push(" ");
         }
+        }
         generate_lhs_id(a->get_lhs_scala());
+    } else if (a->is_target_map_entry()) {
+        generate_sent_map_assign(a->to_assign_mapentry());
+        return;
     } else {
         generate_lhs_field(a->get_lhs_field());
     }
@@ -131,7 +141,12 @@ void gm_cpplib::generate_foreach_header(ast_foreach* fe, gm_code_writer& Body) {
     int type = fe->get_iter_type();
 
     if (gm_is_iteration_on_all_graph(type)) {
-        char* graph_name = source->get_genname();
+        char* graph_name;
+        if(gm_is_node_property_type(source->getTypeSummary()) || gm_is_edge_property_type(source->getTypeSummary())) {
+            graph_name = source->getTypeInfo()->get_target_graph_id()->get_orgname();
+        } else {
+            graph_name = source->get_genname();
+        }
         char* it_name = iter->get_genname();
         sprintf(str_buf, "for (%s %s = 0; %s < %s.%s(); %s ++) ", get_type_string(type), it_name, it_name, graph_name,
                 gm_is_iteration_on_nodes(type) ? NUM_NODES : NUM_EDGES,
@@ -177,7 +192,7 @@ void gm_cpplib::generate_foreach_header(ast_foreach* fe, gm_code_writer& Body) {
     } else if (gm_is_iteration_on_collection(type)) {
 
         assert(!fe->is_parallel());
-        assert(gm_is_node_collection_iter_type(type));
+        assert(gm_is_node_collection_iter_type(type) || gm_is_collection_of_collection_iter_type(type));
 
         const char* iter_name = fe->find_info_string(CPPBE_INFO_COLLECTION_ITERATOR);
         sprintf(str_buf, "while (%s.has_next())", iter_name);
diff --git a/src/backend_cpp/gm_cpp_opt.cc b/src/backend_cpp/gm_cpp_opt.cc
index 8d7c215..ecfcb57 100644
--- a/src/backend_cpp/gm_cpp_opt.cc
+++ b/src/backend_cpp/gm_cpp_opt.cc
@@ -15,6 +15,7 @@ void gm_cpp_gen::init_opt_steps() {
 
     LIST.push_back(GM_COMPILE_STEP_FACTORY(gm_cpp_opt_check_feasible));
     LIST.push_back(GM_COMPILE_STEP_FACTORY(gm_cpp_opt_defer));
+    LIST.push_back(GM_COMPILE_STEP_FACTORY(gm_cpp_opt_common_nbr));
     LIST.push_back(GM_COMPILE_STEP_FACTORY(gm_cpp_opt_select_par));
     LIST.push_back(GM_COMPILE_STEP_FACTORY(gm_cpp_opt_save_bfs));
     LIST.push_back(GM_COMPILE_STEP_FACTORY(gm_ind_opt_move_propdecl)); // from ind-opt
diff --git a/src/backend_cpp/gm_cpplib_gen.cc b/src/backend_cpp/gm_cpplib_gen.cc
index db06499..008f6b4 100644
--- a/src/backend_cpp/gm_cpplib_gen.cc
+++ b/src/backend_cpp/gm_cpplib_gen.cc
@@ -51,19 +51,23 @@ const char* gm_cpplib::get_type_string(int type) {
         return QUEUE_T;
+    } else if (gm_is_map_type(type)) {
+        return MAP_T;
     } else {
         printf("type = %d %s\n", type, gm_get_type_string(type));
         assert(false);
@@ -126,6 +131,64 @@ bool gm_cpplib::add_collection_def(ast_id* i) {
     return false;
 }
 
+const char* gm_cpplib::getMapTypeString(int type) {
+    if (type == MEDIUM)
+        return "gm_map_medium";
+    else
+        assert(false);
+    return NULL;
+}
+
+const char* gm_cpplib::getMapDefaultValueForType(int type) {
+    if (gm_is_float_type(type)) {
+        return "0.0";
+    } else if (gm_is_integer_type(type)) {
+        return "0";
+    } else if (gm_is_boolean_type(type)) {
+        return "false";
+    } else if (gm_is_node_type(type)) {
+        return "gm_graph::NIL_NODE";
+    } else if (gm_is_edge_type(type)) {
+        return "gm_graph::NIL_EDGE";
+    } else {
+        //we only support primitives, nodes and edges in maps (yet)
+        assert(false);
+    }
+    return NULL;
+}
+
+const char* gm_cpplib::getAdditionalMapParameters(int mapType) {
+    switch (mapType) {
+        case MEDIUM:
+            return "gm_rt_get_num_threads(), ";
+        default:
+            assert(false);
+            return "ERROR";
+    }
+}
+
+void gm_cpplib::add_map_def(ast_maptypedecl* map, ast_id* mapId) {
+
+    int mapType = MEDIUM; //TODO: implement compiler optimization to figure out what is best here
+    int keyType = map->getKeyTypeSummary();
+    int valueType = map->getValueTypeSummary();
+    if(valueType == GMTYPE_BOOL) {
+        valueType = GMTYPE_INT;
+    }
+
+    // Output: MapType<KeyType, ValueType> VariableName(AdditionalParameters DefaultValue);
+
+    char typeBuffer[128];
+    sprintf(typeBuffer, "%s<%s, %s>", getMapTypeString(mapType), getTypeString(keyType),  getTypeString(valueType));
+
+    char parameterBuffer[64];
+    sprintf(parameterBuffer, "(%s %s)", getAdditionalMapParameters(mapType), getMapDefaultValueForType(valueType));
+
+    char buffer[256];
+    sprintf(buffer, "%s %s%s;", typeBuffer, mapId->get_genname(), parameterBuffer);
+    Body->pushln(buffer);
+}
+
 void gm_cpplib::generate_sent_nop(ast_nop *f) {
     int subtype = f->get_subtype();
     switch (subtype) {
@@ -195,12 +262,79 @@ const char* gm_cpplib::get_function_name_norder(int methodId) {
             return "pop_back";
         case GM_BLTIN_SET_HAS:
             return "is_in";
        case GM_BLTIN_SET_SIZE:
            return "get_size";
        default:
            assert(false);
            return "ERROR";
    }
}

+const char* gm_cpplib::get_function_name_map(int methodId, bool in_parallel) {
+
+    switch (methodId) {
+        case GM_BLTIN_MAP_SIZE:
+            return "size";
+        case GM_BLTIN_MAP_CLEAR:
+            return "clear";
+        case GM_BLTIN_MAP_HAS_MAX_VALUE:
+        case GM_BLTIN_MAP_HAS_MIN_VALUE:
+        case GM_BLTIN_MAP_HAS_KEY:
+        case GM_BLTIN_MAP_GET_MAX_KEY:
+        case GM_BLTIN_MAP_GET_MIN_KEY:
+        case GM_BLTIN_MAP_GET_MAX_VALUE:
+        case GM_BLTIN_MAP_GET_MIN_VALUE: {
+            if (in_parallel)
+                // if it is in parallel we do not have to use the inherent
+                // parallelism of the map so this is not a bug!!!
+                return get_function_name_map_seq(methodId);
+            else
+                return get_function_name_map_par(methodId);
+        }
         default:
             assert(false);
             return "ERROR";
     }
 }
 
+const char* gm_cpplib::get_function_name_map_seq(int methodId) {
+    switch (methodId) {
+        case GM_BLTIN_MAP_HAS_MAX_VALUE:
+            return "hasMaxValue";
+        case GM_BLTIN_MAP_HAS_MIN_VALUE:
+            return "hasMinValue";
+        case GM_BLTIN_MAP_HAS_KEY:
+            return "hasKey";
+        case GM_BLTIN_MAP_GET_MAX_KEY:
+            return "getMaxKey";
+        case GM_BLTIN_MAP_GET_MIN_KEY:
+            return "getMinKey";
+        case GM_BLTIN_MAP_GET_MAX_VALUE:
+            return "getMaxValue";
+        case GM_BLTIN_MAP_GET_MIN_VALUE:
+            return "getMinValue";
+    }
+}
+
+const char* gm_cpplib::get_function_name_map_par(int methodId) {
+    switch (methodId) {
+        case GM_BLTIN_MAP_HAS_MAX_VALUE:
+            return "hasMaxValue_par";
+        case GM_BLTIN_MAP_HAS_MIN_VALUE:
+            return "hasMinValue_par";
+        case GM_BLTIN_MAP_HAS_KEY:
+            return "hasKey_par";
+        case GM_BLTIN_MAP_GET_MAX_KEY:
+            return "getMaxKey_par";
+        case GM_BLTIN_MAP_GET_MIN_KEY:
+            return "getMinKey_par";
+        case GM_BLTIN_MAP_GET_MAX_VALUE:
+            return "getMaxValue_par";
+        case GM_BLTIN_MAP_GET_MIN_VALUE:
+            return "getMinValue_par";
+    }
+}
+
 const char* gm_cpplib::get_function_name_graph(int methodId) {
     switch (methodId) {
         case GM_BLTIN_GRAPH_NUM_NODES:
@@ -363,6 +497,9 @@ void gm_cpplib::generate_expr_builtin(ast_expr_builtin* e, gm_code_writer& Body)
         case GMTYPE_NSEQ:
             func_name = get_function_name_nseq(method_id);
             break;
+        case GMTYPE_MAP:
+            func_name = get_function_name_map(method_id);
+            break;
         default:
             assert(false);
             break;
diff --git a/src/backend_gps/gm_gps_opt.cc b/src/backend_gps/gm_gps_opt.cc
index fdc96ea..0996590 100644
--- a/src/backend_gps/gm_gps_opt.cc
+++ b/src/backend_gps/gm_gps_opt.cc
@@ -11,6 +11,9 @@ void gm_gps_gen::init_opt_steps() {
     std::list<gm_compile_step*>& L = get_opt_steps();
     L.push_back(GM_COMPILE_STEP_FACTORY(gm_cpp_opt_defer));                    // deferred assignment --> insert _next
     L.push_back(GM_COMPILE_STEP_FACTORY(gm_gps_opt_transform_bfs));            // transform bfs
+    L.push_back(GM_COMPILE_STEP_FACTORY(gm_gps_opt_edge_iteration));           // expand edge iteration
+    L.push_back(GM_COMPILE_STEP_FACTORY(gm_ind_opt_propagate_trivial_writes));
+    L.push_back(GM_COMPILE_STEP_FACTORY(gm_ind_opt_remove_unused_scalar));
     L.push_back(GM_COMPILE_STEP_FACTORY(gm_ind_opt_move_propdecl));            // copied from from ind-opt
     L.push_back(GM_COMPILE_STEP_FACTORY(gm_gps_opt_simplify_expr1));           // separate built-in calls through out-loop drivers 
     //L.push_back(GM_COMPILE_STEP_FACTORY(gm_gps_opt_find_nested_loops_test)); 
diff --git a/src/backend_gps/gm_gps_opt_transform_bfs.cc b/src/backend_gps/gm_gps_opt_transform_bfs.cc
index d358231..2d12e3a 100644
--- a/src/backend_gps/gm_gps_opt_transform_bfs.cc
+++ b/src/backend_gps/gm_gps_opt_transform_bfs.cc
@@ -8,10 +8,12 @@
 #include "gm_backend_gps_opt_steps.h"
 
 //--------------------------------------------------------
+// Transform BFS ==> Pregel-Canonical Statments. (i.e. while + foreach)
 //
-//
-//
-//
+//  By doing this transformation, we may lose an opportunity to use 
+//  a special fast implmentation of BFS.
+//  However, we can re-use GPS tranlsation mechanism for while/foreach statments.
+//  without creating new translation rules.
 //----------------------------------------------------
 
 class gps_opt_find_bfs_t : public gm_apply
@@ -29,7 +31,7 @@ public:
     virtual bool apply(ast_sent* s) {
         if (s->get_nodetype()== AST_BFS)
         {
-            assert (!in_bfs);  // no nested BFS for now
+            assert (!in_bfs);  // [XXX] Nested BFS are not allowed (temporary)
             in_bfs = true;
             current_bfs = (ast_bfs*) s;
             BFS.push_back(current_bfs);
@@ -156,7 +159,7 @@ static void create_fw_iteration(ast_sentblock* sb, ast_bfs* bfs, gm_symtab_entry
     //       Foreach(v:G.Nodes) {
     //          if (v.level == curr_level) {
     //             Foreach(k:v.Nbrs) {
-    //                If (k.level == +INF) {
+    //                If (k.level == +INF && [navigator]) {
     //                   k.level = curr_level + 1;    
     //                   bfs_finished &= False;
     //                }
@@ -205,7 +208,7 @@ static void create_fw_iteration(ast_sentblock* sb, ast_bfs* bfs, gm_symtab_entry
         GMTYPE_NODEITER_ALL);
     while_sb->add_sent(foreach_out);
 
-    // outer if
+
     ast_expr* lev_check_out_c = ast_expr::new_comp_expr(
         GMOP_EQ,
         ast_expr::new_field_expr(
@@ -240,7 +243,24 @@ static void create_fw_iteration(ast_sentblock* sb, ast_bfs* bfs, gm_symtab_entry
             inf
         );
     ast_sentblock* lev_check_in_sb = ast_sentblock::new_sentblock();
-    ast_if* lev_check_in_if = ast_if::new_if(lev_check_in_c, lev_check_in_sb,NULL);
+    ast_if* lev_check_in_if;
+    if (bfs->get_navigator() != NULL) 
+    {
+        ast_expr* navi = bfs->get_navigator();
+        bfs->set_navigator(NULL);
+
+        // replace bfs symbol ==> an inner foreach symbol
+        gm_replace_symbol_entry(bfs->get_iterator()->getSymInfo(), foreach_in->get_iterator()->getSymInfo(), navi);
+
+        // check with navigator
+        ast_expr* new_top = ast_expr::new_lbiop_expr(GMOP_AND, lev_check_in_c, navi);
+        lev_check_in_if = ast_if::new_if(new_top, lev_check_in_sb,NULL);
+    } 
+    else 
+    {
+        lev_check_in_if = ast_if::new_if(lev_check_in_c, lev_check_in_sb,NULL);
+    }
+
     inner_sb->add_sent(lev_check_in_if);
 
     // increase level
@@ -341,10 +362,6 @@ static void create_bw_iteration(ast_sentblock* sb, ast_bfs* bfs, gm_symtab_entry
 
 
 void gm_gps_rewrite_bfs(ast_bfs* b) {
-    // for temporary
-    assert(b->get_b_filter() == NULL);
-    assert(b->get_f_filter() == NULL);
-    assert(b->get_navigator() == NULL);
 
     gm_make_it_belong_to_sentblock(b);
     ast_sentblock* parent = (ast_sentblock*) b->get_parent();
@@ -484,7 +501,6 @@ static void create_user_body_main(ast_sentblock* sb_to_add, ast_bfs* bfs, ast_fo
     gm_ripoff_sent(body);
 
     // replace iterator
-    //printf("repalce :%s -> %s\n", bfs->get_iterator()->get_genname(), out_loop->get_iterator()->get_genname());
     gm_replace_symbol_entry(bfs->get_iterator()->getSymInfo(), out_loop->get_iterator()->getSymInfo(), body);
     // what was iterator 2 again?
     if (bfs->get_iterator2() != NULL)
diff --git a/src/common/gm_builtin.cc b/src/common/gm_builtin.cc
index cc3cf6e..f11d14e 100644
--- a/src/common/gm_builtin.cc
+++ b/src/common/gm_builtin.cc
@@ -46,6 +46,10 @@ static int gm_get_type_from_string(const char* s) {
         return GMTYPE_VOID;
     else if (gm_is_same_string(s, "Bool"))
         return GMTYPE_BOOL;
+    else if (gm_is_same_string(s, "Map"))
+        return GMTYPE_MAP;
+    else if (gm_is_same_string(s, "Generic"))
+        return GMTYPE_GENERIC;
     else {
         assert(false);
         return 0;
diff --git a/src/common/gm_code_generator.cc b/src/common/gm_code_generator.cc
index dd41e55..8ab4e8f 100644
--- a/src/common/gm_code_generator.cc
+++ b/src/common/gm_code_generator.cc
@@ -11,10 +11,23 @@ void gm_code_generator::generate_expr_list(std::list<ast_expr*>& L) {
     }
 }
 
+void gm_code_generator::generate_mapaccess(ast_expr_mapaccess* e) {
+    ast_mapaccess* mapAccess = e->get_mapaccess();
+    ast_id* map = mapAccess->get_map_id();
+    ast_expr* key = mapAccess->get_key_expr();
+    char buffer[256];
+    sprintf(buffer, "%s.getValue(", map->get_genname());
+    _Body.push(buffer);
+    generate_expr(key);
+    _Body.push(")");
+}
+
 extern void gm_flush_reproduce();
 
 void gm_code_generator::generate_expr(ast_expr*e) {
-    if (e->is_inf())
+    if(e->is_mapaccess())
+        generate_mapaccess((ast_expr_mapaccess*)e);
+    else if (e->is_inf())
         generate_expr_inf(e);
     else if (e->is_literal())
         generate_expr_val(e);
@@ -242,7 +255,7 @@ void gm_code_generator::generate_sent(ast_sent* s) {
             break;
         case AST_ASSIGN: {
             ast_assign* a = (ast_assign*) s;
-            if (a->is_reduce_assign()) {
+            if (a->is_reduce_assign() && !a->is_target_map_entry()) {
                 generate_sent_reduce_assign(a);
             } else if (a->is_defer_assign()) {
                 generate_sent_defer_assign(a);
diff --git a/src/common/gm_dumptree.cc b/src/common/gm_dumptree.cc
index aa2e69b..71cc0d3 100644
--- a/src/common/gm_dumptree.cc
+++ b/src/common/gm_dumptree.cc
@@ -40,6 +41,17 @@ void ast_field::dump_tree(int ind_level) {
     printf("]");
 }
 
+void ast_mapaccess::dump_tree(int indLevel) {
+    assert(parent != NULL);
+    IND(indLevel);
+    printf("[");
+    mapId->dump_tree(0);
+    printf("[");
+    keyExpr->dump_tree(indLevel + 1);
+    printf("]");
+    printf("]");
+}
+
 void ast_typedecl::dump_tree(int ind_level) {
     assert(parent!=NULL);
     IND(ind_level);
diff --git a/src/common/gm_error.cc b/src/common/gm_error.cc
index fc84967..17b1669 100644
--- a/src/common/gm_error.cc
+++ b/src/common/gm_error.cc
@@ -147,6 +146,9 @@ void gm_type_error(int errno, int l, int c, const char* str1, const char* str2,
         case GM_ERROR_COMPARE_MISMATCH:
             printf("Typemismatch in Comparison. LHS:%s, RHS:%s \n", str1, str2);
             break;
+        case GM_ERROR_KEY_MISSMATCH:
+            printf("Type mismatch for map-key. Expected %s, but was %s\n", str1, str2);
+            break;
         case GM_ERROR_NEED_BOOLEAN:
             printf("Need boolean expression.\n");
             break;
diff --git a/src/common/gm_misc.cc b/src/common/gm_misc.cc
index 446761e..1c9b05a 100644
--- a/src/common/gm_misc.cc
+++ b/src/common/gm_misc.cc
@@ -126,7 +126,8 @@ const char* gm_get_type_string(int t) {
             return "Collection::I";
         case GMTYPE_VOID:
             return "Void";
-
+        case GMTYPE_MAP:
+            return "Map";
         default: /*printf("%d\n",t); assert(false);*/
             return "Unknown";
     }
@@ -149,16 +150,14 @@ const char* gm_get_iter_type_string(int t) {
             return "InNbrs";
         case GMTYPE_NODEITER_COMMON_NBRS:
             return "CommonNbrs";
-
         case GMTYPE_NODEITER_SET:
-            return "Items";
         case GMTYPE_NODEITER_SEQ:
-            return "Items";
         case GMTYPE_NODEITER_ORDER:
-            return "Items";
         case GMTYPE_ITER_ANY:
+        case GMTYPE_PROPERTYITER_SET:
+        case GMTYPE_PROPERTYITER_SEQ:
+        case GMTYPE_PROPERTYITER_ORDER:
             return "Items";
-
         default:
             assert(false);
             return "Unknown";
@@ -181,7 +180,8 @@ const char* gm_get_reduce_string(int rop_type) {
 }
 const char* gm_get_reduce_expr_string(int rop_type) {
     const char* opstr = (rop_type == GMREDUCE_PLUS) ? "Sum" : (rop_type == GMREDUCE_MULT) ? "Product" : (rop_type == GMREDUCE_MIN) ? "Min" :
-                        (rop_type == GMREDUCE_MAX) ? "Max" : (rop_type == GMREDUCE_AND) ? "All" : (rop_type == GMREDUCE_OR) ? "Exist" : "??";
+                        (rop_type == GMREDUCE_MAX) ? "Max" : (rop_type == GMREDUCE_AND) ? "All" : (rop_type == GMREDUCE_OR) ? "Exist" :
+                        (rop_type == GMREDUCE_AVG) ? "Avg" : "??";
     return opstr;
 }
 
diff --git a/src/common/gm_reproduce.cc b/src/common/gm_reproduce.cc
index 97c9582..e3d6ae3 100644
--- a/src/common/gm_reproduce.cc
+++ b/src/common/gm_reproduce.cc
@@ -45,6 +45,13 @@ void ast_field::reproduce(int ind_level) {
     second->reproduce(0);
 }
 
+void ast_mapaccess::reproduce(int indLevel) {
+    mapId->reproduce(0);
+    Out.push('[');
+    keyExpr->reproduce(0);
+    Out.push(']');
+}
+
 void ast_typedecl::reproduce(int ind_level) {
     if (is_primitive()) {
         Out.push(gm_get_type_string(type_id));
@@ -96,6 +103,14 @@ void ast_typedecl::reproduce(int ind_level) {
     }
 }
 
+void ast_maptypedecl::reproduce(int indLevel) {
+    Out.push("Map <");
+    keyType->reproduce(0);
+    Out.push(", ");
+    valueType->reproduce(0);
+    Out.push(">");
+}
+
 void ast_argdecl::reproduce(int ind_level) {
     idlist->reproduce(0);
     Out.push(" : ");
@@ -250,6 +265,7 @@ void ast_expr::reproduce(int ind_level) {
         case GMEXPR_BIOP:
         case GMEXPR_LBIOP:
         case GMEXPR_COMP:
+            break;
         case GMEXPR_BUILTIN_FIELD:
         case GMEXPR_FOREIGN:
             //TODO add some print statements for these?
@@ -409,6 +425,18 @@ void ast_assign::reproduce(int ind_level) {
     Out.pushln(";");
 }
 
+void ast_assign_mapentry::reproduce(int indLevel) {
+    lhs->reproduce(0);
+    Out.SPC();
+    if(is_reduce_assign())
+        Out.push(gm_get_reduce_string(get_reduce_type()));
+    else
+        Out.push("=");
+    Out.SPC();
+    rhs->reproduce(0);
+    Out.pushln(";");
+}
+
 void ast_vardecl::reproduce(int ind_level) {
     type->reproduce(0);
     Out.SPC();
diff --git a/src/common/gm_resolve_inf_size.cc b/src/common/gm_resolve_inf_size.cc
index 10714cf..bb8ccd2 100644
--- a/src/common/gm_resolve_inf_size.cc
+++ b/src/common/gm_resolve_inf_size.cc
@@ -28,6 +28,7 @@ bool gm_resolve_size_of_inf_expr(ast_expr* e, int dest_type) {
         case GMEXPR_BVAL:
         case GMEXPR_INF:
         case GMEXPR_NIL:
+        case GMEXPR_MAPACCESS:
             break;
 
         case GMEXPR_UOP:
diff --git a/src/common/gm_traverse.cc b/src/common/gm_traverse.cc
index e38f801..c2d2330 100644
--- a/src/common/gm_traverse.cc
+++ b/src/common/gm_traverse.cc
@@ -290,9 +290,27 @@ void ast_bfs::traverse_sent(gm_apply*a, bool is_post, bool is_pre) {
     }
 }
 
+void ast_assign_mapentry::traverse_sent(gm_apply* a, bool is_post, bool is_pre) {
+
+    if (is_pre) {
+        a->apply(to_assign_mapentry()->get_lhs_mapaccess()->get_key_expr());
+    }
+
+    get_rhs()->traverse(a, is_post, is_pre);
+
+    if (is_post) {
+            a->apply(to_assign_mapentry()->get_lhs_mapaccess()->get_key_expr());
+    }
+}
+
 void ast_assign::traverse_sent(gm_apply*a, bool is_post, bool is_pre) {
     bool for_id = a->is_for_id();
 
+    if (is_map_entry_assign()) {
+        printf("traversexxx\n");
+        a->apply(to_assign_mapentry()->get_lhs_mapaccess()->get_key_expr());
+    }
+
     if (is_pre) {
         if (for_id) {
             if (get_lhs_type() == GMASSIGN_LHS_SCALA) {
@@ -825,6 +843,13 @@ void ast_expr::traverse(gm_apply*a, bool is_post, bool is_pre) {
                 }
             }
             break;
+        case GMEXPR_MAPACCESS: {
+            ast_mapaccess* mapAccess = ((ast_expr_mapaccess*) this)->get_mapaccess();
+            a->set_for_rhs(true);
+            mapAccess->get_key_expr()->traverse(a, is_post, is_pre);
+            a->set_for_rhs(for_rhs);
+        }
+            break;
         case GMEXPR_UOP:
         case GMEXPR_LUOP:
             get_left_op()->traverse(a, is_post, is_pre);
diff --git a/src/frontend/gm_check_property_argument_usage.cc b/src/frontend/gm_check_property_argument_usage.cc
index 93316a5..d34b11a 100644
--- a/src/frontend/gm_check_property_argument_usage.cc
+++ b/src/frontend/gm_check_property_argument_usage.cc
@@ -39,7 +39,7 @@ public:
             condition_stack.push_back(s);
         } else if (s->get_nodetype() == AST_ASSIGN) {
             ast_assign* a = (ast_assign*) s;
-            if (!a->is_target_scalar()) {
+            if (!a->is_target_scalar() && !a->is_target_map_entry()) {
                 ast_field* f = a->get_lhs_field();
                 if (a->is_reduce_assign()) {  // this is read & write
                     property_is_read(f->get_second()->getSymInfo(), f->get_first()->getSymInfo(), true);
diff --git a/src/frontend/gm_expand_group_assignment.cc b/src/frontend/gm_expand_group_assignment.cc
index ab7a5d3..4c43992 100644
--- a/src/frontend/gm_expand_group_assignment.cc
+++ b/src/frontend/gm_expand_group_assignment.cc
@@ -53,7 +53,7 @@ public:
     virtual bool apply(ast_sent *s) {
         if (s->get_nodetype() != AST_ASSIGN) return true;
         ast_assign* a = (ast_assign*) s;
-        if (a->is_target_scalar()) return true;
+        if (a->is_target_scalar() || a->is_target_map_entry()) return true;
 
         ast_field* lhs = a->get_lhs_field();
         assert(lhs != NULL);
diff --git a/src/frontend/gm_new_typecheck_step1.cc b/src/frontend/gm_new_typecheck_step1.cc
index 5cd1548..a0c1924 100644
--- a/src/frontend/gm_new_typecheck_step1.cc
+++ b/src/frontend/gm_new_typecheck_step1.cc
@@ -133,6 +135,20 @@ private:
                 return -1;
         }
     }
+
+    void checkAndSetBoundGraphsForMap(ast_mapaccess* mapAccess) {
+        ast_maptypedecl* mapDecl = (ast_maptypedecl*) mapAccess->get_map_id()->getTypeInfo();
+        ast_typedecl* keyType = mapDecl->get_key_type();
+        ast_typedecl* valueType = mapDecl->get_value_type();
+        if (gm_has_target_graph_type(keyType->getTypeSummary())) {
+            gm_symtab_entry* keyGraph = keyType->get_target_graph_sym();
+            mapAccess->set_bound_graph_for_key(keyGraph);
+        }
+        if (gm_has_target_graph_type(valueType->getTypeSummary())) {
+            gm_symtab_entry* valueGraph = valueType->get_target_graph_sym();
+            mapAccess->set_bound_graph_for_value(valueGraph);
+        }
+    }
 };
 
 // check id1 and id2 have same target graph symbol
@@ -244,6 +260,7 @@ ast_id* gm_get_default_graph(gm_symtab* symTab) {
             if (entryType->is_graph()) {
                 foundCount++;
                 if (foundCount > 1) {
+                    printf("FUU\n");
                     gm_type_error(GM_ERROR_DEFAULT_GRAPH_AMBIGUOUS, targetGraph, (*II)->getId());
                     return NULL;
                 }
@@ -288,7 +305,9 @@ bool gm_check_graph_is_defined(ast_typedecl* type, gm_symtab* symTab) {
 //     - connect nbr_id with the symbol
 //     - copy graph_id from collection_id
 //------------------------------------------------
-bool gm_check_type_is_well_defined(ast_typedecl* type, gm_symtab* SYM_V) {
+bool gm_check_type_is_well_defined(ast_typedecl* type, gm_symtab* SYM_V);
+
+bool gm_check_type_is_well_defined(ast_typedecl* type, gm_symtab* SYM_V, int targetType) {
     if (type->is_primitive() || type->is_void()) {
         //nothing to do
     } else if (type->is_graph()) {
@@ -297,7 +316,7 @@ bool gm_check_type_is_well_defined(ast_typedecl* type, gm_symtab* SYM_V) {
             gm_type_error(GM_ERROR_DEFAULT_GRAPH_AMBIGUOUS, (ast_id*) type, "", "");
             return false;
         }
-    } else if (type->is_collection() || type->is_nodeedge() || type->is_all_graph_iterator() || type->is_queue()) {
+    } else if (type->is_collection() || type->is_nodeedge() || type->is_all_graph_iterator() || type->is_collection_of_collection()) {
         bool is_okay = gm_check_graph_is_defined(type, SYM_V);
         if (!is_okay) return is_okay;
     } else if (type->is_property()) {
@@ -319,7 +338,15 @@ bool gm_check_type_is_well_defined(ast_typedecl* type, gm_symtab* SYM_V) {
         if (!is_okay) return false;
 
         // update collection iter type
-        if (type->is_unknown_collection_iterator()) type->setTypeSummary(gm_get_natural_collection_iterator(col->getTypeSummary()));
+        if (type->is_unknown_collection_iterator()) {
+            int iterType = (GMTYPE_T) gm_get_natural_collection_iterator(col->getTypeSummary());
+
+            if (iterType == GMTYPE_ITER_UNDERSPECIFIED && targetType != GMTYPE_INVALID) {
+                iterType = gm_get_specified_collection_iterator(targetType);
+            }
+
+            type->setTypeSummary(iterType);
+        }
 
         // copy graph_id
         type->set_target_graph_id(col->getTypeInfo()->get_target_graph_id()->copy(true));
@@ -335,11 +362,19 @@ bool gm_check_type_is_well_defined(ast_typedecl* type, gm_symtab* SYM_V) {
         ast_id* node = type->get_target_nbr_id();
         assert(node != NULL);
         bool is_okay = gm_check_target_is_defined(node, SYM_V, SHOULD_BE_A_NODE_COMPATIBLE);
-        if (!is_okay) return is_okay;
+        if (!is_okay) return false;
 
         // copy graph_id
         //printf("copying graph id = %s\n", node->getTypeInfo()->get_target_graph_id()->get_orgname());
         type->set_target_graph_id(node->getTypeInfo()->get_target_graph_id()->copy(true));
+    } else if (type->is_map()) {
+        ast_maptypedecl* mapType = (ast_maptypedecl*) type;
+        if(gm_has_target_graph_type(mapType->getKeyTypeSummary())) {
+            if(!gm_check_graph_is_defined(mapType->get_key_type(), SYM_V)) return false;
+        }
+        if(gm_has_target_graph_type(mapType->getValueTypeSummary())) {
+            if(!gm_check_graph_is_defined(mapType->get_value_type(), SYM_V)) return false;
+        }
     } else {
         printf("%s", gm_get_type_string(type->getTypeSummary()));
         assert(false);
@@ -349,6 +384,10 @@ bool gm_check_type_is_well_defined(ast_typedecl* type, gm_symtab* SYM_V) {
     return true;
 }
 
+bool gm_check_type_is_well_defined(ast_typedecl* type, gm_symtab* SYM_V) {
+    return gm_check_type_is_well_defined(type, SYM_V, GMTYPE_INVALID);
+}
+
 //---------------------
 // (This function can be used after type-checking)
 // add a (copy of) symbol and (copy of) type into a symtab, error if symbol is duplicated
@@ -357,14 +396,14 @@ bool gm_check_type_is_well_defined(ast_typedecl* type, gm_symtab* SYM_V) {
 //
 // The name is added to the current procedure vocaburary 
 //---------------------
-bool gm_declare_symbol(gm_symtab* SYM, ast_id* id, ast_typedecl* type, bool is_readable, bool is_writeable, gm_symtab* SYM_ALT) {
+bool gm_declare_symbol(gm_symtab* SYM, ast_id* id, ast_typedecl* type, bool is_readable, bool is_writeable, gm_symtab* SYM_ALT, int targetType) {
 
     if (!type->is_well_defined()) {
         assert(!type->is_property());
         // if so SYM is FIELD actually.
         if (SYM_ALT != NULL) {
-            if (!gm_check_type_is_well_defined(type, SYM_ALT)) return false;
-        } else if (!gm_check_type_is_well_defined(type, SYM)) {
+            if (!gm_check_type_is_well_defined(type, SYM_ALT, targetType)) return false;
+        } else if (!gm_check_type_is_well_defined(type, SYM, targetType)) {
             return false;
         }
     }
@@ -379,8 +418,12 @@ bool gm_declare_symbol(gm_symtab* SYM, ast_id* id, ast_typedecl* type, bool is_r
     return is_okay;
 }
 
+bool gm_declare_symbol(gm_symtab* SYM, ast_id* id, ast_typedecl* type, bool is_readable, bool is_writeable, gm_symtab* SYM_ALT) {
+    return gm_declare_symbol(SYM, id, type, is_readable, is_writeable, SYM_ALT, GMTYPE_INVALID);
+}
+
 bool gm_declare_symbol(gm_symtab* SYM, ast_id* id, ast_typedecl* type, bool is_readable, bool is_writeable) {
-    return gm_declare_symbol(SYM, id, type, is_readable, is_writeable, NULL);
+    return gm_declare_symbol(SYM, id, type, is_readable, is_writeable, NULL, GMTYPE_INVALID);
 }
 
 // symbol checking for foreach and in-place reduction
@@ -456,8 +499,11 @@ bool gm_typechecker_stage_1::gm_symbol_check_iter_header(ast_id* it, ast_id* src
     } else {
         type = ast_typedecl::new_nodeedge_iterator(src->copy(true), iter_type);
     }
+
     if (gm_is_iteration_on_property(iter_type))
         is_okay = gm_declare_symbol(curr_sym, it, type, GM_READ_AVAILABLE, GM_WRITE_NOT_AVAILABLE, curr_field);
+    else if (src->getTypeInfo()->is_collection_of_collection())
+        is_okay = gm_declare_symbol(curr_sym, it, type, GM_READ_AVAILABLE, GM_WRITE_NOT_AVAILABLE, NULL, src->getTargetTypeSummary());
     else
         is_okay = gm_declare_symbol(curr_sym, it, type, GM_READ_AVAILABLE, GM_WRITE_NOT_AVAILABLE);
 
@@ -598,6 +644,11 @@ bool gm_typechecker_stage_1::apply(ast_sent* s) {
             if (a->is_target_scalar()) {
                 ast_id* id = a->get_lhs_scala();
                 is_okay = find_symbol_id(id);
+            } else if(a->is_target_map_entry()){
+                ast_assign_mapentry* mapAssign = (ast_assign_mapentry*)a;
+                ast_mapaccess* mapAccess = mapAssign->get_lhs_mapaccess();
+                is_okay = find_symbol_id(mapAccess->get_map_id());
+                checkAndSetBoundGraphsForMap(mapAccess);
             } else {
                 ast_field* f = a->get_lhs_field();
                 is_okay = find_symbol_field(f);
@@ -719,6 +770,12 @@ bool gm_typechecker_stage_1::apply(ast_expr* p) {
             is_okay = find_symbol_field(p->get_field());
             break;
         }
+        case GMEXPR_MAPACCESS: {
+            is_okay = find_symbol_id(p->get_id());
+            ast_mapaccess* mapAccess = ((ast_expr_mapaccess*) p)->get_mapaccess();
+            checkAndSetBoundGraphsForMap(mapAccess);
+            break;
+        }
         case GMEXPR_REDUCE: {
             ast_expr_reduce* r = (ast_expr_reduce*) p;
             int iter_type = r->get_iter_type();
diff --git a/src/frontend/gm_new_typecheck_step2.cc b/src/frontend/gm_new_typecheck_step2.cc
index 5af4e9a..34964db 100644
--- a/src/frontend/gm_new_typecheck_step2.cc
+++ b/src/frontend/gm_new_typecheck_step2.cc
@@ -41,7 +41,7 @@ public:
 
         if (s->get_nodetype() == AST_ASSIGN) {
             ast_assign *a = (ast_assign*) s;
-            if (!a->is_target_scalar()) {
+            if (!a->is_target_scalar() && !a->is_target_map_entry()) {
                 ast_field* f = a->get_lhs_field();
                 if (f->get_first()->getTypeInfo()->is_graph() || f->get_first()->getTypeInfo()->is_collection()) {
 
@@ -141,12 +141,15 @@ bool gm_typechecker_stage_2::apply_on_builtin(ast_expr_builtin* builtinExpr) {
     int sourceType = builtinExpr->get_source_type();
     switch(sourceType) {
         case GMTYPE_PROPERTYITER_SET:
+        case GMTYPE_COLLECTIONITER_SET:
             sourceType = GMTYPE_NSET;
             break;
         case GMTYPE_PROPERTYITER_SEQ:
+        case GMTYPE_COLLECTIONITER_SEQ:
             sourceType = GMTYPE_NSEQ;
             break;
         case GMTYPE_PROPERTYITER_ORDER:
+        case GMTYPE_COLLECTIONITER_ORDER:
             sourceType = GMTYPE_NORDER;
             break;
         default:
diff --git a/src/frontend/gm_new_typecheck_step3.cc b/src/frontend/gm_new_typecheck_step3.cc
index ede5036..df5f322 100644
--- a/src/frontend/gm_new_typecheck_step3.cc
+++ b/src/frontend/gm_new_typecheck_step3.cc
@@ -23,6 +23,18 @@ public:
     gm_typechecker_stage_3() {
         _is_okay = true;
         set_for_expr(true);
+        set_for_sent(true);
+    }
+
+    bool apply(ast_sent* s) {
+        if (s->get_nodetype() == AST_ASSIGN) {
+            ast_assign* a = (ast_assign*) s;
+            if (a->is_map_entry_assign()) {
+                ast_mapaccess* mapAccess = a->to_assign_mapentry()->get_lhs_mapaccess();
+                return check_boundGraphsForKeyAndValue(mapAccess, a->get_line(), a->get_col());
+            }
+        }
+        return true;
     }
 
     // post apply
@@ -38,6 +50,9 @@ public:
                         gm_symtab_entry * g = t->get_target_graph_sym();
                         assert(g != NULL);
                         e->set_bound_graph(g);
+                    } else if (t->is_map()) {
+                        ast_maptypedecl* mapDecl = (ast_maptypedecl*) t;
+                        e->set_type_summary(mapDecl->getValueTypeSummary());
                     }
                 }
                 break;
@@ -106,6 +121,10 @@ public:
                 e->set_type_summary(GMTYPE_FOREIGN_EXPR);
                 okay = true;
                 break;
+            case GMEXPR_MAPACCESS: {
+                okay = check_mapaccess((ast_expr_mapaccess*) e);
+            }
+                break;
             default:
                 assert(false);
                 break;
@@ -131,7 +150,12 @@ private:
     bool check_binary(ast_expr* e);
     bool check_ter(ast_expr* e);
     bool check_builtin(ast_expr_builtin* e);
+    bool resolveGenericOutputType(ast_expr_builtin* b);
+    int resolveGenericInputType(ast_expr_builtin* b, int argPosition);
     bool check_arguments(ast_expr_builtin* b);
+    bool check_mapaccess(ast_expr_mapaccess* mapAccessExpr);
+    bool check_boundGraphsForKeyAndValue(ast_mapaccess* mapAccess, int line, int column);
+    int tryResolveUnknownType(int type);
 
 public:
     // expression, dest-type
@@ -176,6 +200,59 @@ static bool check_special_case_inside_group_assign(ast_id* l_id, int alt_type_l,
     return true;
 }
 
+bool gm_typechecker_stage_3::check_mapaccess(ast_expr_mapaccess* mapAccessExpr) {
+    mapAccessExpr->set_type_summary(mapAccessExpr->get_id()->getTypeSummary());
+    ast_typedecl* t = mapAccessExpr->get_id()->getTypeInfo();
+    ast_maptypedecl* mapDecl = (ast_maptypedecl*) t;
+    mapAccessExpr->set_type_summary(mapDecl->getValueTypeSummary());
+
+    //check if key-type and key-expression-type are compatible
+    ast_mapaccess* mapAccess = mapAccessExpr->get_mapaccess();
+    ast_expr* keyExpr = mapAccess->get_key_expr();
+    int keyExprType = keyExpr->get_type_summary();
+
+    gm_symtab_entry* mapEntry = mapAccess->get_map_id()->getSymInfo();
+    assert(mapEntry != NULL);
+    assert(mapEntry->getType()->is_map());
+    ast_maptypedecl* mapTypeDecl = (ast_maptypedecl*) mapEntry->getType();
+    int keyType = mapTypeDecl->getKeyTypeSummary();
+
+    int dummy;
+    bool warning;
+    bool isOkay = gm_is_compatible_type_for_assign(keyType, keyExprType, dummy, warning);
+    int line = mapAccessExpr->get_line();
+    int column = mapAccessExpr->get_col();
+    if (!isOkay) {
+        gm_type_error(GM_ERROR_KEY_MISSMATCH, line, column, gm_get_type_string(keyType), gm_get_type_string(keyExprType));
+    } else if (warning) {
+        printf("warning: implicit type conversion %s->%s\n", gm_get_type_string(keyType), gm_get_type_string(keyExprType));
+    }
+
+    isOkay &= check_boundGraphsForKeyAndValue(mapAccess, line, column);
+    return isOkay;
+}
+
+bool gm_typechecker_stage_3::check_boundGraphsForKeyAndValue(ast_mapaccess* mapAccess, int line, int column) {
+    //check if target graphs for key are the same
+    int keyType = mapAccess->get_key_expr()->get_type_summary();
+    if (gm_has_target_graph_type(keyType)) {
+        gm_symtab_entry* keyGraph = mapAccess->get_bound_graph_for_key();
+        ast_expr* keyExpr = mapAccess->get_key_expr();
+        int keyExprType = keyExpr->get_type_summary();
+        gm_symtab_entry* keyExprGraph = keyExpr->get_bound_graph();
+        if (keyExprGraph == NULL) {
+            assert(gm_is_nil_type(keyExprType) || gm_is_foreign_expr_type(keyExprType));
+        } else {
+            if (keyGraph != keyExprGraph) {
+                gm_type_error(GM_ERROR_TARGET_MISMATCH, line, column);
+                return false;
+            }
+        }
+    }
+    return true;
+}
+;
+
 // comparison (eq, neq and less)
 bool gm_typechecker_stage_3::check_binary(ast_expr* e) {
     int op_type = e->get_optype();
@@ -287,6 +364,33 @@ static bool gm_is_compatible_type_collection_of_collection(int shouldbeType, int
     return true;
 }
 
+int gm_typechecker_stage_3::resolveGenericInputType(ast_expr_builtin* b, int argPosition) {
+
+    gm_builtin_def* def = b->get_builtin_def();
+    ast_id* driver = b->get_driver();
+    assert(driver->getTypeSummary() == GMTYPE_MAP);
+    // we only support maps atm
+    ast_typedecl* typeDecl = driver->getTypeInfo();
+    ast_maptypedecl* mapTypeDecl = (ast_maptypedecl*) typeDecl;
+    if (def->genericArgumentTypeIsKeyType(argPosition))
+        return mapTypeDecl->getKeyTypeSummary();
+    else
+        return mapTypeDecl->getValueTypeSummary();
+}
+
+int gm_typechecker_stage_3::tryResolveUnknownType(int type) {
+    switch (type) {
+        case GMTYPE_COLLECTIONITER_SET:
+            return GMTYPE_NSET;
+        case GMTYPE_COLLECTIONITER_ORDER:
+            return GMTYPE_NORDER;
+        case GMTYPE_COLLECTIONITER_SEQ:
+            return GMTYPE_NSEQ;
+        default:
+            return type;
+    }
+}
+
 bool gm_typechecker_stage_3::check_arguments(ast_expr_builtin* b) {
 
     bool okay = true;
@@ -299,17 +403,23 @@ bool gm_typechecker_stage_3::check_arguments(ast_expr_builtin* b) {
         ast_expr* e = *iter;
         int currentType = e->get_type_summary();
         int def_type = def->get_arg_type(position);
-        if (gm_is_unknown_type(currentType)) {
+        if (def_type == GMTYPE_GENERIC) {
+            def_type = (int) resolveGenericInputType(b, position);
+        } else if (gm_is_unknown_type(currentType)) {
             okay = false;
             continue;
         }
+
+        currentType = tryResolveUnknownType(currentType);
+
         bool warning;
         int coerced_type;
         bool isCompatible;
-        if (gm_is_queue_type(b->get_source_type()))
+        if (gm_is_collection_of_collection_type(b->get_source_type())) {
             isCompatible = gm_is_compatible_type_collection_of_collection(b->get_driver()->getTargetTypeSummary(), currentType, def->get_method_id());
-        else
+        } else {
             isCompatible = gm_is_compatible_type_for_assign(def_type, currentType, coerced_type, warning);
+        }
         if (!isCompatible) {
             char temp[20];
             sprintf(temp, "%d", position + 1);
@@ -329,6 +439,10 @@ bool gm_typechecker_stage_3::check_builtin(ast_expr_builtin* b) {
     bool okay = check_arguments(b);
     gm_builtin_def* def = b->get_builtin_def();
     int fun_ret_type = def->get_result_type_summary();
+
+    if (fun_ret_type == GMTYPE_GENERIC) {
+        return resolveGenericOutputType(b);
+    }
     b->set_type_summary(fun_ret_type);
 
     if (gm_has_target_graph_type(fun_ret_type)) {
@@ -342,6 +456,33 @@ bool gm_typechecker_stage_3::check_builtin(ast_expr_builtin* b) {
     return okay;
 }
 
+bool gm_typechecker_stage_3::resolveGenericOutputType(ast_expr_builtin* b) {
+    gm_builtin_def* def = b->get_builtin_def();
+    ast_id* driver = b->get_driver();
+    assert(driver->getTypeSummary() == GMTYPE_MAP);
+    ast_typedecl* typeDecl = driver->getTypeInfo();
+    assert(typeDecl->is_map());
+    ast_maptypedecl* mapTypeDecl = (ast_maptypedecl*) typeDecl;
+    int funcReturnType;
+    if (def->genericTypeIsKeyType())
+        funcReturnType = mapTypeDecl->getKeyTypeSummary();
+    else
+        funcReturnType = mapTypeDecl->getValueTypeSummary();
+
+    b->set_type_summary(funcReturnType);
+
+    if (gm_has_target_graph_type(funcReturnType)) {
+        gm_symtab_entry* graph;
+        if (def->genericTypeIsKeyType())
+            graph = mapTypeDecl->get_key_type()->get_target_graph_sym();
+        else
+            graph = mapTypeDecl->get_value_type()->get_target_graph_sym();
+        b->set_bound_graph(graph);
+    }
+
+    return true;
+}
+
 // type resolve for u-op
 bool gm_typechecker_stage_3::check_uop(ast_expr* e) {
     int op_type = e->get_optype();
diff --git a/src/frontend/gm_new_typecheck_step4.cc b/src/frontend/gm_new_typecheck_step4.cc
index 7813e59..0e8ed13 100644
--- a/src/frontend/gm_new_typecheck_step4.cc
+++ b/src/frontend/gm_new_typecheck_step4.cc
@@ -36,6 +36,10 @@ public:
             int lhs_type;
             if (a->is_target_scalar()) {
                 lhs_type = a->get_lhs_scala()->getTypeSummary();
+            } else if (a->is_target_map_entry()) {
+                ast_mapaccess* mapAccess = a->to_assign_mapentry()->get_lhs_mapaccess();
+                ast_maptypedecl* mapDecl = (ast_maptypedecl*)mapAccess->get_map_id()->getTypeInfo();
+                lhs_type = mapDecl->getValueTypeSummary();
             } else {
                 lhs_type = a->get_lhs_field()->getTargetTypeSummary();
             }
diff --git a/src/frontend/gm_new_typecheck_step5.cc b/src/frontend/gm_new_typecheck_step5.cc
index 5bf220c..4a1d107 100644
--- a/src/frontend/gm_new_typecheck_step5.cc
+++ b/src/frontend/gm_new_typecheck_step5.cc
@@ -124,6 +124,24 @@ public:
                 gm_type_error(GM_ERROR_READONLY, l);
                 return false;
             }
+        } else if (lhs->get_nodetype() == AST_MAPACCESS) {
+            ast_mapaccess* mapAccess = (ast_mapaccess*) lhs;
+            ast_maptypedecl* mapDecl = (ast_maptypedecl*) mapAccess->get_map_id()->getTypeInfo();
+            l_sym = mapAccess->get_bound_graph_for_value();
+            summary_lhs = mapDecl->getValueTypeSummary();
+
+            int keyType = mapDecl->getKeyTypeSummary();
+            int keyExprType = mapAccess->get_key_expr()->get_type_summary();
+            int dummy;
+            bool warning;
+            bool isOkay = gm_is_compatible_type_for_assign(keyType, keyExprType, dummy, warning);
+            if (!isOkay) {
+                gm_type_error(GM_ERROR_KEY_MISSMATCH, l, c, gm_get_type_string(keyType), gm_get_type_string(keyExprType));
+                return false;
+            } else if (warning) {
+                printf("warning: implicit type conversion %s->%s\n", gm_get_type_string(keyType), gm_get_type_string(keyExprType));
+            }
+
         } else {
             // target type (e.g. N_P<Int> -> Int)
             ast_field* f = (ast_field*) lhs;
@@ -132,11 +150,11 @@ public:
             if (f->getTargetTypeInfo()->has_target_graph()) {
                 l_sym = f->getTargetTypeInfo()->get_target_graph_sym();
             }
-
         }
 
         // check assignable
         summary_rhs = rhs->get_type_summary();
+        summary_rhs = tryResolveIfUnknown(summary_rhs);
 
         bool warn;
         int coed;
@@ -150,16 +168,14 @@ public:
         }
 
         if (gm_has_target_graph_type(summary_lhs)) {
-            gm_symtab_entry* r_sym = rhs->get_bound_graph();
-            assert(l_sym != NULL);
-            if (r_sym == NULL) {
-                assert(gm_is_nil_type(summary_rhs) || gm_is_foreign_expr_type(summary_rhs));
+            gm_symtab_entry* r_sym;
+            if (rhs->is_mapaccess()) {
+                ast_mapaccess* mapAccess = ((ast_expr_mapaccess*) rhs)->get_mapaccess();
+                r_sym = mapAccess->get_bound_graph_for_value();
             } else {
-                if (l_sym != r_sym) {
-                    gm_type_error(GM_ERROR_TARGET_MISMATCH, l, c);
-                    return false;
-                }
+                r_sym = rhs->get_bound_graph();
             }
+            return checkGraphs(l_sym, r_sym, summary_rhs, l, c);
         }
 
         return true;
@@ -173,11 +189,15 @@ public:
         if (a->is_target_scalar()) {
             okay = check_assign_lhs_rhs(a->get_lhs_scala(), a->get_rhs(), l, c);
             summary_lhs = a->get_lhs_scala()->getTypeSummary();
+        } else if (a->is_target_map_entry()) {
+            ast_mapaccess* mapAccess = a->to_assign_mapentry()->get_lhs_mapaccess();
+            okay = check_assign_lhs_rhs(mapAccess, a->get_rhs(), l, c);
+            ast_maptypedecl* mapDecl = (ast_maptypedecl*) mapAccess->get_map_id()->getTypeInfo();
+            summary_lhs = mapDecl->getValueTypeSummary();
         } else {
             okay = check_assign_lhs_rhs(a->get_lhs_field(), a->get_rhs(), l, c);
             summary_lhs = a->get_lhs_field()->get_second()->getTargetTypeSummary();
         }
-
         // check body of reduce
         if (a->is_reduce_assign()) {
 
@@ -236,6 +256,31 @@ private:
     bool _is_okay;
     ast_typedecl* ret;
 
+    bool checkGraphs(gm_symtab_entry* l_sym, gm_symtab_entry* r_sym, int summary_rhs, int line, int column) {
+        assert(l_sym != NULL);
+        if (r_sym == NULL) {
+            assert(gm_is_nil_type(summary_rhs) || gm_is_foreign_expr_type(summary_rhs));
+        } else {
+            if (l_sym != r_sym) {
+                gm_type_error(GM_ERROR_TARGET_MISMATCH, line, column);
+                return false;
+            }
+        }
+        return true;
+    }
+
+    int tryResolveIfUnknown(int type) {
+        switch (type) {
+            case GMTYPE_PROPERTYITER_SET:
+                return GMTYPE_NSET;
+            case GMTYPE_PROPERTYITER_SEQ:
+                return GMTYPE_NSEQ;
+            case GMTYPE_PROPERTYITER_ORDER:
+                return GMTYPE_NORDER;
+        }
+        return type;
+    }
+
 public:
     std::map<ast_expr*, int> coercion_targets;
 };
diff --git a/src/frontend/gm_rw_analysis.cc b/src/frontend/gm_rw_analysis.cc
index 6766930..944f4c2 100644
--- a/src/frontend/gm_rw_analysis.cc
+++ b/src/frontend/gm_rw_analysis.cc
@@ -344,6 +344,11 @@ void traverse_expr_for_readset_adding(ast_expr* e, gm_rwinfo_map& rset, temp_map
         case GMEXPR_FIELD:
             traverse_expr_for_readset_adding_field(e, rset, DrvMap);
             break;
+        case GMEXPR_MAPACCESS: {
+            ast_mapaccess* mapAccess = ((ast_expr_mapaccess*) e)->get_mapaccess();
+            traverse_expr_for_readset_adding(mapAccess->get_key_expr(), rset, DrvMap);//TODO
+        }
+            break;
         case GMEXPR_UOP:
         case GMEXPR_LUOP:
             traverse_expr_for_readset_adding(e->get_left_op(), rset, DrvMap);
@@ -489,7 +494,7 @@ bool gm_rw_analysis::apply_assign(ast_assign *a) {
     gm_rwinfo_map& D = sets->reduce_set;
 
     // (1) LHS
-    bool is_reduce = (a->is_reduce_assign() || a->is_defer_assign());
+    bool is_reduce = (a->is_reduce_assign() || a->is_defer_assign()) && !a->is_map_entry_assign();
     gm_symtab_entry* bound_sym = NULL;
     int bound_op = GMREDUCE_NULL;
     if (is_reduce) {
@@ -505,6 +510,10 @@ bool gm_rw_analysis::apply_assign(ast_assign *a) {
     if (a->get_lhs_type() == GMASSIGN_LHS_SCALA) {
         target_sym = a->get_lhs_scala()->getSymInfo();
         new_entry = gm_rwinfo::new_scala_inst(a->get_lhs_scala(), bound_op, bound_sym);
+    } else if (a->get_lhs_type() == GMASSIGN_LHS_MAP) {
+        ast_mapaccess* mapAccess = a->to_assign_mapentry()->get_lhs_mapaccess();
+        target_sym = mapAccess->get_map_id()->getSymInfo();
+        new_entry = gm_rwinfo::new_scala_inst(mapAccess->get_map_id(), bound_op, bound_sym);//TODO
     } else {
         target_sym = a->get_lhs_field()->get_second()->getSymInfo();
         gm_symtab_entry* iter_sym = a->get_lhs_field()->get_first()->getSymInfo();
@@ -990,8 +999,7 @@ static bool cleanup_iterator_access_reduce(ast_id* iter, gm_rwinfo_map& D_temp,
                     if (cp->access_range != GM_RANGE_SINGLE) {
                         cp->access_range = GM_RANGE_RANDOM; // scalar access becomes random access
                     }
-                }
-                else if (!cp->driver->getType()->is_node_edge_iterator()) {
+                } else if (!cp->driver->getType()->is_node_edge_iterator()) {
                     cp->access_range = GM_RANGE_RANDOM;
                     cp->driver = NULL;
                 }
@@ -1065,7 +1073,6 @@ bool gm_rw_analysis::apply_foreach(ast_foreach* a) {
     //printf("R:");gm_print_rwinfo_set(R);
     //printf("done\n");
 
-
     return is_okay;
 }
 
diff --git a/src/frontend/gm_typecheck_oprules.cc b/src/frontend/gm_typecheck_oprules.cc
index 7f2d801..d7618d9 100644
--- a/src/frontend/gm_typecheck_oprules.cc
+++ b/src/frontend/gm_typecheck_oprules.cc
@@ -226,6 +227,10 @@ bool gm_is_compatible_type(int op, int t1, int t2, int& op_result_type, int& t1_
         t2 = t1;
     }
 
+    if ((gm_is_set_collection_type(t1) && gm_is_collection_of_set_iter_type(t2))
+            || (gm_is_sequence_collection_type(t1) && gm_is_collection_of_seq_iter_type(t2))
+            || (gm_is_order_collection_type(t1) && gm_is_collection_of_order_iter_type(t2))) t2 = t1;
+
     for (int i = 0; i < (int) GM_TYPE_RULES.size(); i++) {
         gm_type_rule& R = GM_TYPE_RULES[i];
 
diff --git a/src/inc/gm_ast.h b/src/inc/gm_ast.h
index 319459b..a54f1c0 100644
--- a/src/inc/gm_ast.h
+++ b/src/inc/gm_ast.h
@@ -17,6 +17,7 @@ enum AST_NODE_TYPE
 {
     AST_ID,       // 
     AST_FIELD,    // A.B
+    AST_MAPACCESS,    // A[B]
     AST_IDLIST,   // A, B, C, 
     AST_TYPEDECL, // INT
     AST_ARGDECL,  // a,b : B
@@ -25,6 +26,7 @@ enum AST_NODE_TYPE
     AST_EXPR_RDC,       // c + 3
     AST_EXPR_BUILTIN,   // c + 3
     AST_EXPR_FOREIGN,  // Foreign Expression
+    AST_EXPR_MAPACCESS,
     AST_SENT,     // 
     AST_SENTBLOCK, // { ... }
     AST_ASSIGN,   // C =D
@@ -568,7 +573,7 @@ private:
 
 class ast_typedecl: public ast_node
 {  // property or type
-private:
+protected:
     ast_typedecl() :
             ast_node(AST_TYPEDECL), target_type(NULL), target_graph(NULL), target_collection(NULL), target_nbr(NULL), target_nbr2(NULL), _well_defined(false), type_id(
                     0) {
@@ -576,7 +581,7 @@ private:
 
 public:
     // give a deep copy
-    ast_typedecl* copy() {
+    virtual ast_typedecl* copy() {
         ast_typedecl *p = new ast_typedecl();
         p->type_id = this->type_id;
         p->target_type = (this->target_type == NULL) ? NULL : this->target_type->copy();
@@ -671,7 +676,7 @@ public:
 
     static ast_typedecl* new_queue(ast_id* targetGraph, ast_typedecl* collectionType) {
         ast_typedecl* typeDecl = new ast_typedecl();
-        typeDecl->type_id = GMTYPE_QUEUE;
+        typeDecl->type_id = GMTYPE_COLLECTION;
         typeDecl->target_type = collectionType;
         if (targetGraph == NULL) return typeDecl; //no graph defined for this queue - we will handle this later (typecheck step 1)
         typeDecl->target_graph = targetGraph;
@@ -734,7 +739,7 @@ public:
         return t;
     }
 
-    int get_typeid() {
+    virtual int get_typeid() {
         return type_id;
     }
 
@@ -779,8 +784,8 @@ public:
         return gm_is_collection_type(type_id);
     }
 
-    bool is_queue() {
-        return gm_is_queue_type(type_id);
+    bool is_collection_of_collection() {
+        return gm_is_collection_of_collection_type(type_id);
     }
 
     bool is_node_collection() {
@@ -875,6 +880,10 @@ public:
         return gm_is_sequential_collection_type(type_id);
     }
 
+    virtual bool is_map() {
+        return false;
+    }
+
     virtual void reproduce(int id_level);
     virtual void dump_tree(int id_level);
 
@@ -886,7 +895,7 @@ public:
             assert(target_collection->getTypeInfo() != NULL);
             assert(target_collection->getTypeInfo()->get_target_graph_sym() != NULL);
             return target_collection->getTypeInfo()->get_target_graph_sym();
-        } else if (is_collection() || is_property() || is_nodeedge() || is_node_iterator() || is_edge_iterator() || is_queue()) {
+        } else if (is_collection() || is_property() || is_nodeedge() || is_node_iterator() || is_edge_iterator() || is_collection_of_collection() || gm_is_property_iter_type(type_id)) {
             assert(target_graph != NULL);
             assert(target_graph->getSymInfo() != NULL);
             return target_graph->getSymInfo();
@@ -921,7 +930,7 @@ public:
         return target_type;
     }
 
-    int getTypeSummary() {  // same as get type id
+    virtual int getTypeSummary() {  // same as get type id
         return type_id;
     }
 
@@ -931,7 +940,7 @@ public:
     }
 
     int getTargetTypeSummary() {
-        assert(is_property() || is_queue());
+        assert(is_property() || is_collection_of_collection());
         assert(target_type != NULL);
         return target_type->getTypeSummary();
     }
@@ -958,15 +967,100 @@ public:
 
 private:
     // defined in gm_frontend_api.h
-    int type_id;
     ast_typedecl* target_type;  // for property
     ast_id* target_graph;       // for property, node, edge, set
     ast_id* target_collection;  // for set-iterator set
     ast_id* target_nbr;         // for nbr-iterator
     ast_id* target_nbr2;        // for common neighbor iterator
+
+protected:
+    int type_id;
     bool _well_defined;
 };
@@ -1379,7 +1474,6 @@ protected:
                     GMTYPE_UNKNOWN), bound_graph_sym(NULL) {
     }
 
-protected:
     GMEXPR_CLASS expr_class;  // GMEXPR_...
     ast_expr* left;
     ast_expr* right;
@@ -1402,62 +1496,85 @@ public:
     bool is_foreign() {
         return expr_class == GMEXPR_FOREIGN;
     }
 
+    virtual bool is_mapaccess() {
+        return false;
+    }
+
     //-----------------------------------------------
     // type is set after type-checker execution
     //-----------------------------------------------
     int get_type_summary() {
         return type_of_expression;
     }
+
     void set_type_summary(int t) {
         type_of_expression = t;
     } // set by type checker
 
     gm_symtab_entry* get_bound_graph() {
+        if (bound_graph_sym == NULL && is_id())
+            return id1->getTypeInfo()->get_target_graph_sym();
+        else
         return bound_graph_sym;
     }
+
     void set_bound_graph(gm_symtab_entry*e) {
         bound_graph_sym = e;
     }
@@ -1477,7 +1594,8 @@ public:
     bool is_plus_inf() {
         return is_inf() && plus_inf;
     } // true o
-    ast_id* get_id() {
+
+    virtual ast_id* get_id() {
         return id1;
     }
 
@@ -1485,11 +1603,11 @@ public:
         return field;
     }
 
-    GMEXPR_CLASS get_opclass() {
+    virtual GMEXPR_CLASS get_opclass() {
         return expr_class;
     }
 
-    int get_optype() {
+    virtual int get_optype() {
         return op_type;
     }
 
@@ -1813,43 +2055,55 @@ public:
         return true;
     }
 
+    // [xxx] should it be getIterator()->getTypeSummary()?
     int get_iter_type() {
         return iter_type;
     }
+
     void set_iter_type(int i) {
         iter_type = i;
     }
@@ -1874,11 +2129,14 @@ enum gm_assignment_t
 {
     GMASSIGN_NORMAL, GMASSIGN_REDUCE, GMASSIGN_DEFER, GMASSIGN_INVALID
 };
+
 enum gm_assignment_location_t
 {
-    GMASSIGN_LHS_SCALA, GMASSIGN_LHS_FIELD, GMASSIGN_LHS_END
+    GMASSIGN_LHS_SCALA, GMASSIGN_LHS_FIELD, GMASSIGN_LHS_MAP, GMASSIGN_LHS_END
 };
 
+class ast_assign_mapentry;
+
 class ast_assign: public ast_sent
 {
 public:
@@ -1930,15 +2189,19 @@ public:
     int get_assign_type() {
         return assign_type;
     }
-    int get_lhs_type() {
+
+    virtual int get_lhs_type() {
         return lhs_type;
     }
@@ -1946,28 +2209,40 @@ public:
     bool is_reduce_assign() {
         return assign_type == GMASSIGN_REDUCE;
     }
+
     bool is_defer_assign() {
         return assign_type == GMASSIGN_DEFER;
     }
-    bool is_target_scalar() {
+
+    virtual bool is_target_scalar() {
         return get_lhs_type() == GMASSIGN_LHS_SCALA;
     }
+
+    virtual bool is_target_map_entry() {
+        return false;
+    }
+
     void set_rhs(ast_expr* r) {
         rhs = r;
         rhs->set_parent(this);
@@ -2005,24 +2280,105 @@ public:
         if (new_id != NULL) lhs_type = GMASSIGN_LHS_FIELD;
     }
 
-private:
+    virtual bool is_map_entry_assign() {
+        return false;
+    }
+
+    virtual ast_assign_mapentry* to_assign_mapentry() {
+        assert(false);
+        return NULL;
+    }
+
+    void set_is_reference(bool is_ref) {
+        isReference = is_ref;
+    }
+
+    bool is_reference() {
+        return isReference;
+    }
+
+protected:
     ast_assign() :
-            ast_sent(AST_ASSIGN), lhs_scala(NULL), lhs_field(NULL), rhs(NULL), bound(NULL), arg_minmax(false), lhs_type(0), assign_type(0), reduce_type(0) {
+            ast_sent(AST_ASSIGN), lhs_scala(NULL), lhs_field(NULL), rhs(NULL), bound(NULL), arg_minmax(false), lhs_type(0), assign_type(0), reduce_type(0), isReference(false) {
     }
 
+private:
     int assign_type; // normal, deferred, reduce
     int lhs_type; // scalar, field
     int reduce_type; // add, mult, min, max
     ast_id* lhs_scala;
     ast_field* lhs_field;
-    ast_expr* rhs;
+
     ast_id* bound;  // bounding iterator
 
     bool arg_minmax;
+    bool isReference;
 
     std::list<ast_node*> l_list;
     std::list<ast_expr*> r_list;
 
+protected:
+    ast_expr* rhs;
+
+};
+
diff --git a/src/inc/gm_backend_cpp.h b/src/inc/gm_backend_cpp.h
index 59eae0c..ea28fd3 100644
--- a/src/inc/gm_backend_cpp.h
+++ b/src/inc/gm_backend_cpp.h
@@ -44,9 +45,8 @@ public:
     virtual void generate_sent_nop(ast_nop* n);
     virtual void generate_expr_builtin(ast_expr_builtin* e, gm_code_writer& Body);
     virtual void generate_expr_nil(ast_expr* e, gm_code_writer& Body);
-
     virtual bool add_collection_def(ast_id* set);
-
+    virtual void add_map_def(ast_maptypedecl* map, ast_id* mapId);
     virtual void build_up_language_voca(gm_vocabulary& V);
 
     virtual bool need_up_initializer(ast_foreach* fe);
@@ -56,15 +56,63 @@ public:
     virtual void generate_foreach_header(ast_foreach* fe, gm_code_writer& Body);
 
 private:
+    //map sizes
+    static const int SMALL = 0;
+    static const int MEDIUM = 1;
+    static const int LARGE = 2;
+
+    char str_buf[1024 * 8];
+    gm_cpp_gen* main;
+
     virtual void generate_expr_builtin_field(ast_expr_builtin_field* builtinExpr, gm_code_writer& body);
     const char* get_function_name_graph(int methodId);
     const char* get_function_name_nset(int methodId, bool in_parallel = false);
     const char* get_function_name_nseq(int methodId);
     const char* get_function_name_norder(int methodId);
+    const char* get_function_name_map(int methodId, bool in_parallel = false);
+    const char* get_function_name_map_seq(int methodId);
+    const char* get_function_name_map_par(int methodId);
     void add_arguments_and_thread(gm_code_writer& body, ast_expr_builtin* builtinExpr, bool addThreadId);
+    const char* getMapDefaultValueForType(int type);
+    const char* getMapTypeString(int mapType);
+    const char* getAdditionalMapParameters(int mapType);
+
+    static const char* get_primitive_type_string(int type_id) {
+        switch (type_id) {
+            case GMTYPE_BYTE:
+                return "int8_t";
+            case GMTYPE_SHORT:
+                return "int16_t";
+            case GMTYPE_INT:
+                return "int32_t";
+            case GMTYPE_LONG:
+                return "int64_t";
+            case GMTYPE_FLOAT:
+                return "float";
+            case GMTYPE_DOUBLE:
+                return "double";
+            case GMTYPE_BOOL:
+                return "bool";
+            default:
+                assert(false);
+                return "??";
+        }
+    }
+
+    static const char* getTypeString(int type) {
+        if (gm_is_prim_type(type)) {
+            return get_primitive_type_string(type);
+        } else if (gm_is_node_type(type)) {
+            return NODE_T;
+        } else if (gm_is_edge_type(type)) {
+            return EDGE_T;
+        } else {
+            assert(false);
+        }
+        return NULL;
+    }
+
 
-    char str_buf[1024 * 8];
-    gm_cpp_gen* main;
 };
 
 //-----------------------------------------------------------------
@@ -183,6 +231,7 @@ public:
     virtual void generate_sent_return(ast_return *r);
     virtual void generate_sent_call(ast_call* c);
     virtual void generate_sent_assign(ast_assign* a);
+    virtual const char* get_function_name_map_reduce_assign(int reduceType);
 
     virtual void generate_sent_block_enter(ast_sentblock *b);
     virtual void generate_sent_block_exit(ast_sentblock* b);
@@ -218,6 +267,7 @@ private:
     const char* get_function_name(int methodId, bool& addThreadId);
     void generate_idlist_primitive(ast_idlist* idList);
     void generate_lhs_default(int type);
+    void generate_sent_map_assign(ast_assign_mapentry* a);
 };
 
 extern gm_cpp_gen CPP_BE;
diff --git a/src/inc/gm_backend_giraph.h b/src/inc/gm_backend_giraph.h
index f7c85e2..270c3d3 100644
--- a/src/inc/gm_backend_giraph.h
+++ b/src/inc/gm_backend_giraph.h
@@ -41,7 +41,8 @@ public:
     virtual void generate_broadcast_reduce_initialize_master(ast_id* id, gm_code_writer& Body, int reduce_type, const char* base_value);
     virtual void generate_broadcast_state_master(const char* state_var, gm_code_writer& Body);
     virtual void generate_broadcast_isFirst_master(const char* var, gm_code_writer& Body);
-    virtual void generate_broadcast_variable_type(int gm_type_id, gm_code_writer& Body, int reduce_op = GMREDUCE_NULL);
+    virtual void generate_broadcast_aggregator_type(int gm_type_id, gm_code_writer& Body, int reduce_op = GMREDUCE_NULL);
+    virtual void generate_broadcast_writable_type(int gm_type_id, gm_code_writer& Body);
     virtual void generate_broadcast_send_master(ast_id* id, gm_code_writer& Body);
     virtual void generate_broadcast_receive_master(ast_id* id, gm_code_writer& Body, int reduce_op = GMREDUCE_NULL);
     virtual void generate_headers(gm_code_writer& Body);
@@ -129,10 +137,11 @@ protected:
     void do_generate_scalar_broadcast_receive(gm_gps_basic_block *b);
     void do_generate_shared_variables_keys();
 
-    void do_generate_vertex();
+    void do_generate_vertex_begin();
+    void do_generate_vertex_body();
+    void do_generate_vertex_end();
     void do_generate_worker_context_class();
     void do_generate_vertex_property_class(bool is_edge_prop);
-    void do_generate_vertex_class();
     void do_generate_message_class();
     void do_generate_vertex_states();
     void do_generate_vertex_state_body(gm_gps_basic_block *b);
diff --git a/src/inc/gm_backend_gps.h b/src/inc/gm_backend_gps.h
index 1a2ad72..52a0e28 100644
--- a/src/inc/gm_backend_gps.h
+++ b/src/inc/gm_backend_gps.h
@@ -131,6 +131,8 @@ DEF_STRING(GPS_TAG_COMM_ID);
 // is pararell
 class gm_gps_gen : public gm_backend, public gm_code_generator
 {
+	friend class gm_giraph_gen;
+
 public:
     gm_gps_gen() :
             gm_code_generator(Body), dname(NULL), fname(NULL), f_body(NULL) {
diff --git a/src/inc/gm_code_writer.h b/src/inc/gm_code_writer.h
index 5e47b52..6c31543 100644
--- a/src/inc/gm_code_writer.h
+++ b/src/inc/gm_code_writer.h
@@ -237,6 +237,8 @@ public:
         return gm_need_paranthesis(optype, up_optype, is_right);
     }
 
+    virtual void generate_mapaccess(ast_expr_mapaccess* e);
+
     virtual void generate_lhs_id(ast_id* i) =0;
     virtual void generate_lhs_field(ast_field* i) =0;
     virtual void generate_sent_nop(ast_nop* n) =0;
diff --git a/src/inc/gm_defs.h b/src/inc/gm_defs.h
index f4a6aa4..e58f727 100644
--- a/src/inc/gm_defs.h
+++ b/src/inc/gm_defs.h
@@ -278,18 +302,22 @@ inline static bool gm_is_sequence_collection_type(int i) {
     return gm_is_node_sequence_type(i) || gm_is_edge_sequence_type(i);
 }
 
-inline static bool gm_is_collection_type(int i) {
-    return gm_is_node_collection_type(i) || gm_is_edge_collection_type(i);
+inline static bool gm_is_collection_of_collection_type(int type) {
+    return type == GMTYPE_COLLECTION;
 }
 
-inline static bool gm_is_queue_type(int type) {
-    return type == GMTYPE_QUEUE;
+inline static bool gm_is_collection_type(int i) {
+    return gm_is_node_collection_type(i) || gm_is_edge_collection_type(i) || gm_is_collection_of_collection_type(i);
 }
 
 inline static bool gm_is_sequential_collection_type(int i) {
     return gm_is_sequence_collection_type(i) || gm_is_order_collection_type(i);
 }
 
+inline static bool gm_is_map_type(int i) {
+    return i == GMTYPE_MAP;
+}
+
 // node set -> nodeset iter
 // edge set -> edgeset iter ...
 inline int gm_get_natural_collection_iterator(int src_type) {
@@ -305,16 +333,35 @@ inline int gm_get_natural_collection_iterator(int src_type) {
         return GMTYPE_NODEITER_SEQ;
     else if (src_type == GMTYPE_EORDER)
         return GMTYPE_NODEITER_ORDER;
+    else if (src_type == GMTYPE_COLLECTION)
+        return GMTYPE_ITER_UNDERSPECIFIED; //handle that later
     else {
         assert(false);
-        return 0;
+        return GMTYPE_INVALID;
+    }
+}
+
+inline int gm_get_specified_collection_iterator(int type) {
+    switch (type) {
+        case GMTYPE_NSET:
+        case GMTYPE_ESET:
+            return GMTYPE_COLLECTIONITER_SET;
+        case GMTYPE_NSEQ:
+        case GMTYPE_ESEQ:
+            return GMTYPE_COLLECTIONITER_SEQ;
+        case GMTYPE_NORDER:
+        case GMTYPE_EORDER:
+            return GMTYPE_COLLECTIONITER_ORDER;
+        default:
+            assert(false);
+            return GMTYPE_INVALID;
     }
 }
 
 // return true if this type has a target graph
 inline bool gm_has_target_graph_type(int t) {
     return gm_is_node_edge_compatible_type(t) || // any node-edge iterator (including collection iterator)
-            gm_is_collection_type(t) || gm_is_queue_type(t);
+            gm_is_collection_type(t) || gm_is_collection_of_collection_type(t);
 }
 
 inline static bool gm_is_same_type(int i1, int i2) {
@@ -326,7 +373,7 @@ inline static bool gm_is_same_node_or_edge_compatible_type(int i1, int i2) {
 }
 
 inline static bool gm_collection_of_collection_compatible_type(int def_src, int source_type) {
-    return gm_is_order_collection_type(def_src) && gm_is_queue_type(source_type);
+    return gm_is_order_collection_type(def_src) && gm_is_collection_of_collection_type(source_type);
 }
 
 enum GM_OPS_T
@@ -429,46 +488,67 @@ inline static bool gm_is_iteration_on_property(int iterType) {
 inline static bool gm_is_iteration_on_neighbors_compatible(int itype) {
     return gm_is_any_nbr_node_iter_type(itype);
 }
 
+inline static bool gm_can_be_key_type(GMTYPE_T type) {
+    return gm_is_prim_type(type) || gm_is_nodeedge_type(type);
+}
+
+inline static bool gm_can_be_value_type(GMTYPE_T type) {
+    return gm_is_prim_type(type) || gm_is_nodeedge_type(type);
+}
+
 enum GM_ACCESS_T
 {   // 16 bit bitmap
     GMACCESS_NONE = 0x0000,
diff --git a/src/inc/gm_ind_opt_steps.h b/src/inc/gm_ind_opt_steps.h
index 7c1c75e..934a772 100644
--- a/src/inc/gm_ind_opt_steps.h
+++ b/src/inc/gm_ind_opt_steps.h
@@ -16,6 +16,8 @@ GM_COMPILE_STEP(gm_ind_opt_hoist_foreach, "Move foreach statements")
 GM_COMPILE_STEP(gm_ind_opt_flip_edges, "Flipping Edges in Nested Foeach")
 GM_COMPILE_STEP(gm_ind_opt_loop_merge, "Merge loops")
 GM_COMPILE_STEP(gm_ind_opt_nonconf_reduce, "Optimizing non-conflicting reductions")
+GM_COMPILE_STEP(gm_ind_opt_propagate_trivial_writes, "Propagate Trivial Writes")
+GM_COMPILE_STEP(gm_ind_opt_remove_unused_scalar, "Remove Unused Scalar")
 
 #endif
 
diff --git a/src/inc/gm_transform_helper.h b/src/inc/gm_transform_helper.h
index e359afd..357974b 100644
--- a/src/inc/gm_transform_helper.h
+++ b/src/inc/gm_transform_helper.h
@@ -48,6 +48,7 @@ extern void gm_add_sent_end(ast_sent* current, ast_sent* newone, bool fix_symtab
 //--------------------------------------------------------------------
 extern void gm_add_sent_before(ast_sent* current, ast_sent* newone, bool fix_symtab = true);
 extern void gm_add_sent_after(ast_sent* current, ast_sent* newone, bool fix_symtab = true);
+extern void gm_replace_sent(ast_sent* orgone, ast_sent* newone, bool fix_symtab = true);
 
 //--------------------------------------------------------------------
 // similar to add_sent_*. But explicitly give the sentence bock
@@ -57,6 +58,12 @@ extern void gm_insert_sent_end_of_sb(ast_sentblock* curr_sb, ast_sent* newone, b
 extern void gm_insert_sent_body_begin(ast_foreach* curr_sb, ast_sent* newone, bool fix_symtab = true);
 extern void gm_insert_sent_body_end(ast_foreach* curr_sb, ast_sent* newone, bool fix_sumtab = true);
 
+//--------------------------------------------------------------------
+// Remove(Rip-Off) sentence from a sentence block
+// (User should guarantee target does not use any symbol defined in from)
+//--------------------------------------------------------------------
+extern void gm_remove_sent_from_sb(ast_sent* target, ast_sentblock* from, bool fix_symtab = true);
+
 //------------------------------------------------------------
 // Scope management
 //------------------------------------------------------------
@@ -72,14 +79,25 @@ extern void gm_reconstruct_scope(ast_node* top);  // top should must have a scop
 // Symbol addition and creation
 //------------------------------------------------------------
 // Find an upscope where I can add some symbol defs
-ast_sentblock* gm_find_upscope(ast_sent* s);
+extern ast_sentblock* gm_find_upscope(ast_sent* s);
 // Add symbols into some scope
-gm_symtab_entry* gm_add_new_symbol_primtype(ast_sentblock* sb, int primtype, char* new_vname); // assumtpion: no name-conflict.
-gm_symtab_entry* gm_add_new_symbol_property(ast_sentblock* sb, int primtype, bool is_nodeprop, gm_symtab_entry* target_graph, char* new_vname); // assumtpion: no name-conflict.
-gm_symtab_entry* gm_add_new_symbol_nodeedge_type(ast_sentblock* sb, int nodeedge_type, gm_symtab_entry* target_graph, char* new_vname); // assumtpion: no name-conflict.
+extern gm_symtab_entry* gm_add_new_symbol_primtype(ast_sentblock* sb, int primtype, char* new_vname); // assumtpion: no name-conflict.
+extern gm_symtab_entry* gm_add_new_symbol_property(ast_sentblock* sb, int primtype, bool is_nodeprop, gm_symtab_entry* target_graph, char* new_vname); // assumtpion: no name-conflict.
+extern gm_symtab_entry* gm_add_new_symbol_nodeedge_type(ast_sentblock* sb, int nodeedge_type, gm_symtab_entry* target_graph, char* new_vname); // assumtpion: no name-conflict.
 
+//------------------------------------------------------------
+// Sentence block related
+//------------------------------------------------------------
 // returns sentblock that defines the given entry
-ast_sentblock* gm_find_defining_sentblock_up(ast_node* begin, gm_symtab_entry *e, bool is_property = false);
+extern ast_sentblock* gm_find_defining_sentblock_up(ast_node* begin, gm_symtab_entry *e, bool is_property = false);
+// Is the sentence block empty?   (nothing in there)
+extern bool gm_is_sentblock_empty(ast_sentblock* sb);
+// Is the sentence block trivial? (only one sentence, no definition)--  also returns the only sentence
+extern bool gm_is_sentblock_trivial(ast_sentblock* sb, ast_sent* &s);
+
+// get the trivivial sententce of s if s is a trivial sent-block. otherwise returns s itself
+extern ast_sent* gm_get_sentence_if_trivial_sentblock(ast_sent* s);
+
 
 //------------------------------------------------------------
 // Replace every symbol access
@@ -133,6 +151,7 @@ ast_expr* gm_new_bottom_symbol(int reduce_type, int lhs_type);
 // [the routine expects that there is only 1 instance of old_e inside target top expreesion]
 // note: symtab hierarchy is *not* re-validated by this routine
 // (thus be careful if new_e contains Sum/Product...)
+// (this method should be depricated; use replace_expr_general instead)
 extern bool gm_replace_subexpr(ast_expr* top, ast_expr* old_e, ast_expr* new_e);
 
 // implement following function 
@@ -159,6 +178,8 @@ extern bool gm_resolve_name_conflict(ast_sent *s, gm_symtab_entry *e, bool is_sc
 // [Assumption. e_new is a valid symbol entry that does not break scoping rule.]
 //---------------------------------------------------------------------------------------
 extern bool gm_replace_symbol_entry(gm_symtab_entry *e_old, gm_symtab_entry*e_new, ast_node* top);
+// replace symbol entry only for bounds 
+extern bool gm_replace_symbol_entry_bound(gm_symtab_entry *e_old, gm_symtab_entry *e_new, ast_node* top);
 
 //---------------------------------------------------------------
 // Merge subblock P,Q into P