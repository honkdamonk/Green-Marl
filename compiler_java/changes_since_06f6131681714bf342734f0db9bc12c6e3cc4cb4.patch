diff --git a/src/backend_cpp/gm_cpp_gen.cc b/src/backend_cpp/gm_cpp_gen.cc
index f7735c4..b6ce23c 100644
--- a/src/backend_cpp/gm_cpp_gen.cc
+++ b/src/backend_cpp/gm_cpp_gen.cc
@@ -350,6 +350,13 @@ const char* gm_cpp_gen::get_type_string(ast_typedecl* t) {
         } else {
             assert(false);
         }
+    } else if (t->is_map()) {
+        char temp[256];
+        ast_maptypedecl* mapType = (ast_maptypedecl*)t;
+        const char* keyType = get_type_string(mapType->get_key_type());
+        const char* valueType = get_type_string(mapType->get_value_type());
+        sprintf(temp, "gm_map<%s, %s>", keyType, valueType);
+        return gm_strdup(temp);
     } else
         return get_lib()->get_type_string(t);
 
@@ -470,7 +473,7 @@ void gm_cpp_gen::declare_prop_def(ast_typedecl* t, ast_id * id) {
 void gm_cpp_gen::generate_sent_vardecl(ast_vardecl* v) {
     ast_typedecl* t = v->get_type();
 
-    if (t->is_queue()) {
+    if (t->is_collection_of_collection()) {
         Body.push(get_type_string(t));
         ast_typedecl* targetType = t->get_target_type();
         Body.push("<");
@@ -483,6 +486,14 @@ void gm_cpp_gen::generate_sent_vardecl(ast_vardecl* v) {
         return;
     }
 
+    if (t->is_map()) {
+        ast_maptypedecl* map = (ast_maptypedecl*) t;
+        ast_idlist* idl = v->get_idlist();
+        assert(idl->get_length() == 1);
+        get_lib()->add_map_def(map, idl->get_item(0));
+        return;
+    }
+
     Body.push_spc(get_type_string(t));
 
     if (t->is_property()) {
@@ -504,15 +515,61 @@ void gm_cpp_gen::generate_sent_vardecl(ast_vardecl* v) {
     }
 }
 
+const char* gm_cpp_gen::get_function_name_map_reduce_assign(int reduceType) {
+
+    switch (reduceType) {
+        case GMREDUCE_PLUS:
+            return "changeValueAtomicAdd";
+        default:
+            assert(false);
+            return "ERROR";
+    }
+}
+
+void gm_cpp_gen::generate_sent_map_assign(ast_assign_mapentry* a) {
+    ast_mapaccess* mapAccess = a->to_assign_mapentry()->get_lhs_mapaccess();
+    ast_id* map = mapAccess->get_map_id();
+
+    char buffer[256];
+    if (a->is_under_parallel_execution()) {
+        if (a->is_reduce_assign() && a->get_reduce_type() == GMREDUCE_PLUS) {
+            sprintf(buffer, "%s.%s(", map->get_genname(), get_function_name_map_reduce_assign(a->get_reduce_type()));
+        } else {
+            sprintf(buffer, "%s.setValue_par(", map->get_genname());
+        }
+    } else {
+        if (a->is_reduce_assign() && a->get_reduce_type() == GMREDUCE_PLUS) {
+            //TODO do this without CAS overhead
+            sprintf(buffer, "%s.%s(", map->get_genname(), get_function_name_map_reduce_assign(a->get_reduce_type()));
+        } else {
+            sprintf(buffer, "%s.setValue_seq(", map->get_genname());
+        }
+    }
+    Body.push(buffer);
+
+    ast_expr* key = mapAccess->get_key_expr();
+    generate_expr(key);
+    Body.push(", ");
+    generate_expr(a->get_rhs());
+    Body.pushln(");");
+}
+
 void gm_cpp_gen::generate_sent_assign(ast_assign* a) {
 
     if (a->is_target_scalar()) {
         ast_id* leftHandSide = a->get_lhs_scala();
         if (leftHandSide->is_instantly_assigned()) { //we have to add the variable declaration here
             Body.push(get_lib()->get_type_string(leftHandSide->getTypeSummary()));
+            if(a->is_reference()) {
+                Body.push("& ");
+            } else {
             Body.push(" ");
         }
+        }
         generate_lhs_id(a->get_lhs_scala());
+    } else if (a->is_target_map_entry()) {
+        generate_sent_map_assign(a->to_assign_mapentry());
+        return;
     } else {
         generate_lhs_field(a->get_lhs_field());
     }
@@ -57,6 +58,10 @@ void gm_cpplib::generate_up_initializer(ast_foreach* f, gm_code_writer& Body) {
         const char* prep_str = f->is_parallel() ? "prepare_par_iteration" : f->is_reverse_iteration() ? "prepare_rev_iteration" : "prepare_seq_iteration";
 
         // get a list
+        const char* typeString = NULL;
+        if(gm_is_collection_of_collection_type(source->getTypeSummary()))
+            sprintf(str_buf, "%s<%s>::%s", get_type_string(source->getTypeInfo()), get_type_string(source->getTargetTypeInfo()), iter_type_str);
+        else
         sprintf(str_buf, "%s::%s", get_type_string(source->getTypeInfo()), iter_type_str);
         Body.push(str_buf);
 
@@ -88,9 +93,14 @@ void gm_cpplib::generate_down_initializer(ast_foreach* f, gm_code_writer& Body)
     if (gm_is_iteration_on_collection(iter_type)) {
         assert(f->find_info(CPPBE_INFO_COLLECTION_ITERATOR) != NULL);
         const char* lst_iter_name = f->find_info_string(CPPBE_INFO_COLLECTION_ITERATOR);
-        const char* type_name = source->getTypeInfo()->is_node_collection() ? NODE_T : EDGE_T;
-
-        sprintf(str_buf, "%s %s = %s.get_next();", type_name, f->get_iterator()->get_genname(), lst_iter_name);
+        const char* type_name;
+        if(gm_is_collection_of_collection_type(source->getTypeSummary()))
+            type_name = get_type_string(source->getTargetTypeInfo());
+        else
+            type_name = source->getTypeInfo()->is_node_collection() ? NODE_T : EDGE_T;
+
+        sprintf(str_buf, "const %s& %s = %s.get_next();", type_name, f->get_iterator()->get_genname(), lst_iter_name);
+        //sprintf(str_buf, "%s %s = %s.get_next();", type_name, f->get_iterator()->get_genname(), lst_iter_name);
         Body.pushln(str_buf);
     } else if (gm_is_iteration_on_neighbors_compatible(iter_type)) {
         const char* alias_name = f->find_info_string(CPPBE_INFO_NEIGHBOR_ITERATOR);
@@ -131,7 +141,12 @@ void gm_cpplib::generate_foreach_header(ast_foreach* fe, gm_code_writer& Body) {
     int type = fe->get_iter_type();
 
     if (gm_is_iteration_on_all_graph(type)) {
-        char* graph_name = source->get_genname();
+        char* graph_name;
+        if(gm_is_node_property_type(source->getTypeSummary()) || gm_is_edge_property_type(source->getTypeSummary())) {
+            graph_name = source->getTypeInfo()->get_target_graph_id()->get_orgname();
+        } else {
+            graph_name = source->get_genname();
+        }
         char* it_name = iter->get_genname();
         sprintf(str_buf, "for (%s %s = 0; %s < %s.%s(); %s ++) ", get_type_string(type), it_name, it_name, graph_name,
                 gm_is_iteration_on_nodes(type) ? NUM_NODES : NUM_EDGES,
@@ -177,7 +192,7 @@ void gm_cpplib::generate_foreach_header(ast_foreach* fe, gm_code_writer& Body) {
     } else if (gm_is_iteration_on_collection(type)) {
 
         assert(!fe->is_parallel());
-        assert(gm_is_node_collection_iter_type(type));
+        assert(gm_is_node_collection_iter_type(type) || gm_is_collection_of_collection_iter_type(type));
 
         const char* iter_name = fe->find_info_string(CPPBE_INFO_COLLECTION_ITERATOR);
         sprintf(str_buf, "while (%s.has_next())", iter_name);
diff --git a/src/backend_cpp/gm_cpp_opt.cc b/src/backend_cpp/gm_cpp_opt.cc
index 8d7c215..ecfcb57 100644
--- a/src/backend_cpp/gm_cpp_opt.cc
+++ b/src/backend_cpp/gm_cpp_opt.cc
@@ -15,6 +15,7 @@ void gm_cpp_gen::init_opt_steps() {
 
     LIST.push_back(GM_COMPILE_STEP_FACTORY(gm_cpp_opt_check_feasible));
     LIST.push_back(GM_COMPILE_STEP_FACTORY(gm_cpp_opt_defer));
+    LIST.push_back(GM_COMPILE_STEP_FACTORY(gm_cpp_opt_common_nbr));
     LIST.push_back(GM_COMPILE_STEP_FACTORY(gm_cpp_opt_select_par));
     LIST.push_back(GM_COMPILE_STEP_FACTORY(gm_cpp_opt_save_bfs));
     LIST.push_back(GM_COMPILE_STEP_FACTORY(gm_ind_opt_move_propdecl)); // from ind-opt
diff --git a/src/backend_cpp/gm_cpp_opt_common_nbr.cc b/src/backend_cpp/gm_cpp_opt_common_nbr.cc
new file mode 100644
index 0000000..af99c85
--- /dev/null
+++ b/src/backend_cpp/gm_cpp_opt_common_nbr.cc
@@ -0,0 +1,225 @@
+#include <stdio.h>
+#include <map>
+#include "gm_backend_cpp.h"
+#include "gm_backend_cpp_opt_steps.h"
+#include "gm_error.h"
+#include "gm_typecheck.h"
+#include "gm_transform_helper.h"
+#include "gm_argopts.h"
+#include "gm_builtin.h"
+
+//---------------------------------------------
+// Optimize Common Nbr 
+//---------------------------------------------
+// Finding t such that x --> t and  y --> t
+//---------------------------------------------
+// Foreach(t: x.Nbrs){
+//   If (t.IsNbrFrom(y)) {  // t is an common nbr of x and y
+//      ...
+//   }
+// }
+// ===>
+// Foreach(t: x.CommonNbrs(y)){
+//    ...
+// }
+// 
+//---------------------------------------------
+
+static bool is_common_nbr_expression(ast_expr* e, gm_symtab_entry*& s) {
+    // all right. Just be practical and check only two cases:
+    // t.IsNbrFrom(y)
+    // t.IsNbrFrom(y) == True
+    if (e->get_optype() == GMOP_EQ)
+    {
+        ast_expr* l = e->get_left_op();
+        ast_expr* r = e->get_right_op();
+        if (r->is_literal() && (r->get_type_summary() == GMTYPE_BOOL) && (r->get_bval() == true))
+        {
+            e = l;
+        }
+        else 
+            return false;
+    }
+
+    if (e->is_builtin()) 
+    {
+        ast_expr_builtin * b = (ast_expr_builtin*) e;
+
+        // check if node.isNobrTo()
+        
+        ast_id* driver = b->get_driver();
+        if (driver == NULL) 
+            return false;
+        if (!driver->getTypeInfo()->is_node_compatible())
+            return false;
+
+        if (b->get_builtin_def()->get_method_id() == GM_BLTIN_NODE_IS_NBR) {
+            std::list<ast_expr*>& L = b->get_args();
+            ast_expr* arg = L.front();  assert(arg!=NULL);
+            if (!arg->is_id())
+                return false;
+            s = (arg->get_id())->getSymInfo();
+            return true;
+        }
+    }        
+
+    return false;
+}
+
+struct gm_cpp_common_nbr_item_t {
+    ast_foreach* fe;
+    ast_if* iff;
+    ast_if* out_iff;
+    bool nested_iff;
+    gm_symtab_entry* common_sym;
+};
+
+class cpp_opt_common_nbr_t : public gm_apply
+{
+public:
+    // find targets
+    virtual bool apply(ast_sent* sent) {
+
+        // check only for foreach
+        // todo: do similar thing for BFS
+        if (sent->get_nodetype() != AST_FOREACH) 
+            return true;
+
+        ast_foreach* fe = (ast_foreach*) sent;
+
+        if (fe->get_iter_type() != GMTYPE_NODEITER_NBRS) 
+            return true;
+
+
+        ast_sent* fe_body = gm_get_sentence_if_trivial_sentblock(fe->get_body());
+
+        if (fe_body->get_nodetype() != AST_IF)
+            return true;
+
+        ast_if* iff = (ast_if*) fe_body;
+        if (iff->get_else() != NULL)
+            return true;
+
+        gm_symtab_entry* t_sym;
+        if (is_common_nbr_expression(iff->get_cond(), t_sym)) 
+        {
+            gm_cpp_common_nbr_item_t T;
+            T.fe = fe;
+            T.iff = iff;
+            T.nested_iff = false;
+            T.common_sym = t_sym;
+            _targets.push_back(T);
+        }
+        else 
+        {
+            ast_sent* iff_body = gm_get_sentence_if_trivial_sentblock(iff->get_then());
+            if (iff_body->get_nodetype() != AST_IF)
+                return true;
+
+            ast_if* iff2 = (ast_if*) iff_body;
+            if (is_common_nbr_expression(iff2->get_cond(), t_sym)) 
+            {
+                gm_cpp_common_nbr_item_t T;
+                T.fe = fe;
+                T.iff = iff2;
+                T.nested_iff = true;
+                T.out_iff = iff;
+                T.common_sym = t_sym;
+                _targets.push_back(T);
+            }
+
+            return true;
+        }
+    }
+
+    // iterate over targets
+    void transform_targets() {
+        std::list<gm_cpp_common_nbr_item_t>::iterator I;
+        for (I = _targets.begin(); I != _targets.end(); I++) {
+            apply_transform(*I);
+        }
+    }
+
+    bool has_targets() {
+        return _targets.size() > 0;
+    }
+
+private:
+    std::list<gm_cpp_common_nbr_item_t> _targets;
+    void apply_transform(gm_cpp_common_nbr_item_t& T);
+
+};
+
+//---------------------------------------------
+// apply to each BFS
+//---------------------------------------------
+void cpp_opt_common_nbr_t::apply_transform(gm_cpp_common_nbr_item_t& T) {
+    ast_foreach* fe =T.fe;
+    ast_if* iff = T.iff;
+    ast_if* out_iff = T.out_iff;
+    bool nested_iff = T.nested_iff;
+    gm_symtab_entry* common_sym = T.common_sym;
+   
+
+    ast_sent* if_body = iff->get_then();
+    gm_ripoff_sent(if_body);
+    gm_ripoff_sent(iff);
+
+    if (!nested_iff) 
+    {
+        //--------------------------
+        // foreach(n: x.Nbrs) 
+        // {
+        //    If (n.isNbrFrom(z))
+        //      // body
+        // } 
+        // ==>
+        // foreach(n: x.CommonNbrs(z))
+        // {
+        //     // body
+        // }
+        //-----------------------------
+        fe->set_body(if_body);
+    }
+    else 
+    {
+        //--------------------------
+        // foreach(n: x.Nbrs) 
+        // {
+        //    If( ...) {
+        //      If (n.isNbrFrom(z))
+        //        // body
+        //    }
+        // } 
+        // ==>
+        // foreach(n: x.CommonNbrs(z))
+        // {
+        //     If (...) {
+        //       // body
+        //     }
+        // }
+        //-----------------------------
+        // set if_body to for_body
+        out_iff->set_then(if_body);
+    }
+
+    // set new iterator
+    fe->set_iter_type(GMTYPE_NODEITER_COMMON_NBRS);
+    fe->get_iterator()->getSymInfo()->getType()->set_typeid(GMTYPE_NODEITER_COMMON_NBRS);
+    fe->set_source2(common_sym->getId()->copy());
+
+    // adjust scope information of fe and below
+    gm_reconstruct_scope(fe);
+
+    // iff not used anymore
+    delete iff; 
+}
+
+void gm_cpp_opt_common_nbr::process(ast_procdef *p) {
+    cpp_opt_common_nbr_t T;
+    gm_traverse_sents(p->get_body(), &T);
+    if (T.has_targets()) {
+        T.transform_targets();
+        set_affected(true);
+    }
+}
diff --git a/src/backend_cpp/gm_cpplib_gen.cc b/src/backend_cpp/gm_cpplib_gen.cc
index db06499..008f6b4 100644
--- a/src/backend_cpp/gm_cpplib_gen.cc
+++ b/src/backend_cpp/gm_cpplib_gen.cc
@@ -51,19 +51,23 @@ const char* gm_cpplib::get_type_string(int type) {
             return "ERROR";
         }
     } else if (gm_is_collection_type(type)) {
-        assert(gm_is_node_collection_type(type));
+        assert(gm_is_node_collection_type(type) || gm_is_collection_of_collection_type(type));
         if (gm_is_set_collection_type(type))
             return SET_T;
         else if (gm_is_order_collection_type(type))
             return ORDER_T;
         else if (gm_is_sequence_collection_type(type))
             return SEQ_T;
+        else if (gm_is_collection_of_collection_type(type))
+            return QUEUE_T;
         else {
             assert(false);
             return "ERROR";
         }
-    } else if (gm_is_queue_type(type)) {
+    } else if (gm_is_collection_of_collection_type(type)) {
         return QUEUE_T;
+    } else if (gm_is_map_type(type)) {
+        return MAP_T;
     } else {
         printf("type = %d %s\n", type, gm_get_type_string(type));
         assert(false);
@@ -96,10 +100,11 @@ bool gm_cpplib::add_collection_def(ast_id* i) {
     Body->push("(");
 
     ast_typedecl* t = i->getTypeInfo();
-    if (t->is_set_collection() || t->is_order_collection() || t->is_queue()) {
+    if (t->is_set_collection() || t->is_order_collection() || t->is_collection_of_collection()) {
         // total size;
         assert(t->get_target_graph_id() != NULL);
-        if (!t->is_queue()) Body->push(t->get_target_graph_id()->get_genname());
+
+        if (!t->is_collection_of_collection()) Body->push(t->get_target_graph_id()->get_genname());
         if (t->is_node_collection()) {
             Body->push(".");
             Body->push(NUM_NODES);
@@ -108,7 +113,7 @@ bool gm_cpplib::add_collection_def(ast_id* i) {
             Body->push(".");
             Body->push(NUM_EDGES);
             Body->push("()");
-        } else if (t->is_queue()) {
+        } else if (t->is_collection_of_collection()) {
             assert(true);
         } else {
             assert(false);
@@ -116,7 +121,7 @@ bool gm_cpplib::add_collection_def(ast_id* i) {
     }
     if (t->is_order_collection()) Body->push(", ");
 
-    if (t->is_order_collection() || t->is_sequence_collection() || t->is_queue()) {
+    if (t->is_order_collection() || t->is_sequence_collection() || t->is_collection_of_collection()) {
         Body->push(MAX_THREADS);
         Body->push("()");
     }
@@ -126,6 +131,64 @@ bool gm_cpplib::add_collection_def(ast_id* i) {
     return false;
 }
 
+const char* gm_cpplib::getMapTypeString(int type) {
+    if (type == MEDIUM)
+        return "gm_map_medium";
+    else
+        assert(false);
+    return NULL;
+}
+
+const char* gm_cpplib::getMapDefaultValueForType(int type) {
+    if (gm_is_float_type(type)) {
+        return "0.0";
+    } else if (gm_is_integer_type(type)) {
+        return "0";
+    } else if (gm_is_boolean_type(type)) {
+        return "false";
+    } else if (gm_is_node_type(type)) {
+        return "gm_graph::NIL_NODE";
+    } else if (gm_is_edge_type(type)) {
+        return "gm_graph::NIL_EDGE";
+    } else {
+        //we only support primitives, nodes and edges in maps (yet)
+        assert(false);
+    }
+    return NULL;
+}
+
+const char* gm_cpplib::getAdditionalMapParameters(int mapType) {
+    switch (mapType) {
+        case MEDIUM:
+            return "gm_rt_get_num_threads(), ";
+        default:
+            assert(false);
+            return "ERROR";
+    }
+}
+
+void gm_cpplib::add_map_def(ast_maptypedecl* map, ast_id* mapId) {
+
+    int mapType = MEDIUM; //TODO: implement compiler optimization to figure out what is best here
+    int keyType = map->getKeyTypeSummary();
+    int valueType = map->getValueTypeSummary();
+    if(valueType == GMTYPE_BOOL) {
+        valueType = GMTYPE_INT;
+    }
+
+    // Output: MapType<KeyType, ValueType> VariableName(AdditionalParameters DefaultValue);
+
+    char typeBuffer[128];
+    sprintf(typeBuffer, "%s<%s, %s>", getMapTypeString(mapType), getTypeString(keyType),  getTypeString(valueType));
+
+    char parameterBuffer[64];
+    sprintf(parameterBuffer, "(%s %s)", getAdditionalMapParameters(mapType), getMapDefaultValueForType(valueType));
+
+    char buffer[256];
+    sprintf(buffer, "%s %s%s;", typeBuffer, mapId->get_genname(), parameterBuffer);
+    Body->pushln(buffer);
+}
+
 void gm_cpplib::generate_sent_nop(ast_nop *f) {
     int subtype = f->get_subtype();
     switch (subtype) {
@@ -161,6 +224,8 @@ const char* gm_cpplib::get_function_name_nset(int methodId, bool in_parallel) {
             return "intersect";
         case GM_BLTIN_SET_SUBSET:
             return "is_subset";
+        case GM_BLTIN_SET_SIZE:
+            return "get_size";
         default:
             assert(false);
             return "ERROR";
@@ -177,6 +242,8 @@ const char* gm_cpplib::get_function_name_nseq(int methodId) {
             return "pop_front";
         case GM_BLTIN_SET_REMOVE_BACK:
             return "pop_back";
+        case GM_BLTIN_SET_SIZE:
+            return "get_size";
         default:
             assert(false);
             return "ERROR";
@@ -195,12 +262,79 @@ const char* gm_cpplib::get_function_name_norder(int methodId) {
             return "pop_back";
         case GM_BLTIN_SET_HAS:
             return "is_in";
+        case GM_BLTIN_SET_SIZE:
+            return "get_size";
+        default:
+            assert(false);
+            return "ERROR";
+    }
+}
+
+const char* gm_cpplib::get_function_name_map(int methodId, bool in_parallel) {
+
+    switch (methodId) {
+        case GM_BLTIN_MAP_SIZE:
+            return "size";
+        case GM_BLTIN_MAP_CLEAR:
+            return "clear";
+        case GM_BLTIN_MAP_HAS_MAX_VALUE:
+        case GM_BLTIN_MAP_HAS_MIN_VALUE:
+        case GM_BLTIN_MAP_HAS_KEY:
+        case GM_BLTIN_MAP_GET_MAX_KEY:
+        case GM_BLTIN_MAP_GET_MIN_KEY:
+        case GM_BLTIN_MAP_GET_MAX_VALUE:
+        case GM_BLTIN_MAP_GET_MIN_VALUE: {
+            if (in_parallel)
+                // if it is in parallel we do not have to use the inherent
+                // parallelism of the map so this is not a bug!!!
+                return get_function_name_map_seq(methodId);
+            else
+                return get_function_name_map_par(methodId);
+        }
         default:
             assert(false);
             return "ERROR";
     }
 }
 
+const char* gm_cpplib::get_function_name_map_seq(int methodId) {
+    switch (methodId) {
+        case GM_BLTIN_MAP_HAS_MAX_VALUE:
+            return "hasMaxValue";
+        case GM_BLTIN_MAP_HAS_MIN_VALUE:
+            return "hasMinValue";
+        case GM_BLTIN_MAP_HAS_KEY:
+            return "hasKey";
+        case GM_BLTIN_MAP_GET_MAX_KEY:
+            return "getMaxKey";
+        case GM_BLTIN_MAP_GET_MIN_KEY:
+            return "getMinKey";
+        case GM_BLTIN_MAP_GET_MAX_VALUE:
+            return "getMaxValue";
+        case GM_BLTIN_MAP_GET_MIN_VALUE:
+            return "getMinValue";
+    }
+}
+
+const char* gm_cpplib::get_function_name_map_par(int methodId) {
+    switch (methodId) {
+        case GM_BLTIN_MAP_HAS_MAX_VALUE:
+            return "hasMaxValue_par";
+        case GM_BLTIN_MAP_HAS_MIN_VALUE:
+            return "hasMinValue_par";
+        case GM_BLTIN_MAP_HAS_KEY:
+            return "hasKey_par";
+        case GM_BLTIN_MAP_GET_MAX_KEY:
+            return "getMaxKey_par";
+        case GM_BLTIN_MAP_GET_MIN_KEY:
+            return "getMinKey_par";
+        case GM_BLTIN_MAP_GET_MAX_VALUE:
+            return "getMaxValue_par";
+        case GM_BLTIN_MAP_GET_MIN_VALUE:
+            return "getMinValue_par";
+    }
+}
+
 const char* gm_cpplib::get_function_name_graph(int methodId) {
     switch (methodId) {
         case GM_BLTIN_GRAPH_NUM_NODES:
@@ -363,6 +497,9 @@ void gm_cpplib::generate_expr_builtin(ast_expr_builtin* e, gm_code_writer& Body)
         case GMTYPE_NSEQ:
             func_name = get_function_name_nseq(method_id);
             break;
+        case GMTYPE_MAP:
+            func_name = get_function_name_map(method_id);
+            break;
         default:
             assert(false);
             break;
diff --git a/src/backend_cpp/gm_cpplib_words.h b/src/backend_cpp/gm_cpplib_words.h
index a67020d..7e1685c 100644
--- a/src/backend_cpp/gm_cpplib_words.h
+++ b/src/backend_cpp/gm_cpplib_words.h
@@ -19,6 +19,7 @@ static const char* SET_T = "gm_node_set";
 static const char* ORDER_T = "gm_node_order";
 static const char* SEQ_T = "gm_node_seq";
 static const char* QUEUE_T = "gm_collection";
+static const char* MAP_T = "gm_map";
 static const char* PROP_OF_COL = "gm_property_of_collection";
 static const char* IS_IN = "is_in";
 static const char* MAX_SET_CNT = "max_size";
diff --git a/src/backend_giraph/gm_giraph_gen.cc b/src/backend_giraph/gm_giraph_gen.cc
index f1a732a..c7c00b0 100644
--- a/src/backend_giraph/gm_giraph_gen.cc
+++ b/src/backend_giraph/gm_giraph_gen.cc
@@ -63,21 +90,26 @@ void gm_giraph_gen::do_generate_global_variables() {
 }
 
 void gm_giraph_gen::do_generate_input_output_formats() {
-    char temp[1024];
+    char temp[1024], vertex_data[256], edge_data[256], message_data[256];
     ast_procdef* proc = FE.get_current_proc();
 
     const char* proc_name = proc->get_procname()->get_genname();
     const char* vertex_id = PREGEL_BE->get_lib()->is_node_type_int() ? "IntWritable" : "LongWritable";
-    const char* edge_data = proc->find_info_bool(GPS_FLAG_USE_EDGE_PROP) ? "EdgeData" : "NullWritable";
+    sprintf(vertex_data, "%sVertex.VertexData", proc_name);
+    if (proc->find_info_bool(GPS_FLAG_USE_EDGE_PROP))
+        sprintf(edge_data, "%sVertex.EdgeData", proc_name);
+    else
+        sprintf(edge_data, "NullWritable");
+    sprintf(message_data, "%sVertex.MessageData", proc_name);
 
     Body.pushln("//----------------------------------------------");
     Body.pushln("// Vertex Input format");
     Body.pushln("//----------------------------------------------");
 
-    sprintf(temp, "static class %sVertexInputFormat extends TextVertexInputFormat<%s, VertexData, %s, MessageData> {", proc_name, vertex_id, edge_data);
+    sprintf(temp, "static class %sVertexInputFormat extends TextVertexInputFormat<%s, %s, %s, %s> {", proc_name, vertex_id, vertex_data, edge_data, message_data);
     Body.pushln(temp);
     Body.pushln("@Override");
-    sprintf(temp, "public VertexReader<%s, VertexData, %s, MessageData>", vertex_id, edge_data);
+    sprintf(temp, "public VertexReader<%s, %s, %s, %s>", vertex_id, vertex_data, edge_data, message_data);
     Body.pushln(temp);
     Body.pushln("createVertexReader(InputSplit split, TaskAttemptContext context) throws IOException {");
     sprintf(temp, "return new %sVertexReader(textInputFormat.createRecordReader(split, context));", proc_name);
@@ -85,8 +117,7 @@ void gm_giraph_gen::do_generate_input_output_formats() {
     Body.pushln("}");
     Body.NL();
 
-    sprintf(temp, "static class %sVertexReader extends TextVertexInputFormat.TextVertexReader<%s, VertexData, %s, MessageData> {", proc_name, vertex_id,
-            edge_data);
+    sprintf(temp, "static class %sVertexReader extends TextVertexInputFormat.TextVertexReader<%s, %s, %s, %s> {", proc_name, vertex_id, vertex_data, edge_data, message_data);
     Body.pushln(temp);
     sprintf(temp, "public %sVertexReader(RecordReader<LongWritable, Text> lineRecordReader) {", proc_name);
     Body.pushln(temp);
@@ -95,11 +126,11 @@ void gm_giraph_gen::do_generate_input_output_formats() {
     Body.NL();
 
     Body.pushln("@Override");
-    sprintf(temp, "public BasicVertex<%s, VertexData, %s, MessageData> getCurrentVertex() throws IOException, InterruptedException {", vertex_id, edge_data);
+    sprintf(temp, "public Vertex<%s, %s, %s, %s> getCurrentVertex() throws IOException, InterruptedException {", vertex_id, vertex_data, edge_data, message_data);
     Body.pushln(temp);
-    sprintf(temp, "BasicVertex<%s, VertexData, %s, MessageData> vertex =", vertex_id, edge_data);
+    sprintf(temp, "Vertex<%s, %s, %s, %s> vertex =", vertex_id, vertex_data, edge_data, message_data);
     Body.pushln(temp);
-    sprintf(temp, "    BspUtils.<%s, VertexData, %s, MessageData> createVertex(getContext().getConfiguration());", vertex_id, edge_data);
+    sprintf(temp, "    BspUtils.<%s, %s, %s, %s> createVertex(getContext().getConfiguration());", vertex_id, vertex_data, edge_data, message_data);
     Body.pushln(temp);
     Body.NL();
 
@@ -121,12 +152,14 @@ void gm_giraph_gen::do_generate_input_output_formats() {
     }
     if (proc->find_info_bool(GPS_FLAG_USE_EDGE_PROP)) {
         Body.pushln("double edgeValue = Double.parseDouble(values[i+1]);");
-        Body.pushln("edges.put(edgeId, new EdgeData(edgeValue));");
+        sprintf(temp, "edges.put(edgeId, new %s(edgeValue));", edge_data);
+        Body.pushln(temp);
     } else {
         Body.pushln("edges.put(edgeId, NullWritable.get());");
     }
     Body.pushln("}");
-    Body.pushln("vertex.initialize(vertexId, new VertexData(vertexValue), edges, null);");
+    sprintf(temp, "vertex.initialize(vertexId, new %sVertex.VertexData(vertexValue), edges, null);", proc_name);
+    Body.pushln(temp);
     Body.pushln("return vertex;");
     Body.pushln("}");
     Body.NL();
@@ -144,10 +177,10 @@ void gm_giraph_gen::do_generate_input_output_formats() {
     Body.pushln("// ----------------------------------------------");
     sprintf(temp, "static class %sVertexOutputFormat extends", proc_name);
     Body.pushln(temp);
-    sprintf(temp, "TextVertexOutputFormat<%s, VertexData, %s> {", vertex_id, edge_data);
+    sprintf(temp, "TextVertexOutputFormat<%s, %s, %s> {", vertex_id, vertex_data, edge_data);
     Body.pushln(temp);
     Body.pushln("@Override");
-    sprintf(temp, "public VertexWriter<%s, VertexData, %s> createVertexWriter(", vertex_id, edge_data);
+    sprintf(temp, "public VertexWriter<%s, %s, %s> createVertexWriter(", vertex_id, vertex_data, edge_data);
     Body.pushln(temp);
     Body.pushln("TaskAttemptContext context) throws IOException, InterruptedException {");
     sprintf(temp, "return new %sVertexWriter(textOutputFormat.getRecordWriter(context));", proc_name);
@@ -157,7 +190,7 @@ void gm_giraph_gen::do_generate_input_output_formats() {
 
     sprintf(temp, "static class %sVertexWriter", proc_name);
     Body.pushln(temp);
-    sprintf(temp, "extends TextVertexOutputFormat.TextVertexWriter<%s, VertexData, %s> {", vertex_id, edge_data);
+    sprintf(temp, "extends TextVertexOutputFormat.TextVertexWriter<%s, %s, %s> {", vertex_id, vertex_data, edge_data);
     Body.pushln(temp);
     sprintf(temp, "public %sVertexWriter(RecordWriter<Text, Text> lineRecordReader) {", proc_name);
     Body.pushln(temp);
@@ -167,23 +200,20 @@ void gm_giraph_gen::do_generate_input_output_formats() {
 
     Body.pushln("@Override");
     Body.pushln("public void writeVertex(");
-    sprintf(temp, "BasicVertex<%s, VertexData, %s, ?> vertex)", vertex_id, edge_data);
+    sprintf(temp, "Vertex<%s, %s, %s, ?> vertex)", vertex_id, vertex_data, edge_data);
     Body.pushln(temp);
     Body.pushln("throws IOException, InterruptedException {");
-    Body.pushln("StringBuffer sb = new StringBuffer(vertex.getVertexId().toString());");
-    Body.pushln("sb.append('\\t').append(vertex.getVertexValue());");
+    Body.pushln("StringBuffer sb = new StringBuffer(vertex.getId().toString());");
+    Body.pushln("sb.append('\\t').append(vertex.getValue());");
     Body.NL();
 
-    sprintf(temp, "Iterator<%s> outEdges = vertex.getOutEdgesIterator();", vertex_id);
+    sprintf(temp, "for (Edge<%s, %s> edge : vertex.getEdges()) {", vertex_id, edge_data);
     Body.pushln(temp);
-    Body.pushln("while (outEdges.hasNext()) {");
     if (proc->find_info_bool(GPS_FLAG_USE_EDGE_PROP)) {
-        sprintf(temp, "%s neighbor = outEdges.next();", vertex_id);
-        Body.pushln(temp);
-        Body.pushln("sb.append('\\t').append(neighbor);");
-        Body.pushln("sb.append('\\t').append(vertex.getEdgeValue(neighbor));");
+        Body.pushln("sb.append('\\t').append(edge.getTargetVertexId());");
+        Body.pushln("sb.append('\\t').append(edge.getValue());");
     } else {
-        Body.pushln("sb.append('\\t').append(outEdges.next());");
+        Body.pushln("sb.append('\\t').append(edge.getTargetVertexId());");
         Body.pushln("sb.append(\"\\t1.0\");");
     }
     Body.pushln("}");
@@ -198,6 +228,7 @@ void gm_giraph_gen::do_generate_input_output_formats() {
 void gm_giraph_gen::do_generate_job_configuration() {
     char temp[1024];
     ast_procdef* proc = FE.get_current_proc();
+    char* proc_name = proc->get_procname()->get_genname();
 
     // Iterate symbol table
     gm_symtab* args = proc->get_symtab_var();
@@ -259,17 +290,17 @@ void gm_giraph_gen::do_generate_job_configuration() {
     Body.NL();
     Body.pushln("GiraphJob job = new GiraphJob(getConf(), getClass().getName());");
     Body.pushln("job.getConfiguration().setInt(GiraphJob.CHECKPOINT_FREQUENCY, 0);");
-    sprintf(temp, "job.setMasterComputeClass(%sMaster.class);", proc->get_procname()->get_genname());
+    sprintf(temp, "job.setMasterComputeClass(%sVertex.%sMasterCompute.class);", proc_name, proc_name);
     Body.pushln(temp);
-    sprintf(temp, "job.setVertexClass(%sVertex.class);", proc->get_procname()->get_genname());
+    sprintf(temp, "job.setVertexClass(%sVertex.class);", proc_name);
     Body.pushln(temp);
-    sprintf(temp, "job.setWorkerContextClass(%sWorkerContext.class);", proc->get_procname()->get_genname());
+    sprintf(temp, "job.setWorkerContextClass(%sVertex.%sWorkerContext.class);", proc_name, proc_name);
     Body.pushln(temp);
-    sprintf(temp, "job.setVertexInputFormatClass(%sVertexInputFormat.class);", proc->get_procname()->get_genname());
+    sprintf(temp, "job.setVertexInputFormatClass(%sVertexInputFormat.class);", proc_name);
     Body.pushln(temp);
     Body.pushln("FileInputFormat.addInputPath(job.getInternalJob(), new Path(cmd.getOptionValue('i')));");
     Body.pushln("if (cmd.hasOption('o')) {");
-    sprintf(temp, "job.setVertexOutputFormatClass(%sVertexOutputFormat.class);", proc->get_procname()->get_genname());
+    sprintf(temp, "job.setVertexOutputFormatClass(%sVertexOutputFormat.class);", proc_name);
     Body.pushln(temp);
     Body.pushln("FileOutputFormat.setOutputPath(job.getInternalJob(), new Path(cmd.getOptionValue('o')));");
     Body.pushln("}");
@@ -335,7 +366,7 @@ void gm_giraph_gen::do_generate_job_configuration() {
 
     Body.NL();
     Body.pushln("public static void main(final String[] args) throws Exception {");
-    sprintf(temp, "System.exit(ToolRunner.run(new %s(), args));", proc->get_procname()->get_genname());
+    sprintf(temp, "System.exit(ToolRunner.run(new %s(), args));", proc_name);
     Body.pushln(temp);
     Body.pushln("}");
 }
@@ -346,18 +377,23 @@ void gm_giraph_gen::end_class() {
 
 void gm_giraph_gen::generate_proc(ast_procdef* proc) {
     write_headers();
+
+    if (!OPTIONS.get_arg_bool(GMARGFLAG_GIRAPH_VERTEX_ONLY)) {
     begin_class();
     do_generate_global_variables();
-    do_generate_master();
+    }
 
-    do_generate_vertex();
+    do_generate_vertex_begin();
+    do_generate_master();
+    do_generate_vertex_body();
+    do_generate_vertex_end();
 
+    if (!OPTIONS.get_arg_bool(GMARGFLAG_GIRAPH_VERTEX_ONLY)) {
     do_generate_input_output_formats();
-
     do_generate_job_configuration();
-
     end_class();
 }
+}
 
 void gm_giraph_gen_class::process(ast_procdef* proc) {
     PREGEL_BE->generate_proc(proc);
diff --git a/src/backend_giraph/gm_giraph_gen_master.cc b/src/backend_giraph/gm_giraph_gen_master.cc
index c2767c1..a2e5eae 100644
--- a/src/backend_giraph/gm_giraph_gen_master.cc
+++ b/src/backend_giraph/gm_giraph_gen_master.cc
@@ -14,7 +14,6 @@ void gm_giraph_gen::do_generate_master() {
     do_generate_master_serialization();
     Body.pushln("}"); // finish master class
     Body.NL();
-
 }
 
 void gm_giraph_gen::do_generate_master_class() {
@@ -25,7 +24,7 @@ void gm_giraph_gen::do_generate_master_class() {
     // create master class
     //--------------------------------------------------------------------
     char temp[1024];
-    sprintf(temp, "public static class %sMaster extends MasterCompute {", proc->get_procname()->get_genname());
+    sprintf(temp, "public static class %sMasterCompute extends MasterCompute {", proc->get_procname()->get_genname());
     Body.pushln(temp);
     Body.pushln("// Control fields");
     bool prep = FE.get_current_proc_info()->find_info_bool(GPS_FLAG_USE_REVERSE_EDGE);
@@ -51,7 +50,7 @@ void gm_giraph_gen::do_generate_master_class() {
     std::set<gm_symtab_entry*>& scalar = info->get_scalar_symbols();
     std::set<gm_symtab_entry*>::iterator I_sym;
 
-    sprintf(temp, "registerAggregator(%s, IntOverwriteAggregator.class);", GPS_KEY_FOR_STATE);
+    sprintf(temp, "registerPersistentAggregator(%s, IntOverwriteAggregator.class);", GPS_KEY_FOR_STATE);
     Body.pushln(temp);
     for (I_bb = bb_blocks.begin(); I_bb != bb_blocks.end(); I_bb++) {
         gm_gps_basic_block* b = *I_bb;
@@ -59,7 +58,7 @@ void gm_giraph_gen::do_generate_master_class() {
 
         if (b->find_info_bool(GPS_FLAG_IS_INTRA_MERGED_CONDITIONAL)) {
             int cond_bb_no = b->find_info_int(GPS_INT_INTRA_MERGED_CONDITIONAL_NO);
-            sprintf(temp, "registerAggregator(\"%s%d\", BooleanOverwriteAggregator.class);", GPS_INTRA_MERGE_IS_FIRST, cond_bb_no);
+            sprintf(temp, "registerPersistentAggregator(\"%s%d\", BooleanOverwriteAggregator.class);", GPS_INTRA_MERGE_IS_FIRST, cond_bb_no);
             Body.pushln(temp);
         }
     }
@@ -70,9 +69,9 @@ void gm_giraph_gen::do_generate_master_class() {
         assert(syminfo!=NULL);
 
         if ((syminfo->is_used_in_vertex() || syminfo->is_used_in_receiver()) && syminfo->is_used_in_master()) {
-            sprintf(temp, "registerAggregator(%s, ", get_lib()->create_key_string(sym->getId()));
+            sprintf(temp, "registerPersistentAggregator(%s, ", get_lib()->create_key_string(sym->getId()));
             Body.push(temp);
-            get_lib()->generate_broadcast_variable_type(sym->getId()->getTypeSummary(), Body, syminfo->get_reduce_type());
+            get_lib()->generate_broadcast_aggregator_type(sym->getId()->getTypeSummary(), Body, syminfo->get_reduce_type());
             Body.pushln(".class);");
         }
     }
diff --git a/src/backend_giraph/gm_giraph_gen_vertex.cc b/src/backend_giraph/gm_giraph_gen_vertex.cc
index 6189bc0..01abd36 100644
--- a/src/backend_giraph/gm_giraph_gen_vertex.cc
+++ b/src/backend_giraph/gm_giraph_gen_vertex.cc
@@ -4,13 +4,14 @@
 #include "gm_code_writer.h"
 #include "gm_frontend.h"
 #include "gm_transform_helper.h"
+#include "gm_argopts.h"
 extern void gm_redirect_reproduce(FILE *f);
 extern void gm_baseindent_reproduce(int i);
 extern void gm_flush_reproduce();
 
-void gm_giraph_gen::do_generate_vertex() {
+void gm_giraph_gen::do_generate_vertex_body() {
     set_master_generate(false);
-    do_generate_vertex_class();
+    do_generate_vertex_states();
     do_generate_worker_context_class();
     do_generate_vertex_property_class(false);
 
@@ -19,6 +20,42 @@ void gm_giraph_gen::do_generate_vertex() {
     do_generate_message_class();
 }
 
+void gm_giraph_gen::do_generate_vertex_begin() {
+    char temp[1024];
+    const char* proc_name = FE.get_current_proc()->get_procname()->get_genname();
+    Body.pushln("//----------------------------------------------");
+    Body.pushln("// Main Vertex Class");
+    Body.pushln("//----------------------------------------------");
+    if (OPTIONS.get_arg_bool(GMARGFLAG_GIRAPH_VERTEX_ONLY)) {
+        sprintf(temp, "public class %sVertex", proc_name);
+    } else {
+        sprintf(temp, "public static class %sVertex", proc_name);
+    }
+    Body.pushln(temp);
+    Body.push_indent();
+    if (FE.get_current_proc()->find_info_bool(GPS_FLAG_USE_EDGE_PROP)) {
+        sprintf(temp, "extends EdgeListVertex< %s, %sVertex.VertexData, %sVertex.EdgeData, %sVertex.MessageData > {",
+                PREGEL_BE->get_lib()->is_node_type_int() ? "IntWritable" : "LongWritable",
+                proc_name, proc_name, proc_name);
+    } else {
+        sprintf(temp, "extends EdgeListVertex< %s, %sVertex.VertexData, NullWritable, %sVertex.MessageData > {",
+                PREGEL_BE->get_lib()->is_node_type_int() ? "IntWritable" : "LongWritable",
+                proc_name, proc_name);
+    }
+    Body.pushln(temp);
+    Body.pop_indent();
+    Body.NL();
+    Body.pushln("// Vertex logger");
+    sprintf(temp, "private static final Logger LOG = Logger.getLogger(%sVertex.class);", proc_name);
+    Body.pushln(temp);
+    Body.NL();
+}
+
+void gm_giraph_gen::do_generate_vertex_end() {
+    Body.pushln("} // end of vertex class");
+    Body.NL();
+}
+
 void gm_giraph_gen::do_generate_worker_context_class() {
     char temp[1024];
     const char* proc_name = FE.get_current_proc()->get_procname()->get_genname();
@@ -40,33 +77,6 @@ void gm_giraph_gen::do_generate_worker_context_class() {
     Body.NL();
     Body.pushln("@Override");
     Body.pushln("public void preApplication() throws InstantiationException, IllegalAccessException {");
-    sprintf(temp, "registerAggregator(%s, IntOverwriteAggregator.class);", GPS_KEY_FOR_STATE);
-    Body.pushln(temp);
-
-    for (I_bb = bb_blocks.begin(); I_bb != bb_blocks.end(); I_bb++) {
-        gm_gps_basic_block* b = *I_bb;
-        if ((!b->is_prepare()) && (!b->is_vertex())) continue;
-
-        if (b->find_info_bool(GPS_FLAG_IS_INTRA_MERGED_CONDITIONAL)) {
-            int cond_bb_no = b->find_info_int(GPS_INT_INTRA_MERGED_CONDITIONAL_NO);
-            sprintf(temp, "registerAggregator(\"%s%d\", BooleanOverwriteAggregator.class);", GPS_INTRA_MERGE_IS_FIRST, cond_bb_no);
-            Body.pushln(temp);
-        }
-    }
-
-    for (I_sym = scalar.begin(); I_sym != scalar.end(); I_sym++) {
-        gm_symtab_entry* sym = *I_sym;
-        gps_syminfo* syminfo = (gps_syminfo*) sym->find_info(GPS_TAG_BB_USAGE);
-        assert(syminfo!=NULL);
-
-        if ((syminfo->is_used_in_vertex() || syminfo->is_used_in_receiver()) && syminfo->is_used_in_master()) {
-            sprintf(temp, "registerAggregator(%s, ", get_lib()->create_key_string(sym->getId()));
-            Body.push(temp);
-            get_lib()->generate_broadcast_variable_type(sym->getId()->getTypeSummary(), Body, syminfo->get_reduce_type());
-            Body.pushln(".class);");
-        }
-    }
-
     Body.pushln("}");
     Body.NL();
     Body.pushln("@Override");
@@ -75,31 +85,6 @@ void gm_giraph_gen::do_generate_worker_context_class() {
     Body.NL();
     Body.pushln("@Override");
     Body.pushln("public void preSuperstep() {");
-    sprintf(temp, "useAggregator(%s);", GPS_KEY_FOR_STATE);
-    Body.pushln(temp);
-
-    for (I_bb = bb_blocks.begin(); I_bb != bb_blocks.end(); I_bb++) {
-        gm_gps_basic_block* b = *I_bb;
-        if ((!b->is_prepare()) && (!b->is_vertex())) continue;
-
-        if (b->find_info_bool(GPS_FLAG_IS_INTRA_MERGED_CONDITIONAL)) {
-            int cond_bb_no = b->find_info_int(GPS_INT_INTRA_MERGED_CONDITIONAL_NO);
-            sprintf(temp, "useAggregator(\"%s%d\");", GPS_INTRA_MERGE_IS_FIRST, cond_bb_no);
-            Body.pushln(temp);
-        }
-    }
-
-    for (I_sym = scalar.begin(); I_sym != scalar.end(); I_sym++) {
-        gm_symtab_entry* sym = *I_sym;
-        gps_syminfo* syminfo = (gps_syminfo*) sym->find_info(GPS_TAG_BB_USAGE);
-        assert(syminfo!=NULL);
-
-        if ((syminfo->is_used_in_vertex() || syminfo->is_used_in_receiver()) && syminfo->is_used_in_master()) {
-            sprintf(temp, "useAggregator(%s);", get_lib()->create_key_string(sym->getId()));
-            Body.pushln(temp);
-        }
-    }
-
     Body.pushln("}");
     Body.NL();
     Body.pushln("@Override");
@@ -178,37 +163,11 @@ void gm_giraph_gen::do_generate_message_class() {
     Body.NL();
 }
 
-void gm_giraph_gen::do_generate_vertex_class() {
-    char temp[1024];
-    const char* proc_name = FE.get_current_proc()->get_procname()->get_genname();
-    Body.pushln("//----------------------------------------------");
-    Body.pushln("// Main Vertex Class");
-    Body.pushln("//----------------------------------------------");
-    sprintf(temp, "public static class %sVertex", proc_name);
-    Body.pushln(temp);
-    Body.push_indent();
-    if (FE.get_current_proc()->find_info_bool(GPS_FLAG_USE_EDGE_PROP)) {
-        sprintf(temp, "extends EdgeListVertex< %s, VertexData, EdgeData, MessageData > {",
-                PREGEL_BE->get_lib()->is_node_type_int() ? "IntWritable" : "LongWritable");
-    } else {
-        sprintf(temp, "extends EdgeListVertex< %s, VertexData, NullWritable, MessageData > {",
-                PREGEL_BE->get_lib()->is_node_type_int() ? "IntWritable" : "LongWritable");
-    }
-    Body.pushln(temp);
-    Body.pop_indent();
-
-    do_generate_vertex_states();
-
-    Body.pushln("} // end of vertex class");
-    Body.NL();
-
-}
-
 void gm_giraph_gen::do_generate_vertex_states() {
     char temp[1024];
     Body.NL();
     Body.pushln("@Override");
-    Body.pushln("public void compute(Iterator<MessageData> _msgs) {");
+    Body.pushln("public void compute(Iterable<MessageData> _msgs) {");
     get_lib()->generate_receive_state_vertex("_state_vertex", Body);
 
     Body.pushln("switch(_state_vertex) { ");
@@ -288,7 +247,7 @@ void gm_giraph_gen::do_generate_vertex_state_body(gm_gps_basic_block *b) {
     int type = b->get_type();
 
     char temp[1024];
-    sprintf(temp, "private void _vertex_state_%d(Iterator<MessageData> _msgs) {", id);
+    sprintf(temp, "private void _vertex_state_%d(Iterable<MessageData> _msgs) {", id);
     Body.pushln(temp);
 
     get_lib()->generate_vertex_prop_access_prepare(Body);
@@ -319,8 +278,7 @@ void gm_giraph_gen::do_generate_vertex_state_body(gm_gps_basic_block *b) {
         }
 
         Body.pushln("// Begin msg receive");
-        Body.pushln("while (_msgs.hasNext()) {");
-        Body.pushln("MessageData _msg = _msgs.next();");
+        Body.pushln("for (MessageData _msg : _msgs) {");
 
         std::list<gm_gps_comm_unit>& R = b->get_receivers();
         std::list<gm_gps_comm_unit>::iterator I;
diff --git a/src/backend_giraph/gm_giraph_lib.cc b/src/backend_giraph/gm_giraph_lib.cc
index 3b1b813..60d42a1 100644
--- a/src/backend_giraph/gm_giraph_lib.cc
+++ b/src/backend_giraph/gm_giraph_lib.cc
@@ -5,22 +5,25 @@
 #include "gm_frontend.h"
 #include "gm_transform_helper.h"
 #include "gm_builtin.h"
+#include "gm_argopts.h"
 
 void gm_giraphlib::generate_headers(gm_code_writer& Body) {
     Body.pushln("import java.io.DataInput;");
     Body.pushln("import java.io.DataOutput;");
     Body.pushln("import java.io.IOException;");
     Body.pushln("import java.lang.Math;");
-    Body.pushln("import java.util.Iterator;");
-    Body.pushln("import java.util.Map;");
     Body.pushln("import java.util.Random;");
-    Body.pushln("import org.apache.commons.cli.*;");
     Body.pushln("import org.apache.giraph.aggregators.*;");
     Body.pushln("import org.apache.giraph.graph.*;");
+    Body.pushln("import org.apache.hadoop.io.*;");
+    Body.pushln("import org.apache.log4j.Logger;");
+
+    if (!OPTIONS.get_arg_bool(GMARGFLAG_GIRAPH_VERTEX_ONLY)) {
+        Body.pushln("import java.util.Map;");
+        Body.pushln("import org.apache.commons.cli.*;");
     Body.pushln("import org.apache.giraph.lib.*;");
     Body.pushln("import org.apache.hadoop.conf.Configuration;");
     Body.pushln("import org.apache.hadoop.fs.Path;");
-    Body.pushln("import org.apache.hadoop.io.*;");
     Body.pushln("import org.apache.hadoop.mapreduce.InputSplit;");
     Body.pushln("import org.apache.hadoop.mapreduce.RecordReader;");
     Body.pushln("import org.apache.hadoop.mapreduce.RecordWriter;");
@@ -29,13 +32,15 @@ void gm_giraphlib::generate_headers(gm_code_writer& Body) {
     Body.pushln("import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;");
     Body.pushln("import org.apache.hadoop.util.Tool;");
     Body.pushln("import org.apache.hadoop.util.ToolRunner;");
-    Body.pushln("import org.apache.log4j.Logger;");
     Body.pushln("import com.google.common.collect.Maps;");
 }
+    Body.NL();
+    Body.pushln("@SuppressWarnings(\"unused\")");
+}
 
 void gm_giraphlib::generate_node_iterator_rhs(ast_id* id, gm_code_writer& Body) {
     //TODO
-    Body.push("getVertexId().get()");
+    Body.push("getId().get()");
 }
 
 // scalar variable broadcast
@@ -43,32 +48,33 @@ void gm_giraphlib::generate_node_iterator_rhs(ast_id* id, gm_code_writer& Body)
 
 void gm_giraphlib::generate_broadcast_state_master(const char* state_var, gm_code_writer& Body) {
     char temp[1024];
-    sprintf(temp, "((IntOverwriteAggregator) getAggregator(%s)).setAggregatedValue(%s);", GPS_KEY_FOR_STATE, state_var);
+    sprintf(temp, "setAggregatedValue(%s, new IntWritable(%s));", GPS_KEY_FOR_STATE, state_var);
     Body.pushln(temp);
 }
 
 void gm_giraphlib::generate_receive_state_vertex(const char* state_var, gm_code_writer& Body) {
     char temp[1024];
-    sprintf(temp, "int %s = ((IntOverwriteAggregator) getAggregator(%s)).getAggregatedValue().get();", state_var, GPS_KEY_FOR_STATE);
+    sprintf(temp, "int %s = this.<IntWritable>getAggregatedValue(%s).get();", state_var, GPS_KEY_FOR_STATE);
     Body.pushln(temp);
 }
 void gm_giraphlib::generate_broadcast_isFirst_master(const char* is_first_var, gm_code_writer& Body) {
     char temp[1024];
-    sprintf(temp, "((BooleanOverwriteAggregator) getAggregator(\"%s\")).setAggregatedValue(%s);", is_first_var, is_first_var);
+    sprintf(temp, "setAggregatedValue(\"%s\", new BooleanWritable(%s));", is_first_var, is_first_var);
     Body.pushln(temp);
 }
 void gm_giraphlib::generate_receive_isFirst_vertex(const char* is_first_var, gm_code_writer& Body) {
     char temp[1024];
-    sprintf(temp, "boolean %s = ((BooleanOverwriteAggregator) getAggregator(\"%s\"", is_first_var, is_first_var);
+    sprintf(temp, "boolean %s = this.<BooleanWritable>getAggregatedValue(\"%s\").get();", is_first_var, is_first_var);
     Body.push(temp);
-    Body.pushln(")).getAggregatedValue().get();");
 }
 
 void gm_giraphlib::generate_broadcast_reduce_initialize_master(ast_id* id, gm_code_writer& Body, int reduce_op_type, const char* base_value) {
     char temp[1024];
-    Body.push("((");
-    generate_broadcast_variable_type(id->getTypeSummary(), Body, reduce_op_type);
-    sprintf(temp, ") getAggregator(%s)).setAggregatedValue(%s);", create_key_string(id), base_value);
+
+    sprintf(temp, "setAggregatedValue(%s, new ", create_key_string(id));
+    Body.push(temp);
+    generate_broadcast_writable_type(id->getTypeSummary(), Body);
+    sprintf(temp, "(%s));", base_value);
     Body.pushln(temp);
 }
 
@@ -77,23 +83,23 @@ void gm_giraphlib::generate_broadcast_send_master(ast_id* id, gm_code_writer& Bo
     // create new BV
     //---------------------------------------------------
     char temp[1024];
-    Body.push("((");
-    generate_broadcast_variable_type(id->getTypeSummary(), Body);
-    sprintf(temp, ") getAggregator(%s)).setAggregatedValue(", create_key_string(id));
+    sprintf(temp, "setAggregatedValue(%s, new ", create_key_string(id));
     Body.push(temp);
+    generate_broadcast_writable_type(id->getTypeSummary(), Body);
 
     //---------------------------------------------------
     // Initial Value: Reading of Id
     //---------------------------------------------------
+    Body.push("(");
     get_main()->generate_rhs_id(id);
-    Body.pushln(");");
+    Body.pushln("));");
 }
 
 void gm_giraphlib::generate_broadcast_receive_vertex(ast_id* id, gm_code_writer& Body) {
     char temp[1024];
-    Body.push("((");
-    generate_broadcast_variable_type(id->getTypeSummary(), Body);
-    sprintf(temp, ") getAggregator(%s)).getAggregatedValue().get()", create_key_string(id));
+    Body.push("this.<");
+    generate_broadcast_writable_type(id->getTypeSummary(), Body);
+    sprintf(temp, "> getAggregatedValue(%s).get()", create_key_string(id));
     Body.push(temp);
 }
 
@@ -128,8 +134,7 @@ void gm_giraphlib::generate_parameter_read_vertex(ast_id* id, gm_code_writer& Bo
     Body.push(temp);
 }
 
-void gm_giraphlib::generate_broadcast_variable_type(int type_id, gm_code_writer& Body, int reduce_op)
-
+void gm_giraphlib::generate_broadcast_aggregator_type(int type_id, gm_code_writer& Body, int reduce_op)
 {
     //--------------------------------------
     // Generate following string
@@ -202,14 +207,42 @@ void gm_giraphlib::generate_broadcast_variable_type(int type_id, gm_code_writer&
     Body.push("Aggregator");
 }
 
+void gm_giraphlib::generate_broadcast_writable_type(int type_id, gm_code_writer& Body)
+{
+    if (gm_is_node_compatible_type(type_id)) type_id = GMTYPE_NODE;
+    if (gm_is_edge_compatible_type(type_id)) type_id = GMTYPE_EDGE;
+
+    switch (type_id) {
+        case GMTYPE_INT:
+            Body.push("Int");
+            break;
+        case GMTYPE_DOUBLE:
+            Body.push("Double");
+            break;
+        case GMTYPE_LONG:
+            Body.push("Long");
+            break;
+        case GMTYPE_FLOAT:
+            Body.push("Float");
+            break;
+        case GMTYPE_BOOL:
+            Body.push("Boolean");
+            break;
+        case GMTYPE_NODE:
+            if (is_node_type_int())
+                Body.push("Int");
+            else
+                Body.push("Long");
+            break;
+        default:
+            assert(false);
+            break;
+    }
+    Body.push("Writable");
+}
+
 void gm_giraphlib::generate_broadcast_receive_master(ast_id* id, gm_code_writer& Body, int reduce_op_type) {
     char temp[1024];
-    generate_broadcast_variable_type(id->getTypeSummary(), Body, reduce_op_type);
-    sprintf(temp, " %sAggregator = (", id->get_genname());
-    Body.push(temp);
-    generate_broadcast_variable_type(id->getTypeSummary(), Body, reduce_op_type);
-    sprintf(temp, ") getAggregator(%s);", create_key_string(id));
-    Body.pushln(temp);
 
     // Read from BV to local value
     get_main()->generate_lhs_id(id);
@@ -249,7 +282,9 @@ void gm_giraphlib::generate_broadcast_receive_master(ast_id* id, gm_code_writer&
         }
     }
 
-    sprintf(temp, "%sAggregator.getAggregatedValue().get()", id->get_genname());
+    Body.push("this.<");
+    generate_broadcast_writable_type(id->getTypeSummary(), Body);
+    sprintf(temp, ">getAggregatedValue(%s).get()", create_key_string(id));
     Body.push(temp);
     if (need_paren) Body.push(")");
     Body.pushln(";");
@@ -260,10 +295,10 @@ void gm_giraphlib::generate_reduce_assign_vertex(ast_assign* a, gm_code_writer&
     ast_id* id = a->get_lhs_scala();
 
     char temp[1024];
-    Body.push("((");
-    generate_broadcast_variable_type(id->getTypeSummary(), Body, reduce_op_type);
-    sprintf(temp, ") getAggregator(%s)).aggregate(", create_key_string(id));
+
+    sprintf(temp, "aggregate(%s, new ", create_key_string(id));
     Body.push(temp);
+    generate_broadcast_writable_type(id->getTypeSummary(), Body);
 
     //---------------------------------------------------
     // Initial Value: Reading of Id
@@ -506,7 +541,7 @@ void gm_giraphlib::generate_vertex_prop_class_details(std::set<gm_symtab_entry*>
 
 void gm_giraphlib::generate_vertex_prop_access_prepare(gm_code_writer& Body) {
     char temp[1024];
-    sprintf(temp, "VertexData %s = getVertexValue();", STATE_SHORT_CUT);
+    sprintf(temp, "VertexData %s = getValue();", STATE_SHORT_CUT);
     Body.pushln(temp);
 }
 void gm_giraphlib::generate_vertex_prop_access_lhs(ast_id* id, gm_code_writer& Body) {
@@ -662,6 +697,9 @@ void gm_giraphlib::generate_message_class_details(gm_gps_beinfo* info, gm_code_w
 void gm_giraphlib::generate_message_send(ast_foreach* fe, gm_code_writer& Body) {
     char temp[1024];
 
+    const char* vertex_id = PREGEL_BE->get_lib()->is_node_type_int() ? "IntWritable" : "LongWritable";
+    const char* edge_data = FE.get_current_proc()->find_info_bool(GPS_FLAG_USE_EDGE_PROP) ? "EdgeData" : "NullWritable";
+
     gm_gps_beinfo * info = (gm_gps_beinfo *) FE.get_current_backend_info();
 
     int m_type = (fe == NULL) ? GPS_COMM_INIT : GPS_COMM_NESTED;
@@ -681,17 +719,16 @@ void gm_giraphlib::generate_message_send(ast_foreach* fe, gm_code_writer& Body)
             sprintf(temp, "if (%s.%s.length > 0) {", STATE_SHORT_CUT, GPS_REV_NODE_ID); //TODO
             Body.pushln(temp);
         } else {
-            Body.pushln("if (getNumOutEdges() > 0) {");
+            Body.pushln("if (getNumEdges() > 0) {");
         }
     } else {
         assert((fe != NULL) && (fe->get_iter_type() == GMTYPE_NODEITER_NBRS));
         Body.pushln("// Sending messages to each neighbor");
-        sprintf(temp, "Iterator<%s> neighbors = this.getOutEdgesIterator();", PREGEL_BE->get_lib()->is_node_type_int() ? "IntWritable" : "LongWritable");
+        sprintf(temp, "for (Edge<%s, %s> edge : getEdges()) {", vertex_id, edge_data);
         Body.pushln(temp);
-        Body.pushln("while (neighbors.hasNext()) {");
-        sprintf(temp, "%s _neighborId = neighbors.next();", PREGEL_BE->get_lib()->is_node_type_int() ? "IntWritable" : "LongWritable");
+        sprintf(temp, "%s _neighborId = edge.getTargetVertexId();", PREGEL_BE->get_lib()->is_node_type_int() ? "IntWritable" : "LongWritable");
         Body.pushln(temp);
-        Body.pushln("EdgeData _outEdgeData = this.getEdgeValue(_neighborId);");
+        Body.pushln("EdgeData _outEdgeData = edge.getValue();");
     }
 
     // check if any edge updates that should be done before message sending
@@ -764,14 +801,14 @@ void gm_giraphlib::generate_message_send(ast_foreach* fe, gm_code_writer& Body)
             sprintf(temp, "for (%s node : %s.%s) {", PREGEL_BE->get_lib()->is_node_type_int() ? "IntWritable" : "LongWritable", STATE_SHORT_CUT,
                     GPS_REV_NODE_ID);
             Body.pushln(temp);
-            Body.pushln("sendMsg(node, _msg);");
+            Body.pushln("sendMessage(node, _msg);");
             Body.pushln("}");
         } else {
-            Body.pushln("sendMsgToAllEdges(_msg);");
+            Body.pushln("sendMessageToAllEdges(_msg);");
         }
         Body.pushln("}");
     } else {
-        Body.pushln("sendMsg(_neighborId, _msg);");
+        Body.pushln("sendMessage(_neighborId, _msg);");
         if (sents_after_message.size() > 0) {
             Body.NL();
             std::list<ast_sent*>::iterator I;
@@ -867,11 +904,17 @@ void gm_giraphlib::generate_expr_builtin(ast_expr_builtin* be, gm_code_writer& B
             Body.push(")");
             break;
 
+        case GM_BLTIN_GRAPH_RAND_NODE:         // random node function
+            Body.push("(new java.util.Random()).nextInt(");
+            Body.push("getTotalNumVertices()");
+            Body.push(")");
+            break;
+
         case GM_BLTIN_GRAPH_NUM_NODES:
-            Body.push("getNumVertices()");
+            Body.push("getTotalNumVertices()");
             break;
         case GM_BLTIN_NODE_DEGREE:
-            Body.push("getNumOutEdges()");
+            Body.push("getNumEdges()");
             break;
         case GM_BLTIN_NODE_IN_DEGREE:
             Body.push(STATE_SHORT_CUT);
@@ -891,7 +934,7 @@ void gm_giraphlib::generate_prepare_bb(gm_code_writer& Body, gm_gps_basic_block*
 
     if (bb->get_type() == GM_GPS_BBTYPE_PREPARE1) {
         Body.pushln("// Preperation: creating reverse edges");
-        sprintf(temp, "%s %s = getVertexId().get();", main->get_type_string(GMTYPE_NODE), GPS_DUMMY_ID);
+        sprintf(temp, "%s %s = getId().get();", main->get_type_string(GMTYPE_NODE), GPS_DUMMY_ID);
         Body.pushln(temp);
 
         generate_message_send(NULL, Body);
@@ -899,8 +942,7 @@ void gm_giraphlib::generate_prepare_bb(gm_code_writer& Body, gm_gps_basic_block*
     } else if (bb->get_type() == GM_GPS_BBTYPE_PREPARE2) {
         Body.pushln("//Preperation creating reverse edges");
         Body.pushln("int i = 0; // iterable does not have length(), so we have to count it");
-        Body.pushln("while (_msgs.hasNext()) {");
-        Body.pushln("_msgs.next();");
+        Body.pushln("for (MessageData _msg : _msgs) {");
         Body.pushln("i++;");
         Body.pushln("}");
 
@@ -909,9 +951,7 @@ void gm_giraphlib::generate_prepare_bb(gm_code_writer& Body, gm_gps_basic_block*
         Body.NL();
 
         Body.pushln("i=0;");
-        Body.pushln("MessageData _msg;");
-        Body.pushln("while (_msgs.hasNext()) {");
-        Body.pushln("_msg = _msgs.next();");
+        Body.pushln("for (MessageData _msg : _msgs) {");
         generate_message_receive_begin(NULL, Body, bb, true);
         sprintf(temp, "%s.%s[i] = new %s(%s);", STATE_SHORT_CUT, GPS_REV_NODE_ID, PREGEL_BE->get_lib()->is_node_type_int() ? "IntWritable" : "LongWritable",
                 GPS_DUMMY_ID);
diff --git a/src/backend_giraph/gm_giraph_lib_random_write.cc b/src/backend_giraph/gm_giraph_lib_random_write.cc
index 8fcaa19..3041ea8 100644
--- a/src/backend_giraph/gm_giraph_lib_random_write.cc
+++ b/src/backend_giraph/gm_giraph_lib_random_write.cc
@@ -9,7 +9,7 @@
 void gm_giraphlib::generate_message_send_for_random_write(ast_sentblock* sb, gm_symtab_entry* sym, gm_code_writer& Body) {
     char temp[1024];
 
-    sprintf(temp, "sendMsg(new %s(", PREGEL_BE->get_lib()->is_node_type_int() ? "IntWritable" : "LongWritable");
+    sprintf(temp, "sendMessage(new %s(", PREGEL_BE->get_lib()->is_node_type_int() ? "IntWritable" : "LongWritable");
     Body.push(temp);
     get_main()->generate_rhs_id(sym->getId());
     sprintf(temp, "), %s);", get_random_write_message_name(sym));
diff --git a/src/backend_gps/gm_gps_gen.cc b/src/backend_gps/gm_gps_gen.cc
index acfcf4e..0007924 100644
--- a/src/backend_gps/gm_gps_gen.cc
+++ b/src/backend_gps/gm_gps_gen.cc
@@ -77,6 +77,14 @@ void gm_gps_gen::init_gen_steps() {
 // Main Generator
 //----------------------------------------------------
 bool gm_gps_gen::do_generate() {
+	FE.prepare_proc_iteration();
+	ast_procdef* proc = FE.get_next_proc();
+
+    // Check whether procedure name is the same as the filename
+	if (strcmp(proc->get_procname()->get_genname(), fname) != 0) {
+		gm_backend_error(GM_ERROR_GPS_PROC_NAME, proc->get_procname()->get_genname(), fname);
+		return false;
+	}
 
     if (!open_output_files()) return false;
 
diff --git a/src/backend_gps/gm_gps_new_check_depth_two.cc b/src/backend_gps/gm_gps_new_check_depth_two.cc
index d345211..3274c6f 100644
--- a/src/backend_gps/gm_gps_new_check_depth_two.cc
+++ b/src/backend_gps/gm_gps_new_check_depth_two.cc
@@ -88,15 +88,6 @@ private:
 };
 
 void gm_gps_new_check_depth_two::process(ast_procdef* proc) {
-    // Check number of procedure name is same to the filename
-    const char *fname = PREGEL_BE->getFileName();
-    assert(fname!=NULL);
-    if (strcmp(proc->get_procname()->get_genname(), fname) != 0) {
-        gm_backend_error(GM_ERROR_GPS_PROC_NAME, proc->get_procname()->get_genname(), fname);
-        set_okay(false);
-        return;
-    }
-
     // analyze_symbol_scope should be done before.
     gps_new_check_depth_two_t T;
     proc->traverse_both(&T);
diff --git a/src/backend_gps/gm_gps_opt.cc b/src/backend_gps/gm_gps_opt.cc
index fdc96ea..0996590 100644
--- a/src/backend_gps/gm_gps_opt.cc
+++ b/src/backend_gps/gm_gps_opt.cc
@@ -11,6 +11,9 @@ void gm_gps_gen::init_opt_steps() {
     std::list<gm_compile_step*>& L = get_opt_steps();
     L.push_back(GM_COMPILE_STEP_FACTORY(gm_cpp_opt_defer));                    // deferred assignment --> insert _next
     L.push_back(GM_COMPILE_STEP_FACTORY(gm_gps_opt_transform_bfs));            // transform bfs
+    L.push_back(GM_COMPILE_STEP_FACTORY(gm_gps_opt_edge_iteration));           // expand edge iteration
+    L.push_back(GM_COMPILE_STEP_FACTORY(gm_ind_opt_propagate_trivial_writes));
+    L.push_back(GM_COMPILE_STEP_FACTORY(gm_ind_opt_remove_unused_scalar));
     L.push_back(GM_COMPILE_STEP_FACTORY(gm_ind_opt_move_propdecl));            // copied from from ind-opt
     L.push_back(GM_COMPILE_STEP_FACTORY(gm_gps_opt_simplify_expr1));           // separate built-in calls through out-loop drivers 
     //L.push_back(GM_COMPILE_STEP_FACTORY(gm_gps_opt_find_nested_loops_test)); 
diff --git a/src/backend_gps/gm_gps_opt_edge_iteration.cc b/src/backend_gps/gm_gps_opt_edge_iteration.cc
new file mode 100644
index 0000000..9d6fdb9
--- /dev/null
+++ b/src/backend_gps/gm_gps_opt_edge_iteration.cc
@@ -0,0 +1,174 @@
+#include <stdio.h>
+#include "gm_builtin.h"
+#include "gm_backend_gps.h"
+#include "gm_error.h"
+#include "gm_code_writer.h"
+#include "gm_frontend.h"
+#include "gm_transform_helper.h"
+
+//----------------------------------------------------
+// Foreach(e:G.Edges) {
+//
+//   Node a = e.From()
+//   Node b = e.To()
+//
+// }
+// ==>
+// Foreach(n:G.Nodes)
+//    Foreach(t:n.Nbrs) {
+//       Edge e = t.ToEdge();
+//       // Node a = e.From()
+//       // Node b = e.To()
+//       // a --> n
+//       // b --> t
+//    }
+// }
+//----------------------------------------------------
+
+class gps_opt_edge_iteration_t : public gm_apply
+{
+public:
+    gps_opt_edge_iteration_t() {
+        set_for_sent(true);
+    }
+
+    virtual bool apply(ast_sent* s) {
+        if (s->get_nodetype() == AST_FOREACH) {
+            // check iteratation type
+            ast_foreach* fe = (ast_foreach*) s;
+            if (fe->get_iter_type() == GMTYPE_EDGEITER_ALL) {
+                _targets.push_back(fe);
+            }
+        }
+    }
+
+    bool has_targets() {
+        return _targets.size() > 0; 
+    }
+
+    void post_process() {
+        std::list<ast_foreach*>::iterator I;
+        for (I = _targets.begin(); I != _targets.end(); I++) {
+            ast_foreach* fe = *I;
+
+            char* old_edge_iter_name = gm_strdup(fe->get_iterator()->get_genname());
+            ast_sent* body = fe->get_body();
+            gm_ripoff_sent(body);
+
+            // (1) create outer foreach loop
+            ast_sentblock* sb = ast_sentblock::new_sentblock();
+            const char* outer_name = FE.voca_temp_name_and_add("_n");
+            ast_id* outer_id = ast_id::new_id(outer_name, fe->get_iterator()->get_line(), fe->get_iterator()->get_col());
+            ast_foreach* outer_fe = gm_new_foreach_after_tc(outer_id, fe->get_iterator()->getTypeInfo()->get_target_graph_id()->copy(true), sb, GMTYPE_NODEITER_ALL);
+
+            // (2) create inner foreach loop 
+            const char* inner_name = FE.voca_temp_name_and_add("_t");
+            ast_id* inner_id = ast_id::new_id(inner_name, fe->get_iterator()->get_line(), fe->get_iterator()->get_col());
+            ast_foreach* inner_fe = gm_new_foreach_after_tc(inner_id, outer_id->copy(true), body, GMTYPE_NODEITER_NBRS);
+            sb->add_sent(inner_fe);
+
+            // (3) replace fe -> outer_fe
+            gm_replace_sent(fe, outer_fe);
+            gm_reconstruct_scope(outer_fe);  
+
+            // (4) create new symbol entry in the body
+            if (body->get_nodetype() != AST_SENTBLOCK) {
+                gm_make_it_belong_to_sentblock(body);
+                body = (ast_sentblock*) body->get_parent();
+                assert(body->get_nodetype() == AST_SENTBLOCK);
+            }
+            ast_sentblock* sb2 = (ast_sentblock*) body;
+            gm_symtab_entry *old_edge_symbol = fe->get_iterator()->getSymInfo();
+            gm_symtab_entry *new_edge_symbol = gm_add_new_symbol_nodeedge_type(sb2, GMTYPE_EDGE, 
+                    fe->get_iterator()->getTypeInfo()->get_target_graph_sym(), old_edge_iter_name);
+
+            // (5) replace expressions (from/to)
+            replace_from_to_builtin(body, old_edge_symbol, outer_fe->get_iterator()->getSymInfo(), inner_fe->get_iterator()->getSymInfo());
+
+            // (5) replace other symbol accesses
+            gm_replace_symbol_entry_bound(old_edge_symbol, outer_fe->get_iterator()->getSymInfo(), body );
+            gm_replace_symbol_entry(old_edge_symbol, new_edge_symbol, body );
+
+            // (6) add definition of the new edge symbol at the top
+            ast_expr*  rhs = ast_expr_builtin::new_builtin_expr(inner_id->copy(true), 
+                    BUILT_IN.find_builtin_def(GMTYPE_NODEITER_NBRS, GM_BLTIN_NODE_TO_EDGE), 
+                    NULL);
+            ast_assign* new_assign = ast_assign::new_assign_scala(new_edge_symbol->getId()->copy(true), rhs);
+            gm_insert_sent_begin_of_sb(sb2, new_assign);
+            gm_reconstruct_scope(outer_fe);  
+            
+            delete [] old_edge_iter_name;
+            delete [] outer_name;
+            delete [] inner_name;
+
+            delete fe;
+            //printf("fe = %p\n", fe);
+            //printf("outer_fe = %p\n", outer_fe);
+            //printf("inner_fe = %p\n", inner_fe);
+        }
+    }
+
+private:
+    std::list<ast_foreach*> _targets;
+    void replace_from_to_builtin(ast_node* body, gm_symtab_entry* old_edge, gm_symtab_entry* outer, gm_symtab_entry* inner); 
+
+};
+
+class gm_gps_opt_replace_from_to_builtin_t : public gm_expr_replacement_t
+{
+public:
+    gm_gps_opt_replace_from_to_builtin_t(gm_symtab_entry* old_edge, gm_symtab_entry* outer, gm_symtab_entry* inner) : out(outer), in(inner), edge(old_edge){
+    }
+
+    virtual bool is_target(ast_expr* e) {
+        if (e->is_builtin()) {
+            ast_expr_builtin* b = (ast_expr_builtin*) e;
+            if (b->get_driver() == NULL) 
+                return false;
+            if (b->get_driver()->getSymInfo() != edge)
+                return false;
+
+            gm_builtin_def* D = b->get_builtin_def();
+            if ((D->get_method_id() == GM_BLTIN_EDGE_FROM) || (D->get_method_id() == GM_BLTIN_EDGE_TO)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    virtual ast_expr* create_new_expr(ast_expr* target, bool& destroy_target_after) {
+        assert (target->is_builtin()); 
+        ast_expr_builtin* b = (ast_expr_builtin*) target;
+        ast_expr* new_expr;
+        gm_builtin_def* D = b->get_builtin_def();
+        if (D->get_method_id() == GM_BLTIN_EDGE_FROM) {
+            new_expr = ast_expr::new_id_expr(out->getId()->copy(true));
+        } else if (D->get_method_id() == GM_BLTIN_EDGE_TO) {
+            new_expr = ast_expr::new_id_expr(in->getId()->copy(true));
+        } else {
+            assert(false);
+        }
+
+        destroy_target_after = true;
+    }
+
+private:
+    gm_symtab_entry* out;
+    gm_symtab_entry* in;
+    gm_symtab_entry* edge;
+
+};
+
+void gps_opt_edge_iteration_t::replace_from_to_builtin(ast_node* body, gm_symtab_entry* old_edge, gm_symtab_entry* outer, gm_symtab_entry* inner) {
+
+    gm_gps_opt_replace_from_to_builtin_t Q(old_edge, outer, inner);
+    gm_replace_expr_general(body, &Q);
+}
+
+void gm_gps_opt_edge_iteration::process(ast_procdef* p) {
+    gps_opt_edge_iteration_t T;
+    p->traverse_post(&T);
+    if (T.has_targets()) 
+        T.post_process();
+}
diff --git a/src/backend_gps/gm_gps_opt_transform_bfs.cc b/src/backend_gps/gm_gps_opt_transform_bfs.cc
index d358231..2d12e3a 100644
--- a/src/backend_gps/gm_gps_opt_transform_bfs.cc
+++ b/src/backend_gps/gm_gps_opt_transform_bfs.cc
@@ -8,10 +8,12 @@
 #include "gm_backend_gps_opt_steps.h"
 
 //--------------------------------------------------------
+// Transform BFS ==> Pregel-Canonical Statments. (i.e. while + foreach)
 //
-//
-//
-//
+//  By doing this transformation, we may lose an opportunity to use 
+//  a special fast implmentation of BFS.
+//  However, we can re-use GPS tranlsation mechanism for while/foreach statments.
+//  without creating new translation rules.
 //----------------------------------------------------
 
 class gps_opt_find_bfs_t : public gm_apply
@@ -29,7 +31,7 @@ public:
     virtual bool apply(ast_sent* s) {
         if (s->get_nodetype()== AST_BFS)
         {
-            assert (!in_bfs);  // no nested BFS for now
+            assert (!in_bfs);  // [XXX] Nested BFS are not allowed (temporary)
             in_bfs = true;
             current_bfs = (ast_bfs*) s;
             BFS.push_back(current_bfs);
@@ -156,7 +159,7 @@ static void create_fw_iteration(ast_sentblock* sb, ast_bfs* bfs, gm_symtab_entry
     //       Foreach(v:G.Nodes) {
     //          if (v.level == curr_level) {
     //             Foreach(k:v.Nbrs) {
-    //                If (k.level == +INF) {
+    //                If (k.level == +INF && [navigator]) {
     //                   k.level = curr_level + 1;    
     //                   bfs_finished &= False;
     //                }
@@ -205,7 +208,7 @@ static void create_fw_iteration(ast_sentblock* sb, ast_bfs* bfs, gm_symtab_entry
         GMTYPE_NODEITER_ALL);
     while_sb->add_sent(foreach_out);
 
-    // outer if
+
     ast_expr* lev_check_out_c = ast_expr::new_comp_expr(
         GMOP_EQ,
         ast_expr::new_field_expr(
@@ -240,7 +243,24 @@ static void create_fw_iteration(ast_sentblock* sb, ast_bfs* bfs, gm_symtab_entry
             inf
         );
     ast_sentblock* lev_check_in_sb = ast_sentblock::new_sentblock();
-    ast_if* lev_check_in_if = ast_if::new_if(lev_check_in_c, lev_check_in_sb,NULL);
+    ast_if* lev_check_in_if;
+    if (bfs->get_navigator() != NULL) 
+    {
+        ast_expr* navi = bfs->get_navigator();
+        bfs->set_navigator(NULL);
+
+        // replace bfs symbol ==> an inner foreach symbol
+        gm_replace_symbol_entry(bfs->get_iterator()->getSymInfo(), foreach_in->get_iterator()->getSymInfo(), navi);
+
+        // check with navigator
+        ast_expr* new_top = ast_expr::new_lbiop_expr(GMOP_AND, lev_check_in_c, navi);
+        lev_check_in_if = ast_if::new_if(new_top, lev_check_in_sb,NULL);
+    } 
+    else 
+    {
+        lev_check_in_if = ast_if::new_if(lev_check_in_c, lev_check_in_sb,NULL);
+    }
+
     inner_sb->add_sent(lev_check_in_if);
 
     // increase level
@@ -341,10 +362,6 @@ static void create_bw_iteration(ast_sentblock* sb, ast_bfs* bfs, gm_symtab_entry
 
 
 void gm_gps_rewrite_bfs(ast_bfs* b) {
-    // for temporary
-    assert(b->get_b_filter() == NULL);
-    assert(b->get_f_filter() == NULL);
-    assert(b->get_navigator() == NULL);
 
     gm_make_it_belong_to_sentblock(b);
     ast_sentblock* parent = (ast_sentblock*) b->get_parent();
@@ -484,7 +501,6 @@ static void create_user_body_main(ast_sentblock* sb_to_add, ast_bfs* bfs, ast_fo
     gm_ripoff_sent(body);
 
     // replace iterator
-    //printf("repalce :%s -> %s\n", bfs->get_iterator()->get_genname(), out_loop->get_iterator()->get_genname());
     gm_replace_symbol_entry(bfs->get_iterator()->getSymInfo(), out_loop->get_iterator()->getSymInfo(), body);
     // what was iterator 2 again?
     if (bfs->get_iterator2() != NULL)
diff --git a/src/common/gm_builtin.cc b/src/common/gm_builtin.cc
index cc3cf6e..f11d14e 100644
--- a/src/common/gm_builtin.cc
+++ b/src/common/gm_builtin.cc
@@ -46,6 +46,10 @@ static int gm_get_type_from_string(const char* s) {
         return GMTYPE_VOID;
     else if (gm_is_same_string(s, "Bool"))
         return GMTYPE_BOOL;
+    else if (gm_is_same_string(s, "Map"))
+        return GMTYPE_MAP;
+    else if (gm_is_same_string(s, "Generic"))
+        return GMTYPE_GENERIC;
     else {
         assert(false);
         return 0;
diff --git a/src/common/gm_code_generator.cc b/src/common/gm_code_generator.cc
index dd41e55..8ab4e8f 100644
--- a/src/common/gm_code_generator.cc
+++ b/src/common/gm_code_generator.cc
@@ -11,10 +11,23 @@ void gm_code_generator::generate_expr_list(std::list<ast_expr*>& L) {
     }
 }
 
+void gm_code_generator::generate_mapaccess(ast_expr_mapaccess* e) {
+    ast_mapaccess* mapAccess = e->get_mapaccess();
+    ast_id* map = mapAccess->get_map_id();
+    ast_expr* key = mapAccess->get_key_expr();
+    char buffer[256];
+    sprintf(buffer, "%s.getValue(", map->get_genname());
+    _Body.push(buffer);
+    generate_expr(key);
+    _Body.push(")");
+}
+
 extern void gm_flush_reproduce();
 
 void gm_code_generator::generate_expr(ast_expr*e) {
-    if (e->is_inf())
+    if(e->is_mapaccess())
+        generate_mapaccess((ast_expr_mapaccess*)e);
+    else if (e->is_inf())
         generate_expr_inf(e);
     else if (e->is_literal())
         generate_expr_val(e);
@@ -242,7 +255,7 @@ void gm_code_generator::generate_sent(ast_sent* s) {
             break;
         case AST_ASSIGN: {
             ast_assign* a = (ast_assign*) s;
-            if (a->is_reduce_assign()) {
+            if (a->is_reduce_assign() && !a->is_target_map_entry()) {
                 generate_sent_reduce_assign(a);
             } else if (a->is_defer_assign()) {
                 generate_sent_defer_assign(a);
diff --git a/src/common/gm_dumptree.cc b/src/common/gm_dumptree.cc
index aa2e69b..71cc0d3 100644
--- a/src/common/gm_dumptree.cc
+++ b/src/common/gm_dumptree.cc
@@ -40,6 +41,17 @@ void ast_field::dump_tree(int ind_level) {
     printf("]");
 }
 
+void ast_mapaccess::dump_tree(int indLevel) {
+    assert(parent != NULL);
+    IND(indLevel);
+    printf("[");
+    mapId->dump_tree(0);
+    printf("[");
+    keyExpr->dump_tree(indLevel + 1);
+    printf("]");
+    printf("]");
+}
+
 void ast_typedecl::dump_tree(int ind_level) {
     assert(parent!=NULL);
     IND(ind_level);
diff --git a/src/common/gm_error.cc b/src/common/gm_error.cc
index fc84967..17b1669 100644
--- a/src/common/gm_error.cc
+++ b/src/common/gm_error.cc
@@ -147,6 +146,9 @@ void gm_type_error(int errno, int l, int c, const char* str1, const char* str2,
         case GM_ERROR_COMPARE_MISMATCH:
             printf("Typemismatch in Comparison. LHS:%s, RHS:%s \n", str1, str2);
             break;
+        case GM_ERROR_KEY_MISSMATCH:
+            printf("Type mismatch for map-key. Expected %s, but was %s\n", str1, str2);
+            break;
         case GM_ERROR_NEED_BOOLEAN:
             printf("Need boolean expression.\n");
             break;
diff --git a/src/common/gm_misc.cc b/src/common/gm_misc.cc
index 446761e..1c9b05a 100644
--- a/src/common/gm_misc.cc
+++ b/src/common/gm_misc.cc
@@ -126,7 +126,8 @@ const char* gm_get_type_string(int t) {
             return "Collection::I";
         case GMTYPE_VOID:
             return "Void";
-
+        case GMTYPE_MAP:
+            return "Map";
         default: /*printf("%d\n",t); assert(false);*/
             return "Unknown";
     }
@@ -149,16 +150,14 @@ const char* gm_get_iter_type_string(int t) {
             return "InNbrs";
         case GMTYPE_NODEITER_COMMON_NBRS:
             return "CommonNbrs";
-
         case GMTYPE_NODEITER_SET:
-            return "Items";
         case GMTYPE_NODEITER_SEQ:
-            return "Items";
         case GMTYPE_NODEITER_ORDER:
-            return "Items";
         case GMTYPE_ITER_ANY:
+        case GMTYPE_PROPERTYITER_SET:
+        case GMTYPE_PROPERTYITER_SEQ:
+        case GMTYPE_PROPERTYITER_ORDER:
             return "Items";
-
         default:
             assert(false);
             return "Unknown";
@@ -181,7 +180,8 @@ const char* gm_get_reduce_string(int rop_type) {
 }
 const char* gm_get_reduce_expr_string(int rop_type) {
     const char* opstr = (rop_type == GMREDUCE_PLUS) ? "Sum" : (rop_type == GMREDUCE_MULT) ? "Product" : (rop_type == GMREDUCE_MIN) ? "Min" :
-                        (rop_type == GMREDUCE_MAX) ? "Max" : (rop_type == GMREDUCE_AND) ? "All" : (rop_type == GMREDUCE_OR) ? "Exist" : "??";
+                        (rop_type == GMREDUCE_MAX) ? "Max" : (rop_type == GMREDUCE_AND) ? "All" : (rop_type == GMREDUCE_OR) ? "Exist" :
+                        (rop_type == GMREDUCE_AVG) ? "Avg" : "??";
     return opstr;
 }
 
diff --git a/src/common/gm_reproduce.cc b/src/common/gm_reproduce.cc
index 97c9582..e3d6ae3 100644
--- a/src/common/gm_reproduce.cc
+++ b/src/common/gm_reproduce.cc
@@ -45,6 +45,13 @@ void ast_field::reproduce(int ind_level) {
     second->reproduce(0);
 }
 
+void ast_mapaccess::reproduce(int indLevel) {
+    mapId->reproduce(0);
+    Out.push('[');
+    keyExpr->reproduce(0);
+    Out.push(']');
+}
+
 void ast_typedecl::reproduce(int ind_level) {
     if (is_primitive()) {
         Out.push(gm_get_type_string(type_id));
@@ -96,6 +103,14 @@ void ast_typedecl::reproduce(int ind_level) {
     }
 }
 
+void ast_maptypedecl::reproduce(int indLevel) {
+    Out.push("Map <");
+    keyType->reproduce(0);
+    Out.push(", ");
+    valueType->reproduce(0);
+    Out.push(">");
+}
+
 void ast_argdecl::reproduce(int ind_level) {
     idlist->reproduce(0);
     Out.push(" : ");
@@ -250,6 +265,7 @@ void ast_expr::reproduce(int ind_level) {
         case GMEXPR_BIOP:
         case GMEXPR_LBIOP:
         case GMEXPR_COMP:
+            break;
         case GMEXPR_BUILTIN_FIELD:
         case GMEXPR_FOREIGN:
             //TODO add some print statements for these?
@@ -409,6 +425,18 @@ void ast_assign::reproduce(int ind_level) {
     Out.pushln(";");
 }
 
+void ast_assign_mapentry::reproduce(int indLevel) {
+    lhs->reproduce(0);
+    Out.SPC();
+    if(is_reduce_assign())
+        Out.push(gm_get_reduce_string(get_reduce_type()));
+    else
+        Out.push("=");
+    Out.SPC();
+    rhs->reproduce(0);
+    Out.pushln(";");
+}
+
 void ast_vardecl::reproduce(int ind_level) {
     type->reproduce(0);
     Out.SPC();
diff --git a/src/common/gm_resolve_inf_size.cc b/src/common/gm_resolve_inf_size.cc
index 10714cf..bb8ccd2 100644
--- a/src/common/gm_resolve_inf_size.cc
+++ b/src/common/gm_resolve_inf_size.cc
@@ -28,6 +28,7 @@ bool gm_resolve_size_of_inf_expr(ast_expr* e, int dest_type) {
         case GMEXPR_BVAL:
         case GMEXPR_INF:
         case GMEXPR_NIL:
+        case GMEXPR_MAPACCESS:
             break;
 
         case GMEXPR_UOP:
diff --git a/src/common/gm_resolve_nc.cc b/src/common/gm_resolve_nc.cc
index e440acc..f9dab4f 100644
--- a/src/common/gm_resolve_nc.cc
+++ b/src/common/gm_resolve_nc.cc
@@ -124,7 +124,8 @@ bool gm_reflect_symbol_entry_name(gm_symtab_entry *e_modified, ast_node* top)
 // If the new symbol has different orgname() from the old one, modify the name in the id node as well.
 // (Assumption. e_new is a valid symbol entry that does not break scoping rule)
 //---------------------------------------------------------------------------------------
-bool gm_replace_symbol_entry(gm_symtab_entry *e_old, gm_symtab_entry*e_new, ast_node* top);
+extern bool gm_replace_symbol_entry(gm_symtab_entry *e_old, gm_symtab_entry*e_new, ast_node* top);
+extern bool gm_replace_symbol_entry_bound(gm_symtab_entry *e_old, gm_symtab_entry*e_new, ast_node* top);
 
 class gm_replace_symbol_entry_t : public gm_apply
 {
@@ -162,3 +163,45 @@ bool gm_replace_symbol_entry(gm_symtab_entry *e_old, gm_symtab_entry*e_new, ast_
     T.do_replace(e_old, e_new, top);
     return T.is_changed();
 }
+
+class gm_replace_symbol_entry_bound_t : public gm_apply
+{
+public:
+    virtual bool apply(ast_sent* s) {
+        assert(_src != NULL);
+        assert(_target !=NULL);
+
+        if (s->get_nodetype() == AST_ASSIGN) {
+            ast_assign* a = (ast_assign*) s;
+            if (a->get_bound() != NULL) {
+                ast_id * i = a->get_bound();
+                assert(i->getSymInfo() != NULL);
+                if (i->getSymInfo() == _src) {
+                    i->setSymInfo(_target);
+                    _changed = true;
+                }
+                return true;
+            }
+        }
+    }
+    bool is_changed() {
+        return _changed;
+    }
+    void do_replace(gm_symtab_entry *e_old, gm_symtab_entry* e_new, ast_node* top) {
+        set_for_sent(true);
+        _src = e_old;
+        _target = e_new;
+        _changed = false;
+        top->traverse_pre(this);
+    }
+protected:
+    bool _changed;
+    gm_symtab_entry* _src;
+    gm_symtab_entry*_target;
+};
+
+bool gm_replace_symbol_entry_bound(gm_symtab_entry *e_old, gm_symtab_entry*e_new, ast_node* top) {
+    gm_replace_symbol_entry_bound_t T;
+    T.do_replace(e_old, e_new, top);
+    return T.is_changed();
+}
diff --git a/src/common/gm_transform_helper.cc b/src/common/gm_transform_helper.cc
index 7364e64..5b1dce3 100644
--- a/src/common/gm_transform_helper.cc
+++ b/src/common/gm_transform_helper.cc
@@ -278,6 +278,10 @@ void gm_add_sent_before(ast_sent* current, ast_sent* target, bool need_fix_symta
 void gm_add_sent_after(ast_sent* current, ast_sent* target, bool need_fix_symtab) {
     gm_add_sent(current, target, GM_INSERT_AFTER, need_fix_symtab);
 }
+void gm_replace_sent(ast_sent* current, ast_sent* target, bool need_fix_symtab) {
+    gm_add_sent_after(current, target, need_fix_symtab);
+    gm_ripoff_sent(current, need_fix_symtab);
+}
 
 void gm_ripoff_sent(ast_sent* target, bool need_fix_symtab) {
     // make sure that target belongs to a sent block
@@ -351,6 +355,12 @@ void gm_insert_sent_body_end(ast_foreach* fe, ast_sent* target, bool need_fix_sy
     }
 }
 
+
+void gm_remove_sent_from_sb(ast_sent* target, ast_sentblock* from, bool fix_symtab)
+{
+    gm_ripoff_sent(target, fix_symtab); // this is same from ripoff sent
+}
+
 class replace_subexpr_A : public gm_apply
 {
 public:
@@ -649,3 +659,39 @@ void gm_reconstruct_scope(ast_node* top)
     gm_reconstruct_scope_t T(top);
     top->traverse_pre(&T);
 }
+
+//------------------------------------------------------------
+// Sentenceblock related
+//------------------------------------------------------------
+bool gm_is_sentblock_empty(ast_sentblock* sb)
+{
+    std::list<ast_sent*>& L = sb->get_sents();
+    return (L.size() == 0);
+}
+bool gm_is_sentblock_trivial(ast_sentblock* sb, ast_sent* &s)
+{
+    std::list<ast_sent*>& L = sb->get_sents();
+    if (L.size() != 1) return false;
+
+    // also there should be no definitions
+    if (sb->get_symtab_var()->get_num_symbols() != 0) return false;
+    if (sb->get_symtab_field()->get_num_symbols() != 0) return false;
+    if (sb->get_symtab_proc()->get_num_symbols() != 0) return false;
+
+    s = L.front();
+    return true;
+}
+
+ast_sent* gm_get_sentence_if_trivial_sentblock(ast_sent* s) 
+{
+    if (s->get_nodetype() == AST_SENTBLOCK) 
+    {
+        ast_sent* t;
+        if (gm_is_sentblock_trivial((ast_sentblock*) s, t))
+        {
+            return t;
+        }
+    }
+
+    return s;
+}
diff --git a/src/common/gm_traverse.cc b/src/common/gm_traverse.cc
index e38f801..c2d2330 100644
--- a/src/common/gm_traverse.cc
+++ b/src/common/gm_traverse.cc
@@ -290,9 +290,27 @@ void ast_bfs::traverse_sent(gm_apply*a, bool is_post, bool is_pre) {
     }
 }
 
+void ast_assign_mapentry::traverse_sent(gm_apply* a, bool is_post, bool is_pre) {
+
+    if (is_pre) {
+        a->apply(to_assign_mapentry()->get_lhs_mapaccess()->get_key_expr());
+    }
+
+    get_rhs()->traverse(a, is_post, is_pre);
+
+    if (is_post) {
+            a->apply(to_assign_mapentry()->get_lhs_mapaccess()->get_key_expr());
+    }
+}
+
 void ast_assign::traverse_sent(gm_apply*a, bool is_post, bool is_pre) {
     bool for_id = a->is_for_id();
 
+    if (is_map_entry_assign()) {
+        printf("traversexxx\n");
+        a->apply(to_assign_mapentry()->get_lhs_mapaccess()->get_key_expr());
+    }
+
     if (is_pre) {
         if (for_id) {
             if (get_lhs_type() == GMASSIGN_LHS_SCALA) {
@@ -825,6 +843,13 @@ void ast_expr::traverse(gm_apply*a, bool is_post, bool is_pre) {
                 }
             }
             break;
+        case GMEXPR_MAPACCESS: {
+            ast_mapaccess* mapAccess = ((ast_expr_mapaccess*) this)->get_mapaccess();
+            a->set_for_rhs(true);
+            mapAccess->get_key_expr()->traverse(a, is_post, is_pre);
+            a->set_for_rhs(for_rhs);
+        }
+            break;
         case GMEXPR_UOP:
         case GMEXPR_LUOP:
             get_left_op()->traverse(a, is_post, is_pre);
diff --git a/src/frontend/gm_check_property_argument_usage.cc b/src/frontend/gm_check_property_argument_usage.cc
index 93316a5..d34b11a 100644
--- a/src/frontend/gm_check_property_argument_usage.cc
+++ b/src/frontend/gm_check_property_argument_usage.cc
@@ -39,7 +39,7 @@ public:
             condition_stack.push_back(s);
         } else if (s->get_nodetype() == AST_ASSIGN) {
             ast_assign* a = (ast_assign*) s;
-            if (!a->is_target_scalar()) {
+            if (!a->is_target_scalar() && !a->is_target_map_entry()) {
                 ast_field* f = a->get_lhs_field();
                 if (a->is_reduce_assign()) {  // this is read & write
                     property_is_read(f->get_second()->getSymInfo(), f->get_first()->getSymInfo(), true);
diff --git a/src/frontend/gm_expand_group_assignment.cc b/src/frontend/gm_expand_group_assignment.cc
index ab7a5d3..4c43992 100644
--- a/src/frontend/gm_expand_group_assignment.cc
+++ b/src/frontend/gm_expand_group_assignment.cc
@@ -53,7 +53,7 @@ public:
     virtual bool apply(ast_sent *s) {
         if (s->get_nodetype() != AST_ASSIGN) return true;
         ast_assign* a = (ast_assign*) s;
-        if (a->is_target_scalar()) return true;
+        if (a->is_target_scalar() || a->is_target_map_entry()) return true;
 
         ast_field* lhs = a->get_lhs_field();
         assert(lhs != NULL);
diff --git a/src/frontend/gm_fixup_bound_symbol.cc b/src/frontend/gm_fixup_bound_symbol.cc
index e265106..d600a83 100644
--- a/src/frontend/gm_fixup_bound_symbol.cc
+++ b/src/frontend/gm_fixup_bound_symbol.cc
@@ -201,6 +201,7 @@ public:
                 a->set_bound(bound->getId()->copy(true));
             }
         } else if (a->is_reduce_assign()) {
+            if(a->is_map_entry_assign()) return true;
             // null bound
             // find higest parallel region
             if (a->get_bound() == NULL) {
diff --git a/src/frontend/gm_frontend.cc b/src/frontend/gm_frontend.cc
index a58f070..dd80577 100644
--- a/src/frontend/gm_frontend.cc
+++ b/src/frontend/gm_frontend.cc
@@ -91,6 +91,12 @@ ast_node* GM_expr_field_access(ast_node* field) {
     return n;
 }
 
+ast_node* GM_expr_map_access(ast_node* mapAccess, int line, int column) {
+    assert(mapAccess != NULL);
+    assert(mapAccess->get_nodetype() == AST_MAPACCESS);
+    return ast_expr_mapaccess::new_expr_mapaccess((ast_mapaccess*)mapAccess, line, column);
+}
+
 ast_node* GM_expr_ival(long lval, int l, int c) {
     ast_node* n = ast_expr::new_ival_expr(lval);
     n->set_line(l);
@@ -263,12 +269,25 @@ ast_node* GM_queuetype_ref(ast_node* collectionType, ast_node* id) {
     return ast_typedecl::new_queue((ast_id*) id, (ast_typedecl*) collectionType);
 }
 
+ast_node* GM_maptype_ref(ast_node* key, ast_node* value) {
+    assert(key != NULL);
+    assert(value != NULL);
+    assert(key->get_nodetype() == AST_TYPEDECL);
+    assert(value->get_nodetype() == AST_TYPEDECL);
+    ast_typedecl* keyType = (ast_typedecl*)key;
+    ast_typedecl* valueType = (ast_typedecl*)value;
+    assert(gm_can_be_key_type((GMTYPE_T)keyType->getTypeSummary()));
+    assert(gm_can_be_value_type((GMTYPE_T)valueType->getTypeSummary()));
+    return ast_maptypedecl::new_map(keyType, valueType);
+}
+
 ast_node* GM_nodeprop_ref(ast_node* typedecl, ast_node* id) {
     assert(typedecl->get_nodetype() == AST_TYPEDECL);
     if (id == NULL) return ast_typedecl::new_nodeprop((ast_typedecl*) typedecl, NULL);
     assert(id->get_nodetype() == AST_ID);
     return ast_typedecl::new_nodeprop((ast_typedecl*) typedecl, (ast_id*) id);
 }
+
 ast_node* GM_edgeprop_ref(ast_node* typedecl, ast_node* id) {
     assert(typedecl->get_nodetype() == AST_TYPEDECL);
     if (id == NULL) return ast_typedecl::new_edgeprop((ast_typedecl*) typedecl, NULL);
@@ -326,6 +345,14 @@ ast_node* GM_field(ast_node* id1, ast_node* id2, bool is_rarrow) {
     return ast_field::new_field((ast_id*) id1, (ast_id*) id2, is_rarrow);
 }
 
+ast_node* GM_map_access(ast_node* mapId, ast_node* keyExpr) {
+    assert(mapId != NULL);
+    assert(keyExpr != NULL);
+    assert(mapId->get_nodetype() == AST_ID);
+    assert(keyExpr->get_nodetype() == AST_EXPR);
+    return ast_mapaccess::new_mapaccess((ast_id*)mapId, (ast_expr*)keyExpr);
+}
+
 void GM_add_id_comma_list(ast_node* id) {
     assert(id->get_nodetype() == AST_ID);
     ast_idlist* idlist = FE.get_current_idlist();
@@ -343,9 +370,10 @@ ast_node* GM_normal_assign(ast_node* lhs, ast_node* rhs) {
 
     if (lhs->get_nodetype() == AST_ID) {
         return ast_assign::new_assign_scala((ast_id*) lhs, (ast_expr*) rhs, GMASSIGN_NORMAL, NULL, GMREDUCE_NULL);
-
     } else if (lhs->get_nodetype() == AST_FIELD) {
         return ast_assign::new_assign_field((ast_field*) lhs, (ast_expr*) rhs, GMASSIGN_NORMAL, NULL, GMREDUCE_NULL);
+    } else if(lhs->get_nodetype() == AST_MAPACCESS) {
+        return ast_assign_mapentry::new_mapentry_assign((ast_mapaccess*)lhs, (ast_expr*)rhs);
     }
     assert(false);
     return NULL;
@@ -356,9 +384,10 @@ ast_node* GM_reduce_assign(ast_node* lhs, ast_node* rhs, ast_node* id, int reduc
 
     if (lhs->get_nodetype() == AST_ID) {
         return ast_assign::new_assign_scala((ast_id*) lhs, (ast_expr*) rhs, GMASSIGN_REDUCE, (ast_id*) id, reduce_type);
-
     } else if (lhs->get_nodetype() == AST_FIELD) {
         return ast_assign::new_assign_field((ast_field*) lhs, (ast_expr*) rhs, GMASSIGN_REDUCE, (ast_id*) id, reduce_type);
+    } else if (lhs->get_nodetype() == AST_MAPACCESS) {
+        return ast_assign_mapentry::new_mapentry_reduce_assign((ast_mapaccess*)lhs, (ast_expr*)rhs, reduce_type);
     } else {
         assert(false);
         return NULL;
diff --git a/src/frontend/gm_new_typecheck_step1.cc b/src/frontend/gm_new_typecheck_step1.cc
index 5cd1548..a0c1924 100644
--- a/src/frontend/gm_new_typecheck_step1.cc
+++ b/src/frontend/gm_new_typecheck_step1.cc
@@ -65,6 +65,7 @@ public:
 
         //printf("push\n");
     }
+
     virtual void end_context(ast_node * n) {
         assert(n->has_scope());
         curr_sym = var_syms.back();
@@ -80,6 +81,7 @@ public:
     void set_okay(bool b) {
         _is_okay = _is_okay && b;
     }
+
     bool is_okay() {
         return _is_okay;
     }
@@ -133,6 +135,20 @@ private:
                 return -1;
         }
     }
+
+    void checkAndSetBoundGraphsForMap(ast_mapaccess* mapAccess) {
+        ast_maptypedecl* mapDecl = (ast_maptypedecl*) mapAccess->get_map_id()->getTypeInfo();
+        ast_typedecl* keyType = mapDecl->get_key_type();
+        ast_typedecl* valueType = mapDecl->get_value_type();
+        if (gm_has_target_graph_type(keyType->getTypeSummary())) {
+            gm_symtab_entry* keyGraph = keyType->get_target_graph_sym();
+            mapAccess->set_bound_graph_for_key(keyGraph);
+        }
+        if (gm_has_target_graph_type(valueType->getTypeSummary())) {
+            gm_symtab_entry* valueGraph = valueType->get_target_graph_sym();
+            mapAccess->set_bound_graph_for_value(valueGraph);
+        }
+    }
 };
 
 // check id1 and id2 have same target graph symbol
@@ -244,6 +260,7 @@ ast_id* gm_get_default_graph(gm_symtab* symTab) {
             if (entryType->is_graph()) {
                 foundCount++;
                 if (foundCount > 1) {
+                    printf("FUU\n");
                     gm_type_error(GM_ERROR_DEFAULT_GRAPH_AMBIGUOUS, targetGraph, (*II)->getId());
                     return NULL;
                 }
@@ -288,7 +305,9 @@ bool gm_check_graph_is_defined(ast_typedecl* type, gm_symtab* symTab) {
 //     - connect nbr_id with the symbol
 //     - copy graph_id from collection_id
 //------------------------------------------------
-bool gm_check_type_is_well_defined(ast_typedecl* type, gm_symtab* SYM_V) {
+bool gm_check_type_is_well_defined(ast_typedecl* type, gm_symtab* SYM_V);
+
+bool gm_check_type_is_well_defined(ast_typedecl* type, gm_symtab* SYM_V, int targetType) {
     if (type->is_primitive() || type->is_void()) {
         //nothing to do
     } else if (type->is_graph()) {
@@ -297,7 +316,7 @@ bool gm_check_type_is_well_defined(ast_typedecl* type, gm_symtab* SYM_V) {
             gm_type_error(GM_ERROR_DEFAULT_GRAPH_AMBIGUOUS, (ast_id*) type, "", "");
             return false;
         }
-    } else if (type->is_collection() || type->is_nodeedge() || type->is_all_graph_iterator() || type->is_queue()) {
+    } else if (type->is_collection() || type->is_nodeedge() || type->is_all_graph_iterator() || type->is_collection_of_collection()) {
         bool is_okay = gm_check_graph_is_defined(type, SYM_V);
         if (!is_okay) return is_okay;
     } else if (type->is_property()) {
@@ -319,7 +338,15 @@ bool gm_check_type_is_well_defined(ast_typedecl* type, gm_symtab* SYM_V) {
         if (!is_okay) return false;
 
         // update collection iter type
-        if (type->is_unknown_collection_iterator()) type->setTypeSummary(gm_get_natural_collection_iterator(col->getTypeSummary()));
+        if (type->is_unknown_collection_iterator()) {
+            int iterType = (GMTYPE_T) gm_get_natural_collection_iterator(col->getTypeSummary());
+
+            if (iterType == GMTYPE_ITER_UNDERSPECIFIED && targetType != GMTYPE_INVALID) {
+                iterType = gm_get_specified_collection_iterator(targetType);
+            }
+
+            type->setTypeSummary(iterType);
+        }
 
         // copy graph_id
         type->set_target_graph_id(col->getTypeInfo()->get_target_graph_id()->copy(true));
@@ -335,11 +362,19 @@ bool gm_check_type_is_well_defined(ast_typedecl* type, gm_symtab* SYM_V) {
         ast_id* node = type->get_target_nbr_id();
         assert(node != NULL);
         bool is_okay = gm_check_target_is_defined(node, SYM_V, SHOULD_BE_A_NODE_COMPATIBLE);
-        if (!is_okay) return is_okay;
+        if (!is_okay) return false;
 
         // copy graph_id
         //printf("copying graph id = %s\n", node->getTypeInfo()->get_target_graph_id()->get_orgname());
         type->set_target_graph_id(node->getTypeInfo()->get_target_graph_id()->copy(true));
+    } else if (type->is_map()) {
+        ast_maptypedecl* mapType = (ast_maptypedecl*) type;
+        if(gm_has_target_graph_type(mapType->getKeyTypeSummary())) {
+            if(!gm_check_graph_is_defined(mapType->get_key_type(), SYM_V)) return false;
+        }
+        if(gm_has_target_graph_type(mapType->getValueTypeSummary())) {
+            if(!gm_check_graph_is_defined(mapType->get_value_type(), SYM_V)) return false;
+        }
     } else {
         printf("%s", gm_get_type_string(type->getTypeSummary()));
         assert(false);
@@ -349,6 +384,10 @@ bool gm_check_type_is_well_defined(ast_typedecl* type, gm_symtab* SYM_V) {
     return true;
 }
 
+bool gm_check_type_is_well_defined(ast_typedecl* type, gm_symtab* SYM_V) {
+    return gm_check_type_is_well_defined(type, SYM_V, GMTYPE_INVALID);
+}
+
 //---------------------
 // (This function can be used after type-checking)
 // add a (copy of) symbol and (copy of) type into a symtab, error if symbol is duplicated
@@ -357,14 +396,14 @@ bool gm_check_type_is_well_defined(ast_typedecl* type, gm_symtab* SYM_V) {
 //
 // The name is added to the current procedure vocaburary 
 //---------------------
-bool gm_declare_symbol(gm_symtab* SYM, ast_id* id, ast_typedecl* type, bool is_readable, bool is_writeable, gm_symtab* SYM_ALT) {
+bool gm_declare_symbol(gm_symtab* SYM, ast_id* id, ast_typedecl* type, bool is_readable, bool is_writeable, gm_symtab* SYM_ALT, int targetType) {
 
     if (!type->is_well_defined()) {
         assert(!type->is_property());
         // if so SYM is FIELD actually.
         if (SYM_ALT != NULL) {
-            if (!gm_check_type_is_well_defined(type, SYM_ALT)) return false;
-        } else if (!gm_check_type_is_well_defined(type, SYM)) {
+            if (!gm_check_type_is_well_defined(type, SYM_ALT, targetType)) return false;
+        } else if (!gm_check_type_is_well_defined(type, SYM, targetType)) {
             return false;
         }
     }
@@ -379,8 +418,12 @@ bool gm_declare_symbol(gm_symtab* SYM, ast_id* id, ast_typedecl* type, bool is_r
     return is_okay;
 }
 
+bool gm_declare_symbol(gm_symtab* SYM, ast_id* id, ast_typedecl* type, bool is_readable, bool is_writeable, gm_symtab* SYM_ALT) {
+    return gm_declare_symbol(SYM, id, type, is_readable, is_writeable, SYM_ALT, GMTYPE_INVALID);
+}
+
 bool gm_declare_symbol(gm_symtab* SYM, ast_id* id, ast_typedecl* type, bool is_readable, bool is_writeable) {
-    return gm_declare_symbol(SYM, id, type, is_readable, is_writeable, NULL);
+    return gm_declare_symbol(SYM, id, type, is_readable, is_writeable, NULL, GMTYPE_INVALID);
 }
 
 // symbol checking for foreach and in-place reduction
@@ -456,8 +499,11 @@ bool gm_typechecker_stage_1::gm_symbol_check_iter_header(ast_id* it, ast_id* src
     } else {
         type = ast_typedecl::new_nodeedge_iterator(src->copy(true), iter_type);
     }
+
     if (gm_is_iteration_on_property(iter_type))
         is_okay = gm_declare_symbol(curr_sym, it, type, GM_READ_AVAILABLE, GM_WRITE_NOT_AVAILABLE, curr_field);
+    else if (src->getTypeInfo()->is_collection_of_collection())
+        is_okay = gm_declare_symbol(curr_sym, it, type, GM_READ_AVAILABLE, GM_WRITE_NOT_AVAILABLE, NULL, src->getTargetTypeSummary());
     else
         is_okay = gm_declare_symbol(curr_sym, it, type, GM_READ_AVAILABLE, GM_WRITE_NOT_AVAILABLE);
 
@@ -598,6 +644,11 @@ bool gm_typechecker_stage_1::apply(ast_sent* s) {
             if (a->is_target_scalar()) {
                 ast_id* id = a->get_lhs_scala();
                 is_okay = find_symbol_id(id);
+            } else if(a->is_target_map_entry()){
+                ast_assign_mapentry* mapAssign = (ast_assign_mapentry*)a;
+                ast_mapaccess* mapAccess = mapAssign->get_lhs_mapaccess();
+                is_okay = find_symbol_id(mapAccess->get_map_id());
+                checkAndSetBoundGraphsForMap(mapAccess);
             } else {
                 ast_field* f = a->get_lhs_field();
                 is_okay = find_symbol_field(f);
@@ -719,6 +770,12 @@ bool gm_typechecker_stage_1::apply(ast_expr* p) {
             is_okay = find_symbol_field(p->get_field());
             break;
         }
+        case GMEXPR_MAPACCESS: {
+            is_okay = find_symbol_id(p->get_id());
+            ast_mapaccess* mapAccess = ((ast_expr_mapaccess*) p)->get_mapaccess();
+            checkAndSetBoundGraphsForMap(mapAccess);
+            break;
+        }
         case GMEXPR_REDUCE: {
             ast_expr_reduce* r = (ast_expr_reduce*) p;
             int iter_type = r->get_iter_type();
diff --git a/src/frontend/gm_new_typecheck_step2.cc b/src/frontend/gm_new_typecheck_step2.cc
index 5af4e9a..34964db 100644
--- a/src/frontend/gm_new_typecheck_step2.cc
+++ b/src/frontend/gm_new_typecheck_step2.cc
@@ -41,7 +41,7 @@ public:
 
         if (s->get_nodetype() == AST_ASSIGN) {
             ast_assign *a = (ast_assign*) s;
-            if (!a->is_target_scalar()) {
+            if (!a->is_target_scalar() && !a->is_target_map_entry()) {
                 ast_field* f = a->get_lhs_field();
                 if (f->get_first()->getTypeInfo()->is_graph() || f->get_first()->getTypeInfo()->is_collection()) {
 
@@ -141,12 +141,15 @@ bool gm_typechecker_stage_2::apply_on_builtin(ast_expr_builtin* builtinExpr) {
     int sourceType = builtinExpr->get_source_type();
     switch(sourceType) {
         case GMTYPE_PROPERTYITER_SET:
+        case GMTYPE_COLLECTIONITER_SET:
             sourceType = GMTYPE_NSET;
             break;
         case GMTYPE_PROPERTYITER_SEQ:
+        case GMTYPE_COLLECTIONITER_SEQ:
             sourceType = GMTYPE_NSEQ;
             break;
         case GMTYPE_PROPERTYITER_ORDER:
+        case GMTYPE_COLLECTIONITER_ORDER:
             sourceType = GMTYPE_NORDER;
             break;
         default:
diff --git a/src/frontend/gm_new_typecheck_step3.cc b/src/frontend/gm_new_typecheck_step3.cc
index ede5036..df5f322 100644
--- a/src/frontend/gm_new_typecheck_step3.cc
+++ b/src/frontend/gm_new_typecheck_step3.cc
@@ -23,6 +23,18 @@ public:
     gm_typechecker_stage_3() {
         _is_okay = true;
         set_for_expr(true);
+        set_for_sent(true);
+    }
+
+    bool apply(ast_sent* s) {
+        if (s->get_nodetype() == AST_ASSIGN) {
+            ast_assign* a = (ast_assign*) s;
+            if (a->is_map_entry_assign()) {
+                ast_mapaccess* mapAccess = a->to_assign_mapentry()->get_lhs_mapaccess();
+                return check_boundGraphsForKeyAndValue(mapAccess, a->get_line(), a->get_col());
+            }
+        }
+        return true;
     }
 
     // post apply
@@ -38,6 +50,9 @@ public:
                         gm_symtab_entry * g = t->get_target_graph_sym();
                         assert(g != NULL);
                         e->set_bound_graph(g);
+                    } else if (t->is_map()) {
+                        ast_maptypedecl* mapDecl = (ast_maptypedecl*) t;
+                        e->set_type_summary(mapDecl->getValueTypeSummary());
                     }
                 }
                 break;
@@ -106,6 +121,10 @@ public:
                 e->set_type_summary(GMTYPE_FOREIGN_EXPR);
                 okay = true;
                 break;
+            case GMEXPR_MAPACCESS: {
+                okay = check_mapaccess((ast_expr_mapaccess*) e);
+            }
+                break;
             default:
                 assert(false);
                 break;
@@ -131,7 +150,12 @@ private:
     bool check_binary(ast_expr* e);
     bool check_ter(ast_expr* e);
     bool check_builtin(ast_expr_builtin* e);
+    bool resolveGenericOutputType(ast_expr_builtin* b);
+    int resolveGenericInputType(ast_expr_builtin* b, int argPosition);
     bool check_arguments(ast_expr_builtin* b);
+    bool check_mapaccess(ast_expr_mapaccess* mapAccessExpr);
+    bool check_boundGraphsForKeyAndValue(ast_mapaccess* mapAccess, int line, int column);
+    int tryResolveUnknownType(int type);
 
 public:
     // expression, dest-type
@@ -176,6 +200,59 @@ static bool check_special_case_inside_group_assign(ast_id* l_id, int alt_type_l,
     return true;
 }
 
+bool gm_typechecker_stage_3::check_mapaccess(ast_expr_mapaccess* mapAccessExpr) {
+    mapAccessExpr->set_type_summary(mapAccessExpr->get_id()->getTypeSummary());
+    ast_typedecl* t = mapAccessExpr->get_id()->getTypeInfo();
+    ast_maptypedecl* mapDecl = (ast_maptypedecl*) t;
+    mapAccessExpr->set_type_summary(mapDecl->getValueTypeSummary());
+
+    //check if key-type and key-expression-type are compatible
+    ast_mapaccess* mapAccess = mapAccessExpr->get_mapaccess();
+    ast_expr* keyExpr = mapAccess->get_key_expr();
+    int keyExprType = keyExpr->get_type_summary();
+
+    gm_symtab_entry* mapEntry = mapAccess->get_map_id()->getSymInfo();
+    assert(mapEntry != NULL);
+    assert(mapEntry->getType()->is_map());
+    ast_maptypedecl* mapTypeDecl = (ast_maptypedecl*) mapEntry->getType();
+    int keyType = mapTypeDecl->getKeyTypeSummary();
+
+    int dummy;
+    bool warning;
+    bool isOkay = gm_is_compatible_type_for_assign(keyType, keyExprType, dummy, warning);
+    int line = mapAccessExpr->get_line();
+    int column = mapAccessExpr->get_col();
+    if (!isOkay) {
+        gm_type_error(GM_ERROR_KEY_MISSMATCH, line, column, gm_get_type_string(keyType), gm_get_type_string(keyExprType));
+    } else if (warning) {
+        printf("warning: implicit type conversion %s->%s\n", gm_get_type_string(keyType), gm_get_type_string(keyExprType));
+    }
+
+    isOkay &= check_boundGraphsForKeyAndValue(mapAccess, line, column);
+    return isOkay;
+}
+
+bool gm_typechecker_stage_3::check_boundGraphsForKeyAndValue(ast_mapaccess* mapAccess, int line, int column) {
+    //check if target graphs for key are the same
+    int keyType = mapAccess->get_key_expr()->get_type_summary();
+    if (gm_has_target_graph_type(keyType)) {
+        gm_symtab_entry* keyGraph = mapAccess->get_bound_graph_for_key();
+        ast_expr* keyExpr = mapAccess->get_key_expr();
+        int keyExprType = keyExpr->get_type_summary();
+        gm_symtab_entry* keyExprGraph = keyExpr->get_bound_graph();
+        if (keyExprGraph == NULL) {
+            assert(gm_is_nil_type(keyExprType) || gm_is_foreign_expr_type(keyExprType));
+        } else {
+            if (keyGraph != keyExprGraph) {
+                gm_type_error(GM_ERROR_TARGET_MISMATCH, line, column);
+                return false;
+            }
+        }
+    }
+    return true;
+}
+;
+
 // comparison (eq, neq and less)
 bool gm_typechecker_stage_3::check_binary(ast_expr* e) {
     int op_type = e->get_optype();
@@ -287,6 +364,33 @@ static bool gm_is_compatible_type_collection_of_collection(int shouldbeType, int
     return true;
 }
 
+int gm_typechecker_stage_3::resolveGenericInputType(ast_expr_builtin* b, int argPosition) {
+
+    gm_builtin_def* def = b->get_builtin_def();
+    ast_id* driver = b->get_driver();
+    assert(driver->getTypeSummary() == GMTYPE_MAP);
+    // we only support maps atm
+    ast_typedecl* typeDecl = driver->getTypeInfo();
+    ast_maptypedecl* mapTypeDecl = (ast_maptypedecl*) typeDecl;
+    if (def->genericArgumentTypeIsKeyType(argPosition))
+        return mapTypeDecl->getKeyTypeSummary();
+    else
+        return mapTypeDecl->getValueTypeSummary();
+}
+
+int gm_typechecker_stage_3::tryResolveUnknownType(int type) {
+    switch (type) {
+        case GMTYPE_COLLECTIONITER_SET:
+            return GMTYPE_NSET;
+        case GMTYPE_COLLECTIONITER_ORDER:
+            return GMTYPE_NORDER;
+        case GMTYPE_COLLECTIONITER_SEQ:
+            return GMTYPE_NSEQ;
+        default:
+            return type;
+    }
+}
+
 bool gm_typechecker_stage_3::check_arguments(ast_expr_builtin* b) {
 
     bool okay = true;
@@ -299,17 +403,23 @@ bool gm_typechecker_stage_3::check_arguments(ast_expr_builtin* b) {
         ast_expr* e = *iter;
         int currentType = e->get_type_summary();
         int def_type = def->get_arg_type(position);
-        if (gm_is_unknown_type(currentType)) {
+        if (def_type == GMTYPE_GENERIC) {
+            def_type = (int) resolveGenericInputType(b, position);
+        } else if (gm_is_unknown_type(currentType)) {
             okay = false;
             continue;
         }
+
+        currentType = tryResolveUnknownType(currentType);
+
         bool warning;
         int coerced_type;
         bool isCompatible;
-        if (gm_is_queue_type(b->get_source_type()))
+        if (gm_is_collection_of_collection_type(b->get_source_type())) {
             isCompatible = gm_is_compatible_type_collection_of_collection(b->get_driver()->getTargetTypeSummary(), currentType, def->get_method_id());
-        else
+        } else {
             isCompatible = gm_is_compatible_type_for_assign(def_type, currentType, coerced_type, warning);
+        }
         if (!isCompatible) {
             char temp[20];
             sprintf(temp, "%d", position + 1);
@@ -329,6 +439,10 @@ bool gm_typechecker_stage_3::check_builtin(ast_expr_builtin* b) {
     bool okay = check_arguments(b);
     gm_builtin_def* def = b->get_builtin_def();
     int fun_ret_type = def->get_result_type_summary();
+
+    if (fun_ret_type == GMTYPE_GENERIC) {
+        return resolveGenericOutputType(b);
+    }
     b->set_type_summary(fun_ret_type);
 
     if (gm_has_target_graph_type(fun_ret_type)) {
@@ -342,6 +456,33 @@ bool gm_typechecker_stage_3::check_builtin(ast_expr_builtin* b) {
     return okay;
 }
 
+bool gm_typechecker_stage_3::resolveGenericOutputType(ast_expr_builtin* b) {
+    gm_builtin_def* def = b->get_builtin_def();
+    ast_id* driver = b->get_driver();
+    assert(driver->getTypeSummary() == GMTYPE_MAP);
+    ast_typedecl* typeDecl = driver->getTypeInfo();
+    assert(typeDecl->is_map());
+    ast_maptypedecl* mapTypeDecl = (ast_maptypedecl*) typeDecl;
+    int funcReturnType;
+    if (def->genericTypeIsKeyType())
+        funcReturnType = mapTypeDecl->getKeyTypeSummary();
+    else
+        funcReturnType = mapTypeDecl->getValueTypeSummary();
+
+    b->set_type_summary(funcReturnType);
+
+    if (gm_has_target_graph_type(funcReturnType)) {
+        gm_symtab_entry* graph;
+        if (def->genericTypeIsKeyType())
+            graph = mapTypeDecl->get_key_type()->get_target_graph_sym();
+        else
+            graph = mapTypeDecl->get_value_type()->get_target_graph_sym();
+        b->set_bound_graph(graph);
+    }
+
+    return true;
+}
+
 // type resolve for u-op
 bool gm_typechecker_stage_3::check_uop(ast_expr* e) {
     int op_type = e->get_optype();
diff --git a/src/frontend/gm_new_typecheck_step4.cc b/src/frontend/gm_new_typecheck_step4.cc
index 7813e59..0e8ed13 100644
--- a/src/frontend/gm_new_typecheck_step4.cc
+++ b/src/frontend/gm_new_typecheck_step4.cc
@@ -36,6 +36,10 @@ public:
             int lhs_type;
             if (a->is_target_scalar()) {
                 lhs_type = a->get_lhs_scala()->getTypeSummary();
+            } else if (a->is_target_map_entry()) {
+                ast_mapaccess* mapAccess = a->to_assign_mapentry()->get_lhs_mapaccess();
+                ast_maptypedecl* mapDecl = (ast_maptypedecl*)mapAccess->get_map_id()->getTypeInfo();
+                lhs_type = mapDecl->getValueTypeSummary();
             } else {
                 lhs_type = a->get_lhs_field()->getTargetTypeSummary();
             }
diff --git a/src/frontend/gm_new_typecheck_step5.cc b/src/frontend/gm_new_typecheck_step5.cc
index 5bf220c..4a1d107 100644
--- a/src/frontend/gm_new_typecheck_step5.cc
+++ b/src/frontend/gm_new_typecheck_step5.cc
@@ -124,6 +124,24 @@ public:
                 gm_type_error(GM_ERROR_READONLY, l);
                 return false;
             }
+        } else if (lhs->get_nodetype() == AST_MAPACCESS) {
+            ast_mapaccess* mapAccess = (ast_mapaccess*) lhs;
+            ast_maptypedecl* mapDecl = (ast_maptypedecl*) mapAccess->get_map_id()->getTypeInfo();
+            l_sym = mapAccess->get_bound_graph_for_value();
+            summary_lhs = mapDecl->getValueTypeSummary();
+
+            int keyType = mapDecl->getKeyTypeSummary();
+            int keyExprType = mapAccess->get_key_expr()->get_type_summary();
+            int dummy;
+            bool warning;
+            bool isOkay = gm_is_compatible_type_for_assign(keyType, keyExprType, dummy, warning);
+            if (!isOkay) {
+                gm_type_error(GM_ERROR_KEY_MISSMATCH, l, c, gm_get_type_string(keyType), gm_get_type_string(keyExprType));
+                return false;
+            } else if (warning) {
+                printf("warning: implicit type conversion %s->%s\n", gm_get_type_string(keyType), gm_get_type_string(keyExprType));
+            }
+
         } else {
             // target type (e.g. N_P<Int> -> Int)
             ast_field* f = (ast_field*) lhs;
@@ -132,11 +150,11 @@ public:
             if (f->getTargetTypeInfo()->has_target_graph()) {
                 l_sym = f->getTargetTypeInfo()->get_target_graph_sym();
             }
-
         }
 
         // check assignable
         summary_rhs = rhs->get_type_summary();
+        summary_rhs = tryResolveIfUnknown(summary_rhs);
 
         bool warn;
         int coed;
@@ -150,16 +168,14 @@ public:
         }
 
         if (gm_has_target_graph_type(summary_lhs)) {
-            gm_symtab_entry* r_sym = rhs->get_bound_graph();
-            assert(l_sym != NULL);
-            if (r_sym == NULL) {
-                assert(gm_is_nil_type(summary_rhs) || gm_is_foreign_expr_type(summary_rhs));
+            gm_symtab_entry* r_sym;
+            if (rhs->is_mapaccess()) {
+                ast_mapaccess* mapAccess = ((ast_expr_mapaccess*) rhs)->get_mapaccess();
+                r_sym = mapAccess->get_bound_graph_for_value();
             } else {
-                if (l_sym != r_sym) {
-                    gm_type_error(GM_ERROR_TARGET_MISMATCH, l, c);
-                    return false;
-                }
+                r_sym = rhs->get_bound_graph();
             }
+            return checkGraphs(l_sym, r_sym, summary_rhs, l, c);
         }
 
         return true;
@@ -173,11 +189,15 @@ public:
         if (a->is_target_scalar()) {
             okay = check_assign_lhs_rhs(a->get_lhs_scala(), a->get_rhs(), l, c);
             summary_lhs = a->get_lhs_scala()->getTypeSummary();
+        } else if (a->is_target_map_entry()) {
+            ast_mapaccess* mapAccess = a->to_assign_mapentry()->get_lhs_mapaccess();
+            okay = check_assign_lhs_rhs(mapAccess, a->get_rhs(), l, c);
+            ast_maptypedecl* mapDecl = (ast_maptypedecl*) mapAccess->get_map_id()->getTypeInfo();
+            summary_lhs = mapDecl->getValueTypeSummary();
         } else {
             okay = check_assign_lhs_rhs(a->get_lhs_field(), a->get_rhs(), l, c);
             summary_lhs = a->get_lhs_field()->get_second()->getTargetTypeSummary();
         }
-
         // check body of reduce
         if (a->is_reduce_assign()) {
 
@@ -236,6 +256,31 @@ private:
     bool _is_okay;
     ast_typedecl* ret;
 
+    bool checkGraphs(gm_symtab_entry* l_sym, gm_symtab_entry* r_sym, int summary_rhs, int line, int column) {
+        assert(l_sym != NULL);
+        if (r_sym == NULL) {
+            assert(gm_is_nil_type(summary_rhs) || gm_is_foreign_expr_type(summary_rhs));
+        } else {
+            if (l_sym != r_sym) {
+                gm_type_error(GM_ERROR_TARGET_MISMATCH, line, column);
+                return false;
+            }
+        }
+        return true;
+    }
+
+    int tryResolveIfUnknown(int type) {
+        switch (type) {
+            case GMTYPE_PROPERTYITER_SET:
+                return GMTYPE_NSET;
+            case GMTYPE_PROPERTYITER_SEQ:
+                return GMTYPE_NSEQ;
+            case GMTYPE_PROPERTYITER_ORDER:
+                return GMTYPE_NORDER;
+        }
+        return type;
+    }
+
 public:
     std::map<ast_expr*, int> coercion_targets;
 };
diff --git a/src/frontend/gm_rw_analysis.cc b/src/frontend/gm_rw_analysis.cc
index 6766930..944f4c2 100644
--- a/src/frontend/gm_rw_analysis.cc
+++ b/src/frontend/gm_rw_analysis.cc
@@ -344,6 +344,11 @@ void traverse_expr_for_readset_adding(ast_expr* e, gm_rwinfo_map& rset, temp_map
         case GMEXPR_FIELD:
             traverse_expr_for_readset_adding_field(e, rset, DrvMap);
             break;
+        case GMEXPR_MAPACCESS: {
+            ast_mapaccess* mapAccess = ((ast_expr_mapaccess*) e)->get_mapaccess();
+            traverse_expr_for_readset_adding(mapAccess->get_key_expr(), rset, DrvMap);//TODO
+        }
+            break;
         case GMEXPR_UOP:
         case GMEXPR_LUOP:
             traverse_expr_for_readset_adding(e->get_left_op(), rset, DrvMap);
@@ -489,7 +494,7 @@ bool gm_rw_analysis::apply_assign(ast_assign *a) {
     gm_rwinfo_map& D = sets->reduce_set;
 
     // (1) LHS
-    bool is_reduce = (a->is_reduce_assign() || a->is_defer_assign());
+    bool is_reduce = (a->is_reduce_assign() || a->is_defer_assign()) && !a->is_map_entry_assign();
     gm_symtab_entry* bound_sym = NULL;
     int bound_op = GMREDUCE_NULL;
     if (is_reduce) {
@@ -505,6 +510,10 @@ bool gm_rw_analysis::apply_assign(ast_assign *a) {
     if (a->get_lhs_type() == GMASSIGN_LHS_SCALA) {
         target_sym = a->get_lhs_scala()->getSymInfo();
         new_entry = gm_rwinfo::new_scala_inst(a->get_lhs_scala(), bound_op, bound_sym);
+    } else if (a->get_lhs_type() == GMASSIGN_LHS_MAP) {
+        ast_mapaccess* mapAccess = a->to_assign_mapentry()->get_lhs_mapaccess();
+        target_sym = mapAccess->get_map_id()->getSymInfo();
+        new_entry = gm_rwinfo::new_scala_inst(mapAccess->get_map_id(), bound_op, bound_sym);//TODO
     } else {
         target_sym = a->get_lhs_field()->get_second()->getSymInfo();
         gm_symtab_entry* iter_sym = a->get_lhs_field()->get_first()->getSymInfo();
@@ -990,8 +999,7 @@ static bool cleanup_iterator_access_reduce(ast_id* iter, gm_rwinfo_map& D_temp,
                     if (cp->access_range != GM_RANGE_SINGLE) {
                         cp->access_range = GM_RANGE_RANDOM; // scalar access becomes random access
                     }
-                }
-                else if (!cp->driver->getType()->is_node_edge_iterator()) {
+                } else if (!cp->driver->getType()->is_node_edge_iterator()) {
                     cp->access_range = GM_RANGE_RANDOM;
                     cp->driver = NULL;
                 }
@@ -1065,7 +1073,6 @@ bool gm_rw_analysis::apply_foreach(ast_foreach* a) {
     //printf("R:");gm_print_rwinfo_set(R);
     //printf("done\n");
 
-
     return is_okay;
 }
 
diff --git a/src/frontend/gm_typecheck_oprules.cc b/src/frontend/gm_typecheck_oprules.cc
index 7f2d801..d7618d9 100644
--- a/src/frontend/gm_typecheck_oprules.cc
+++ b/src/frontend/gm_typecheck_oprules.cc
@@ -226,6 +227,10 @@ bool gm_is_compatible_type(int op, int t1, int t2, int& op_result_type, int& t1_
         t2 = t1;
     }
 
+    if ((gm_is_set_collection_type(t1) && gm_is_collection_of_set_iter_type(t2))
+            || (gm_is_sequence_collection_type(t1) && gm_is_collection_of_seq_iter_type(t2))
+            || (gm_is_order_collection_type(t1) && gm_is_collection_of_order_iter_type(t2))) t2 = t1;
+
     for (int i = 0; i < (int) GM_TYPE_RULES.size(); i++) {
         gm_type_rule& R = GM_TYPE_RULES[i];
 
diff --git a/src/inc/gm_ast.h b/src/inc/gm_ast.h
index 319459b..a54f1c0 100644
--- a/src/inc/gm_ast.h
+++ b/src/inc/gm_ast.h
@@ -17,6 +17,7 @@ enum AST_NODE_TYPE
 {
     AST_ID,       // 
     AST_FIELD,    // A.B
+    AST_MAPACCESS,    // A[B]
     AST_IDLIST,   // A, B, C, 
     AST_TYPEDECL, // INT
     AST_ARGDECL,  // a,b : B
@@ -25,6 +26,7 @@ enum AST_NODE_TYPE
     AST_EXPR_RDC,       // c + 3
     AST_EXPR_BUILTIN,   // c + 3
     AST_EXPR_FOREIGN,  // Foreign Expression
+    AST_EXPR_MAPACCESS,
     AST_SENT,     // 
     AST_SENTBLOCK, // { ... }
     AST_ASSIGN,   // C =D
@@ -568,7 +573,7 @@ private:
 
 class ast_typedecl: public ast_node
 {  // property or type
-private:
+protected:
     ast_typedecl() :
             ast_node(AST_TYPEDECL), target_type(NULL), target_graph(NULL), target_collection(NULL), target_nbr(NULL), target_nbr2(NULL), _well_defined(false), type_id(
                     0) {
@@ -576,7 +581,7 @@ private:
 
 public:
     // give a deep copy
-    ast_typedecl* copy() {
+    virtual ast_typedecl* copy() {
         ast_typedecl *p = new ast_typedecl();
         p->type_id = this->type_id;
         p->target_type = (this->target_type == NULL) ? NULL : this->target_type->copy();
@@ -671,7 +676,7 @@ public:
 
     static ast_typedecl* new_queue(ast_id* targetGraph, ast_typedecl* collectionType) {
         ast_typedecl* typeDecl = new ast_typedecl();
-        typeDecl->type_id = GMTYPE_QUEUE;
+        typeDecl->type_id = GMTYPE_COLLECTION;
         typeDecl->target_type = collectionType;
         if (targetGraph == NULL) return typeDecl; //no graph defined for this queue - we will handle this later (typecheck step 1)
         typeDecl->target_graph = targetGraph;
@@ -734,7 +739,7 @@ public:
         return t;
     }
 
-    int get_typeid() {
+    virtual int get_typeid() {
         return type_id;
     }
 
@@ -779,8 +784,8 @@ public:
         return gm_is_collection_type(type_id);
     }
 
-    bool is_queue() {
-        return gm_is_queue_type(type_id);
+    bool is_collection_of_collection() {
+        return gm_is_collection_of_collection_type(type_id);
     }
 
     bool is_node_collection() {
@@ -875,6 +880,10 @@ public:
         return gm_is_sequential_collection_type(type_id);
     }
 
+    virtual bool is_map() {
+        return false;
+    }
+
     virtual void reproduce(int id_level);
     virtual void dump_tree(int id_level);
 
@@ -886,7 +895,7 @@ public:
             assert(target_collection->getTypeInfo() != NULL);
             assert(target_collection->getTypeInfo()->get_target_graph_sym() != NULL);
             return target_collection->getTypeInfo()->get_target_graph_sym();
-        } else if (is_collection() || is_property() || is_nodeedge() || is_node_iterator() || is_edge_iterator() || is_queue()) {
+        } else if (is_collection() || is_property() || is_nodeedge() || is_node_iterator() || is_edge_iterator() || is_collection_of_collection() || gm_is_property_iter_type(type_id)) {
             assert(target_graph != NULL);
             assert(target_graph->getSymInfo() != NULL);
             return target_graph->getSymInfo();
@@ -921,7 +930,7 @@ public:
         return target_type;
     }
 
-    int getTypeSummary() {  // same as get type id
+    virtual int getTypeSummary() {  // same as get type id
         return type_id;
     }
 
@@ -931,7 +940,7 @@ public:
     }
 
     int getTargetTypeSummary() {
-        assert(is_property() || is_queue());
+        assert(is_property() || is_collection_of_collection());
         assert(target_type != NULL);
         return target_type->getTypeSummary();
     }
@@ -958,15 +967,100 @@ public:
 
 private:
     // defined in gm_frontend_api.h
-    int type_id;
     ast_typedecl* target_type;  // for property
     ast_id* target_graph;       // for property, node, edge, set
     ast_id* target_collection;  // for set-iterator set
     ast_id* target_nbr;         // for nbr-iterator
     ast_id* target_nbr2;        // for common neighbor iterator
+
+protected:
+    int type_id;
     bool _well_defined;
 };
 
+class ast_maptypedecl: public ast_typedecl
+{
+
+private:
+    ast_typedecl* keyType;
+    ast_typedecl* valueType;
+
+    ast_maptypedecl() :
+            ast_typedecl(), keyType(NULL), valueType(NULL) {
+    }
+
+public:
+
+    ~ast_maptypedecl() {
+        delete keyType;
+        delete valueType;
+    }
+
+    virtual void reproduce(int id_level);
+
+    static ast_maptypedecl* new_map(ast_typedecl* keyType, ast_typedecl* valueType) {
+        ast_maptypedecl* newMap = new ast_maptypedecl();
+        newMap->type_id = GMTYPE_MAP;
+        newMap->keyType = keyType;
+        newMap->valueType = valueType;
+        keyType->set_parent(newMap);
+        valueType->set_parent(newMap);
+        return newMap;
+    }
+
+    ast_typedecl* copy() {
+        ast_maptypedecl* clone = new ast_maptypedecl();
+        clone->type_id = type_id;
+        clone->keyType = (keyType == NULL) ? NULL : keyType->copy();
+        clone->valueType = (valueType == NULL) ? NULL : valueType->copy();
+        clone->line = line;
+        clone->col = col;
+        clone->_well_defined = this->_well_defined;
+        return clone;
+    }
+
+    void set_key_type(ast_typedecl* newKeyType) {
+        assert(gm_can_be_key_type((GMTYPE_T)newKeyType->getTypeSummary()));
+        keyType = newKeyType;
+    }
+
+    ast_typedecl* get_key_type() {
+        return keyType;
+    }
+
+    ast_typedecl* get_value_type() {
+        return valueType;
+    }
+
+    void set_value_type(ast_typedecl* newValueType) {
+        assert(gm_can_be_key_type((GMTYPE_T)newValueType->getTypeSummary()));
+        valueType = newValueType;
+    }
+
+    bool is_map() {
+        return true;
+    }
+
+    int get_typeid() {
+        return (int) GMTYPE_MAP;
+    }
+
+    int getTypeSummary() {
+        return get_typeid();
+    }
+
+    int getKeyTypeSummary() {
+        assert(keyType != NULL);
+        return keyType->getTypeSummary();
+    }
+
+    int getValueTypeSummary() {
+        assert(valueType != NULL);
+        return valueType->getTypeSummary();
+    }
+
+};
+
 //==========================================================================
 class ast_sent: public ast_node
 {
@@ -1209,6 +1303,7 @@ enum GMEXPR_CLASS
     GMEXPR_BUILTIN_FIELD, //builtin ops on property entries
     GMEXPR_TER,      // ternary operation
     GMEXPR_FOREIGN,
+    GMEXPR_MAPACCESS,
 // foreign expression
 };
 
@@ -1379,7 +1474,6 @@ protected:
                     GMTYPE_UNKNOWN), bound_graph_sym(NULL) {
     }
 
-protected:
     GMEXPR_CLASS expr_class;  // GMEXPR_...
     ast_expr* left;
     ast_expr* right;
@@ -1402,62 +1496,85 @@ public:
     bool is_foreign() {
         return expr_class == GMEXPR_FOREIGN;
     }
 
+    virtual bool is_mapaccess() {
+        return false;
+    }
+
     //-----------------------------------------------
     // type is set after type-checker execution
     //-----------------------------------------------
     int get_type_summary() {
         return type_of_expression;
     }
+
     void set_type_summary(int t) {
         type_of_expression = t;
     } // set by type checker
 
     gm_symtab_entry* get_bound_graph() {
+        if (bound_graph_sym == NULL && is_id())
+            return id1->getTypeInfo()->get_target_graph_sym();
+        else
         return bound_graph_sym;
     }
+
     void set_bound_graph(gm_symtab_entry*e) {
         bound_graph_sym = e;
     }
@@ -1477,7 +1594,8 @@ public:
     bool is_plus_inf() {
         return is_inf() && plus_inf;
     } // true o
-    ast_id* get_id() {
+
+    virtual ast_id* get_id() {
         return id1;
     }
 
@@ -1485,11 +1603,11 @@ public:
         return field;
     }
 
-    GMEXPR_CLASS get_opclass() {
+    virtual GMEXPR_CLASS get_opclass() {
         return expr_class;
     }
 
-    int get_optype() {
+    virtual int get_optype() {
         return op_type;
     }
 
@@ -1580,6 +1698,129 @@ protected:
     gm_symtab_entry* bound_graph_sym; // used only during typecheck
 };
 
+class ast_mapaccess: public ast_node
+{
+private:
+    ast_id* mapId;
+    ast_expr* keyExpr;
+
+    gm_symtab_entry* keyGraph;
+    gm_symtab_entry* valueGraph;
+
+    ast_mapaccess() :
+            ast_node(AST_MAPACCESS), mapId(NULL), keyExpr(NULL), keyGraph(NULL), valueGraph(NULL) {
+    }
+
+    ast_mapaccess(ast_id* map, ast_expr* key) :
+            ast_node(AST_MAPACCESS), mapId(map), keyExpr(key), keyGraph(NULL), valueGraph(NULL) {
+    }
+
+public:
+    ~ast_mapaccess() {
+        delete mapId;
+        delete keyExpr;
+    }
+
+    virtual void dump_tree(int i);
+    virtual void reproduce(int i);
+
+    ast_mapaccess* copy(bool cp_sym = false) {
+        ast_mapaccess* clone = new ast_mapaccess();
+        clone->mapId = mapId->copy(cp_sym);
+        clone->keyExpr = keyExpr->copy(cp_sym);
+        return clone;
+    }
+
+    ast_id* get_map_id() {
+        assert(mapId != NULL);
+        return mapId;
+    }
+
+    ast_expr* get_key_expr() {
+        assert(keyExpr != NULL);
+        return keyExpr;
+    }
+
+    gm_symtab_entry* get_bound_graph_for_key() {
+        return keyGraph;
+    }
+
+    void set_bound_graph_for_key(gm_symtab_entry* graphEntry) {
+        keyGraph = graphEntry;
+    }
+
+    gm_symtab_entry* get_bound_graph_for_value() {
+        return valueGraph;
+    }
+
+    void set_bound_graph_for_value(gm_symtab_entry* graphEntry) {
+        valueGraph = graphEntry;
+    }
+
+    static ast_mapaccess* new_mapaccess(ast_id* map, ast_expr* key) {
+        ast_mapaccess* newMapAccess = new ast_mapaccess(map, key);
+        assert(newMapAccess->keyExpr != NULL);
+        return newMapAccess;
+    }
+
+};
+
+class ast_expr_mapaccess: public ast_expr
+{
+private:
+    ast_mapaccess* mapAccess;
+
+    ast_expr_mapaccess() :
+            ast_expr(), mapAccess(NULL) {
+        set_nodetype(AST_EXPR_MAPACCESS);
+    }
+
+    ast_expr_mapaccess(ast_mapaccess* mapAccess, int line, int column) :
+            ast_expr(), mapAccess(mapAccess) {
+        set_nodetype(AST_EXPR_MAPACCESS);
+        set_line(line);
+        set_col(column);
+    }
+
+public:
+    ~ast_expr_mapaccess() {
+        delete mapAccess;
+    }
+
+    ast_expr_mapaccess* copy(bool cp_sym = false) {
+        ast_expr_mapaccess* clone = new ast_expr_mapaccess();
+        clone->mapAccess = mapAccess->copy(cp_sym);
+        return clone;
+    }
+
+    bool is_mapaccess() {
+        return true;
+    }
+
+    int get_optype() {
+        return (int) GMEXPR_MAPACCESS;
+    }
+
+    GMEXPR_CLASS get_opclass() {
+        return GMEXPR_MAPACCESS;
+    }
+
+    ast_id* get_id() {
+        return mapAccess->get_map_id();
+    }
+
+    ast_mapaccess* get_mapaccess() {
+        assert(mapAccess != NULL);
+        return mapAccess;
+    }
+
+    static ast_expr_mapaccess* new_expr_mapaccess(ast_mapaccess* mapAccess, int line, int column) {
+        ast_expr_mapaccess* newMapAccess = new ast_expr_mapaccess(mapAccess, line, column);
+        return newMapAccess;
+    }
+
+};
+
 class ast_expr_foreign: public ast_expr
 {
 public:
@@ -1813,43 +2055,55 @@ public:
         return true;
     }
 
+    // [xxx] should it be getIterator()->getTypeSummary()?
     int get_iter_type() {
         return iter_type;
     }
+
     void set_iter_type(int i) {
         iter_type = i;
     }
@@ -1874,11 +2129,14 @@ enum gm_assignment_t
 {
     GMASSIGN_NORMAL, GMASSIGN_REDUCE, GMASSIGN_DEFER, GMASSIGN_INVALID
 };
+
 enum gm_assignment_location_t
 {
-    GMASSIGN_LHS_SCALA, GMASSIGN_LHS_FIELD, GMASSIGN_LHS_END
+    GMASSIGN_LHS_SCALA, GMASSIGN_LHS_FIELD, GMASSIGN_LHS_MAP, GMASSIGN_LHS_END
 };
 
+class ast_assign_mapentry;
+
 class ast_assign: public ast_sent
 {
 public:
@@ -1930,15 +2189,19 @@ public:
     int get_assign_type() {
         return assign_type;
     }
-    int get_lhs_type() {
+
+    virtual int get_lhs_type() {
         return lhs_type;
     }
@@ -1946,28 +2209,40 @@ public:
     bool is_reduce_assign() {
         return assign_type == GMASSIGN_REDUCE;
     }
+
     bool is_defer_assign() {
         return assign_type == GMASSIGN_DEFER;
     }
-    bool is_target_scalar() {
+
+    virtual bool is_target_scalar() {
         return get_lhs_type() == GMASSIGN_LHS_SCALA;
     }
+
+    virtual bool is_target_map_entry() {
+        return false;
+    }
+
     void set_rhs(ast_expr* r) {
         rhs = r;
         rhs->set_parent(this);
@@ -2005,24 +2280,105 @@ public:
         if (new_id != NULL) lhs_type = GMASSIGN_LHS_FIELD;
     }
 
-private:
+    virtual bool is_map_entry_assign() {
+        return false;
+    }
+
+    virtual ast_assign_mapentry* to_assign_mapentry() {
+        assert(false);
+        return NULL;
+    }
+
+    void set_is_reference(bool is_ref) {
+        isReference = is_ref;
+    }
+
+    bool is_reference() {
+        return isReference;
+    }
+
+protected:
     ast_assign() :
-            ast_sent(AST_ASSIGN), lhs_scala(NULL), lhs_field(NULL), rhs(NULL), bound(NULL), arg_minmax(false), lhs_type(0), assign_type(0), reduce_type(0) {
+            ast_sent(AST_ASSIGN), lhs_scala(NULL), lhs_field(NULL), rhs(NULL), bound(NULL), arg_minmax(false), lhs_type(0), assign_type(0), reduce_type(0), isReference(false) {
     }
 
+private:
     int assign_type; // normal, deferred, reduce
     int lhs_type; // scalar, field
     int reduce_type; // add, mult, min, max
     ast_id* lhs_scala;
     ast_field* lhs_field;
-    ast_expr* rhs;
+
     ast_id* bound;  // bounding iterator
 
     bool arg_minmax;
+    bool isReference;
 
     std::list<ast_node*> l_list;
     std::list<ast_expr*> r_list;
 
+protected:
+    ast_expr* rhs;
+
+};
+
+class ast_assign_mapentry : public ast_assign {
+private:
+    ast_mapaccess* lhs;
+
+    ast_assign_mapentry(ast_mapaccess* lhs, ast_expr* rhs) : ast_assign(), lhs(lhs) {
+        this->rhs = rhs;
+    }
+
+    ast_assign_mapentry(ast_mapaccess* lhs, ast_expr* rhs, int reduceType) : ast_assign(), lhs(lhs) {
+        this->rhs = rhs;
+        set_reduce_type(reduceType);
+        set_assign_type(GMASSIGN_REDUCE);
+    }
+
+public:
+    ~ast_assign_mapentry() {
+        delete lhs;
+    }
+
+    virtual void reproduce(int indLevel);
+
+    void traverse_sent(gm_apply*a, bool is_post, bool is_pre);
+
+    bool is_map_entry_assign() {
+        return true;
+    }
+
+    bool is_target_map_entry() {
+        return true;
+    }
+
+    bool is_target_scalar() {
+        return false;
+    }
+
+    virtual int get_lhs_type() {
+        return GMASSIGN_LHS_MAP;
+    }
+
+    ast_assign_mapentry* to_assign_mapentry() {
+        return this;
+    }
+
+    ast_mapaccess* get_lhs_mapaccess() {
+        return lhs;
+    }
+
+    static ast_assign_mapentry* new_mapentry_assign(ast_mapaccess* lhs, ast_expr* rhs) {
+        ast_assign_mapentry* newAssign = new ast_assign_mapentry(lhs, rhs);
+        return newAssign;
+    }
+
+    static ast_assign_mapentry* new_mapentry_reduce_assign(ast_mapaccess* lhs, ast_expr* rhs, int reduceType) {
+        ast_assign_mapentry* newAssign = new ast_assign_mapentry(lhs, rhs, reduceType);
+        return newAssign;
+    }
+
 };
 
 class ast_vardecl: public ast_sent
@@ -2376,9 +2732,11 @@ public:
         b_filter = e;
     }
     void set_fbody(ast_sentblock* b) {
+        if (b != NULL) b->set_parent(this);
         f_body = b;
     }
     void set_bbody(ast_sentblock* b) {
+        if (b != NULL) b->set_parent(this);
         b_body = b;
     }
     virtual void reproduce(int id_level);
@@ -2506,9 +2864,11 @@ public:
         return cond;
     }
     void set_then(ast_sent* s) {
+        if (s!=NULL) s->set_parent(this);
         then_part = s;
     }
     void set_else(ast_sent* s) {
+        if (s!=NULL) s->set_parent(this);
         else_part = s;
     }
     void set_cond(ast_expr* c) {
diff --git a/src/inc/gm_backend_cpp.h b/src/inc/gm_backend_cpp.h
index 59eae0c..ea28fd3 100644
--- a/src/inc/gm_backend_cpp.h
+++ b/src/inc/gm_backend_cpp.h
@@ -7,6 +7,7 @@
 #include "gm_compile_step.h"
 #include "gm_backend_cpp_opt_steps.h"
 #include "gm_backend_cpp_gen_steps.h"
+#include "../backend_cpp/gm_cpplib_words.h"
 
 #include <list>
 
@@ -44,9 +45,8 @@ public:
     virtual void generate_sent_nop(ast_nop* n);
     virtual void generate_expr_builtin(ast_expr_builtin* e, gm_code_writer& Body);
     virtual void generate_expr_nil(ast_expr* e, gm_code_writer& Body);
-
     virtual bool add_collection_def(ast_id* set);
-
+    virtual void add_map_def(ast_maptypedecl* map, ast_id* mapId);
     virtual void build_up_language_voca(gm_vocabulary& V);
 
     virtual bool need_up_initializer(ast_foreach* fe);
@@ -56,15 +56,63 @@ public:
     virtual void generate_foreach_header(ast_foreach* fe, gm_code_writer& Body);
 
 private:
+    //map sizes
+    static const int SMALL = 0;
+    static const int MEDIUM = 1;
+    static const int LARGE = 2;
+
+    char str_buf[1024 * 8];
+    gm_cpp_gen* main;
+
     virtual void generate_expr_builtin_field(ast_expr_builtin_field* builtinExpr, gm_code_writer& body);
     const char* get_function_name_graph(int methodId);
     const char* get_function_name_nset(int methodId, bool in_parallel = false);
     const char* get_function_name_nseq(int methodId);
     const char* get_function_name_norder(int methodId);
+    const char* get_function_name_map(int methodId, bool in_parallel = false);
+    const char* get_function_name_map_seq(int methodId);
+    const char* get_function_name_map_par(int methodId);
     void add_arguments_and_thread(gm_code_writer& body, ast_expr_builtin* builtinExpr, bool addThreadId);
+    const char* getMapDefaultValueForType(int type);
+    const char* getMapTypeString(int mapType);
+    const char* getAdditionalMapParameters(int mapType);
+
+    static const char* get_primitive_type_string(int type_id) {
+        switch (type_id) {
+            case GMTYPE_BYTE:
+                return "int8_t";
+            case GMTYPE_SHORT:
+                return "int16_t";
+            case GMTYPE_INT:
+                return "int32_t";
+            case GMTYPE_LONG:
+                return "int64_t";
+            case GMTYPE_FLOAT:
+                return "float";
+            case GMTYPE_DOUBLE:
+                return "double";
+            case GMTYPE_BOOL:
+                return "bool";
+            default:
+                assert(false);
+                return "??";
+        }
+    }
+
+    static const char* getTypeString(int type) {
+        if (gm_is_prim_type(type)) {
+            return get_primitive_type_string(type);
+        } else if (gm_is_node_type(type)) {
+            return NODE_T;
+        } else if (gm_is_edge_type(type)) {
+            return EDGE_T;
+        } else {
+            assert(false);
+        }
+        return NULL;
+    }
+
 
-    char str_buf[1024 * 8];
-    gm_cpp_gen* main;
 };
 
 //-----------------------------------------------------------------
@@ -183,6 +231,7 @@ public:
     virtual void generate_sent_return(ast_return *r);
     virtual void generate_sent_call(ast_call* c);
     virtual void generate_sent_assign(ast_assign* a);
+    virtual const char* get_function_name_map_reduce_assign(int reduceType);
 
     virtual void generate_sent_block_enter(ast_sentblock *b);
     virtual void generate_sent_block_exit(ast_sentblock* b);
@@ -218,6 +267,7 @@ private:
     const char* get_function_name(int methodId, bool& addThreadId);
     void generate_idlist_primitive(ast_idlist* idList);
     void generate_lhs_default(int type);
+    void generate_sent_map_assign(ast_assign_mapentry* a);
 };
 
 extern gm_cpp_gen CPP_BE;
diff --git a/src/inc/gm_backend_cpp_opt_steps.h b/src/inc/gm_backend_cpp_opt_steps.h
index 1f2b856..1e2d515 100644
--- a/src/inc/gm_backend_cpp_opt_steps.h
+++ b/src/inc/gm_backend_cpp_opt_steps.h
@@ -11,6 +11,7 @@
 GM_COMPILE_STEP(gm_cpp_opt_check_feasible, "Check compiler feasiblity")
 GM_COMPILE_STEP(gm_cpp_opt_defer, "Handle deferred writes")
 GM_COMPILE_STEP(gm_cpp_opt_sanitize_name, "Sanitize identifier")
+GM_COMPILE_STEP(gm_cpp_opt_common_nbr, "Common Neigbhor Iteration")
 GM_COMPILE_STEP(gm_cpp_opt_select_par, "Select parallel regions")
 GM_COMPILE_STEP(gm_cpp_opt_save_bfs, "Finding BFS Children")
 //GM_COMPILE_STEP(gm_cpp_opt_reduce_bound, "Optimize reductions with sequential bound ")
diff --git a/src/inc/gm_backend_giraph.h b/src/inc/gm_backend_giraph.h
index f7c85e2..270c3d3 100644
--- a/src/inc/gm_backend_giraph.h
+++ b/src/inc/gm_backend_giraph.h
@@ -41,7 +41,8 @@ public:
     virtual void generate_broadcast_reduce_initialize_master(ast_id* id, gm_code_writer& Body, int reduce_type, const char* base_value);
     virtual void generate_broadcast_state_master(const char* state_var, gm_code_writer& Body);
     virtual void generate_broadcast_isFirst_master(const char* var, gm_code_writer& Body);
-    virtual void generate_broadcast_variable_type(int gm_type_id, gm_code_writer& Body, int reduce_op = GMREDUCE_NULL);
+    virtual void generate_broadcast_aggregator_type(int gm_type_id, gm_code_writer& Body, int reduce_op = GMREDUCE_NULL);
+    virtual void generate_broadcast_writable_type(int gm_type_id, gm_code_writer& Body);
     virtual void generate_broadcast_send_master(ast_id* id, gm_code_writer& Body);
     virtual void generate_broadcast_receive_master(ast_id* id, gm_code_writer& Body, int reduce_op = GMREDUCE_NULL);
     virtual void generate_headers(gm_code_writer& Body);
@@ -129,10 +137,11 @@ protected:
     void do_generate_scalar_broadcast_receive(gm_gps_basic_block *b);
     void do_generate_shared_variables_keys();
 
-    void do_generate_vertex();
+    void do_generate_vertex_begin();
+    void do_generate_vertex_body();
+    void do_generate_vertex_end();
     void do_generate_worker_context_class();
     void do_generate_vertex_property_class(bool is_edge_prop);
-    void do_generate_vertex_class();
     void do_generate_message_class();
     void do_generate_vertex_states();
     void do_generate_vertex_state_body(gm_gps_basic_block *b);
diff --git a/src/inc/gm_backend_gps.h b/src/inc/gm_backend_gps.h
index 1a2ad72..52a0e28 100644
--- a/src/inc/gm_backend_gps.h
+++ b/src/inc/gm_backend_gps.h
@@ -131,6 +131,8 @@ DEF_STRING(GPS_TAG_COMM_ID);
 // is pararell
 class gm_gps_gen : public gm_backend, public gm_code_generator
 {
+	friend class gm_giraph_gen;
+
 public:
     gm_gps_gen() :
             gm_code_generator(Body), dname(NULL), fname(NULL), f_body(NULL) {
diff --git a/src/inc/gm_backend_gps_opt_steps.h b/src/inc/gm_backend_gps_opt_steps.h
index 8370e31..e7866cf 100644
--- a/src/inc/gm_backend_gps_opt_steps.h
+++ b/src/inc/gm_backend_gps_opt_steps.h
@@ -9,6 +9,7 @@
 // declaration of optimization steps
 //-------------------------------------------
 GM_COMPILE_STEP(gm_gps_opt_transform_bfs, "Transform BFS into while and foreach")
+GM_COMPILE_STEP(gm_gps_opt_edge_iteration, "Transform Edge Iteration")
 GM_COMPILE_STEP(gm_gps_opt_simplify_expr1, "Seperating builtin-calls from outer-loop driver")
 //GM_COMPILE_STEP(gm_gps_opt_find_nested_loops_test, "test find nested loops")
 GM_COMPILE_STEP(gm_gps_opt_find_nested_loops_test, "test find nested loops")
diff --git a/src/inc/gm_builtin.h b/src/inc/gm_builtin.h
index cb11df8..5bf5f84 100644
--- a/src/inc/gm_builtin.h
+++ b/src/inc/gm_builtin.h
@@ -61,6 +61,16 @@ enum gm_method_id_t
     GM_BLTIN_SET_SUBSET,
     GM_BLTIN_SET_SIZE,
 
+    GM_BLTIN_MAP_SIZE,          // returns the number of mappings in the map
+    GM_BLTIN_MAP_HAS_MAX_VALUE, // checks if the key is mapped to the biggest value
+    GM_BLTIN_MAP_HAS_MIN_VALUE, // checks if the key is mapped to the smallest value
+    GM_BLTIN_MAP_HAS_KEY,       // checks if there is a mapping for the key in the map
+    GM_BLTIN_MAP_GET_MAX_KEY,   // returns the key that is mapped to the biggest value
+    GM_BLTIN_MAP_GET_MIN_KEY,   // returns the key that is mapped to the smallest value
+    GM_BLTIN_MAP_GET_MAX_VALUE, // returns the biggest value in the map
+    GM_BLTIN_MAP_GET_MIN_VALUE, // returns the smallest value in the map
+    GM_BLTIN_MAP_CLEAR,         // clears the whole map
+
     GM_BLTIN_END
 };
 
@@ -123,6 +139,18 @@ const gm_builtin_desc_t GM_builtins[] = {
         { "_:Log:Double:1:Double", GM_BLTIN_TOP_LOG, "" },  // returns log(d)  // base-e
         { "_:Exp:Double:1:Double", GM_BLTIN_TOP_EXP, "" },  // returns e^d
         { "_:Pow:Double:2:Double:Double", GM_BLTIN_TOP_POW, "" },  // returns a^b
+
+        // Map
+        { "Map:Size:Int:0",                 GM_BLTIN_MAP_SIZE,          "" },
+        { "Map:Clear:Void:0",               GM_BLTIN_MAP_CLEAR,         "" },
+        { "Map:HasKey:Bool:1:Generic",      GM_BLTIN_MAP_HAS_KEY,       "" },
+        { "Map:HasMaxValue:Bool:1:Generic", GM_BLTIN_MAP_HAS_MAX_VALUE, "" },
+        { "Map:HasMinValue:Bool:1:Generic", GM_BLTIN_MAP_HAS_MIN_VALUE, "" },
+        { "Map:GetMaxKey:Generic:0:",       GM_BLTIN_MAP_GET_MAX_KEY,   "" },
+        { "Map:GetMinKey:Generic:0:",       GM_BLTIN_MAP_GET_MIN_KEY,   "" },
+        { "Map:GetMaxValue:Generic:0:",     GM_BLTIN_MAP_GET_MAX_VALUE, "" },
+        { "Map:GetMinValue:Generic:0:",     GM_BLTIN_MAP_GET_MIN_VALUE, "" },
+
         };
 
 class gm_builtin_def
@@ -140,16 +168,33 @@ public:
     int get_arg_type(int i) {
         assert(i<num_args);
         return arg_types[i];
     }
+
+    bool genericArgumentTypeIsKeyType(int position) {
+        assert(position == 0); //we only support maps yet
+        switch(method_id) {
+            case GM_BLTIN_MAP_HAS_MAX_VALUE:
+            case GM_BLTIN_MAP_HAS_MIN_VALUE:
+            case GM_BLTIN_MAP_HAS_KEY:
+                return true;
+            default:
+                assert(false); //if you called it with the wrong method_id, then your code must be wrong...
+                return false;
+        }
+    }
+
     int get_method_id() {
         return method_id;
     }
+
     const char* get_orgname() {
         return orgname;
     }
@@ -157,10 +202,25 @@ public:
     bool is_synonym_def() {
         return synonym;
     }
+
     gm_builtin_def* get_org_def() {
         return org_def;
     }
 
+    bool genericTypeIsKeyType() {
+        switch(method_id) {
+            case GM_BLTIN_MAP_GET_MAX_KEY:
+            case GM_BLTIN_MAP_GET_MIN_KEY:
+                return true;
+            case GM_BLTIN_MAP_GET_MAX_VALUE:
+            case GM_BLTIN_MAP_GET_MIN_VALUE:
+                return false;
+            default:
+                assert(false); //if you called it with the wrong method_id, then your code must be wrong...
+                return false;
+        }
+    }
+
     void add_info_int(const char* key, int v);
     void add_info_bool(const char* key, bool b);
     bool has_info(const char* key);
diff --git a/src/inc/gm_code_writer.h b/src/inc/gm_code_writer.h
index 5e47b52..6c31543 100644
--- a/src/inc/gm_code_writer.h
+++ b/src/inc/gm_code_writer.h
@@ -237,6 +237,8 @@ public:
         return gm_need_paranthesis(optype, up_optype, is_right);
     }
 
+    virtual void generate_mapaccess(ast_expr_mapaccess* e);
+
     virtual void generate_lhs_id(ast_id* i) =0;
     virtual void generate_lhs_field(ast_field* i) =0;
     virtual void generate_sent_nop(ast_nop* n) =0;
diff --git a/src/inc/gm_defs.h b/src/inc/gm_defs.h
index f4a6aa4..e58f727 100644
--- a/src/inc/gm_defs.h
+++ b/src/inc/gm_defs.h
@@ -18,7 +18,8 @@ enum GMTYPE_T
     GMTYPE_ESET,
     GMTYPE_ESEQ,
     GMTYPE_EORDER,
-    GMTYPE_QUEUE,
+    GMTYPE_COLLECTION,
+    GMTYPE_MAP,
 
     // iterators
     GMTYPE_NODEITER_ALL = 100,
@@ -33,6 +34,10 @@ enum GMTYPE_T
 
     GMTYPE_NODEITER_COMMON_NBRS,    // common neighbors
 
+    GMTYPE_COLLECTIONITER_SET,          // iterator over collection of collection
+    GMTYPE_COLLECTIONITER_ORDER,
+    GMTYPE_COLLECTIONITER_SEQ,
+
     GMTYPE_EDGEITER_ALL = 200,
     GMTYPE_EDGEITER_NBRS,
     GMTYPE_EDGEITER_IN_NBRS,
@@ -68,7 +73,9 @@ enum GMTYPE_T
     GMTYPE_UNKNOWN = 9999,  // expression whose type is not identified yet (variable before typechecking)
     GMTYPE_UNKNOWN_NUMERIC, // expression whose type should be numeric, size not determined yet
     GMTYPE_ITER_ANY,        // iterator to some collection. resolved after type checking
+    GMTYPE_ITER_UNDERSPECIFIED,
     GMTYPE_VOID,
+    GMTYPE_GENERIC,
     GMTYPE_INVALID = 99999,
 };
 
@@ -159,8 +166,25 @@ inline static bool gm_is_unknown_collection_iter_type(int i) {
     return (i == GMTYPE_ITER_ANY);
 }
 
+inline static bool gm_is_collection_of_set_iter_type(int i) {
+    return i == GMTYPE_COLLECTIONITER_SET;
+}
+
+inline static bool gm_is_collection_of_seq_iter_type(int i) {
+    return i == GMTYPE_COLLECTIONITER_SEQ;
+}
+
+inline static bool gm_is_collection_of_order_iter_type(int i) {
+    return i == GMTYPE_COLLECTIONITER_ORDER;
+}
+
+inline static bool gm_is_collection_of_collection_iter_type(int i) {
+    return gm_is_collection_of_set_iter_type(i) || gm_is_collection_of_order_iter_type(i) || gm_is_collection_of_seq_iter_type(i);
+}
+
 inline static bool gm_is_collection_iter_type(int i) {
-    return gm_is_node_collection_iter_type(i) || gm_is_edge_collection_iter_type(i) || gm_is_unknown_collection_iter_type(i);
+    return gm_is_node_collection_iter_type(i) || gm_is_edge_collection_iter_type(i) || gm_is_unknown_collection_iter_type(i)
+            || gm_is_collection_of_collection_iter_type(i);
 }
 
 inline static bool gm_is_property_iter_set_type(int i) {
@@ -278,18 +302,22 @@ inline static bool gm_is_sequence_collection_type(int i) {
     return gm_is_node_sequence_type(i) || gm_is_edge_sequence_type(i);
 }
 
-inline static bool gm_is_collection_type(int i) {
-    return gm_is_node_collection_type(i) || gm_is_edge_collection_type(i);
+inline static bool gm_is_collection_of_collection_type(int type) {
+    return type == GMTYPE_COLLECTION;
 }
 
-inline static bool gm_is_queue_type(int type) {
-    return type == GMTYPE_QUEUE;
+inline static bool gm_is_collection_type(int i) {
+    return gm_is_node_collection_type(i) || gm_is_edge_collection_type(i) || gm_is_collection_of_collection_type(i);
 }
 
 inline static bool gm_is_sequential_collection_type(int i) {
     return gm_is_sequence_collection_type(i) || gm_is_order_collection_type(i);
 }
 
+inline static bool gm_is_map_type(int i) {
+    return i == GMTYPE_MAP;
+}
+
 // node set -> nodeset iter
 // edge set -> edgeset iter ...
 inline int gm_get_natural_collection_iterator(int src_type) {
@@ -305,16 +333,35 @@ inline int gm_get_natural_collection_iterator(int src_type) {
         return GMTYPE_NODEITER_SEQ;
     else if (src_type == GMTYPE_EORDER)
         return GMTYPE_NODEITER_ORDER;
+    else if (src_type == GMTYPE_COLLECTION)
+        return GMTYPE_ITER_UNDERSPECIFIED; //handle that later
     else {
         assert(false);
-        return 0;
+        return GMTYPE_INVALID;
+    }
+}
+
+inline int gm_get_specified_collection_iterator(int type) {
+    switch (type) {
+        case GMTYPE_NSET:
+        case GMTYPE_ESET:
+            return GMTYPE_COLLECTIONITER_SET;
+        case GMTYPE_NSEQ:
+        case GMTYPE_ESEQ:
+            return GMTYPE_COLLECTIONITER_SEQ;
+        case GMTYPE_NORDER:
+        case GMTYPE_EORDER:
+            return GMTYPE_COLLECTIONITER_ORDER;
+        default:
+            assert(false);
+            return GMTYPE_INVALID;
     }
 }
 
 // return true if this type has a target graph
 inline bool gm_has_target_graph_type(int t) {
     return gm_is_node_edge_compatible_type(t) || // any node-edge iterator (including collection iterator)
-            gm_is_collection_type(t) || gm_is_queue_type(t);
+            gm_is_collection_type(t) || gm_is_collection_of_collection_type(t);
 }
 
 inline static bool gm_is_same_type(int i1, int i2) {
@@ -326,7 +373,7 @@ inline static bool gm_is_same_node_or_edge_compatible_type(int i1, int i2) {
 }
 
 inline static bool gm_collection_of_collection_compatible_type(int def_src, int source_type) {
-    return gm_is_order_collection_type(def_src) && gm_is_queue_type(source_type);
+    return gm_is_order_collection_type(def_src) && gm_is_collection_of_collection_type(source_type);
 }
 
 enum GM_OPS_T
@@ -398,7 +450,12 @@ inline bool gm_is_compatible_type_for_assign(int t_lhs, int t_rhs, int& t_new_rh
 
 enum GM_REDUCE_T
 {
-    GMREDUCE_INVALID = 0, GMREDUCE_PLUS = 1, GMREDUCE_MULT, GMREDUCE_MIN, GMREDUCE_MAX, GMREDUCE_AND,     // logical AND
+    GMREDUCE_INVALID = 0,
+    GMREDUCE_PLUS = 1,
+    GMREDUCE_MULT,
+    GMREDUCE_MIN,
+    GMREDUCE_MAX,
+    GMREDUCE_AND,     // logical AND
     GMREDUCE_OR,      // logical OR
     GMREDUCE_AVG,     // average (syntactic sugar)
     GMREDUCE_DEFER,  // deferred assignment is not a reduce op. but shares a lot of properies
@@ -429,46 +488,67 @@ inline static bool gm_is_iteration_on_property(int iterType) {
 inline static bool gm_is_iteration_on_neighbors_compatible(int itype) {
     return gm_is_any_nbr_node_iter_type(itype);
 }
 
+inline static bool gm_can_be_key_type(GMTYPE_T type) {
+    return gm_is_prim_type(type) || gm_is_nodeedge_type(type);
+}
+
+inline static bool gm_can_be_value_type(GMTYPE_T type) {
+    return gm_is_prim_type(type) || gm_is_nodeedge_type(type);
+}
+
 enum GM_ACCESS_T
 {   // 16 bit bitmap
     GMACCESS_NONE = 0x0000,
diff --git a/src/inc/gm_error.h b/src/inc/gm_error.h
index a2af967..8324af1 100644
--- a/src/inc/gm_error.h
+++ b/src/inc/gm_error.h
@@ -18,6 +18,7 @@ enum GM_ERRORS_AND_WARNINGS
     GM_ERROR_OPERATOR_MISMATCH,
     GM_ERROR_OPERATOR_MISMATCH2,
     GM_ERROR_COMPARE_MISMATCH,
+    GM_ERROR_KEY_MISSMATCH,
     GM_ERROR_READONLY,
     GM_ERROR_TARGET_MISMATCH,
     GM_ERROR_TARGET_MISMATCH2, // expr
diff --git a/src/inc/gm_frontend_api.h b/src/inc/gm_frontend_api.h
index 492c318..752f43a 100644
--- a/src/inc/gm_frontend_api.h
+++ b/src/inc/gm_frontend_api.h
@@ -63,6 +63,7 @@ extern ast_node* GM_expr_reduceop(int op, ast_node* iter, ast_node* src, int ite
 extern ast_node* GM_expr_ternary(ast_node* cond, ast_node* left, ast_node* right, int l, int c);
 extern ast_node* GM_expr_builtin_expr(ast_node* id, ast_node* id2, expr_list* l);
 extern ast_node* GM_expr_builtin_field_expr(ast_node* id, ast_node* id2, expr_list* list);
+extern ast_node* GM_expr_map_access(ast_node* mapAccess, int line, int column);
 
 extern void GM_start_sentblock();
 extern ast_node* GM_finish_sentblock();
@@ -94,9 +95,11 @@ extern ast_node* GM_edgetype_ref(ast_node* id);
 
 extern ast_node* GM_settype_ref(int set_type_id, ast_node* id);
 extern ast_node* GM_queuetype_ref(ast_node* collectionType, ast_node* id);
+extern ast_node* GM_maptype_ref(ast_node* keyType, ast_node* valueType);
 
 extern ast_node* GM_id(char* orgname, int line, int col);
 extern ast_node* GM_field(ast_node* id, ast_node* field, bool is_rarrow);
+extern ast_node* GM_map_access(ast_node* mapId, ast_node* keyExpr);
 
 extern void GM_add_id_comma_list(ast_node* id);
 extern ast_node* GM_finish_id_comma_list();
diff --git a/src/inc/gm_ind_opt_steps.h b/src/inc/gm_ind_opt_steps.h
index 7c1c75e..934a772 100644
--- a/src/inc/gm_ind_opt_steps.h
+++ b/src/inc/gm_ind_opt_steps.h
@@ -16,6 +16,8 @@ GM_COMPILE_STEP(gm_ind_opt_hoist_foreach, "Move foreach statements")
 GM_COMPILE_STEP(gm_ind_opt_flip_edges, "Flipping Edges in Nested Foeach")
 GM_COMPILE_STEP(gm_ind_opt_loop_merge, "Merge loops")
 GM_COMPILE_STEP(gm_ind_opt_nonconf_reduce, "Optimizing non-conflicting reductions")
+GM_COMPILE_STEP(gm_ind_opt_propagate_trivial_writes, "Propagate Trivial Writes")
+GM_COMPILE_STEP(gm_ind_opt_remove_unused_scalar, "Remove Unused Scalar")
 
 #endif
 
diff --git a/src/inc/gm_rw_analysis.h b/src/inc/gm_rw_analysis.h
index 5e05279..810392a 100644
--- a/src/inc/gm_rw_analysis.h
+++ b/src/inc/gm_rw_analysis.h
@@ -100,6 +100,10 @@ static int gm_get_range_from_itertype(int itype) {
         case GMTYPE_PROPERTYITER_SEQ:
         case GMTYPE_PROPERTYITER_ORDER:
             return GM_RANGE_LINEAR;
+        case GMTYPE_COLLECTIONITER_SET:
+        case GMTYPE_COLLECTIONITER_SEQ:
+        case GMTYPE_COLLECTIONITER_ORDER:
+            return GM_RANGE_RANDOM; //TODO is there somthing more suitable?
         default:
             printf("type = %d\n", itype);
             assert(false);
diff --git a/src/inc/gm_transform_helper.h b/src/inc/gm_transform_helper.h
index e359afd..357974b 100644
--- a/src/inc/gm_transform_helper.h
+++ b/src/inc/gm_transform_helper.h
@@ -48,6 +48,7 @@ extern void gm_add_sent_end(ast_sent* current, ast_sent* newone, bool fix_symtab
 //--------------------------------------------------------------------
 extern void gm_add_sent_before(ast_sent* current, ast_sent* newone, bool fix_symtab = true);
 extern void gm_add_sent_after(ast_sent* current, ast_sent* newone, bool fix_symtab = true);
+extern void gm_replace_sent(ast_sent* orgone, ast_sent* newone, bool fix_symtab = true);
 
 //--------------------------------------------------------------------
 // similar to add_sent_*. But explicitly give the sentence bock
@@ -57,6 +58,12 @@ extern void gm_insert_sent_end_of_sb(ast_sentblock* curr_sb, ast_sent* newone, b
 extern void gm_insert_sent_body_begin(ast_foreach* curr_sb, ast_sent* newone, bool fix_symtab = true);
 extern void gm_insert_sent_body_end(ast_foreach* curr_sb, ast_sent* newone, bool fix_sumtab = true);
 
+//--------------------------------------------------------------------
+// Remove(Rip-Off) sentence from a sentence block
+// (User should guarantee target does not use any symbol defined in from)
+//--------------------------------------------------------------------
+extern void gm_remove_sent_from_sb(ast_sent* target, ast_sentblock* from, bool fix_symtab = true);
+
 //------------------------------------------------------------
 // Scope management
 //------------------------------------------------------------
@@ -72,14 +79,25 @@ extern void gm_reconstruct_scope(ast_node* top);  // top should must have a scop
 // Symbol addition and creation
 //------------------------------------------------------------
 // Find an upscope where I can add some symbol defs
-ast_sentblock* gm_find_upscope(ast_sent* s);
+extern ast_sentblock* gm_find_upscope(ast_sent* s);
 // Add symbols into some scope
-gm_symtab_entry* gm_add_new_symbol_primtype(ast_sentblock* sb, int primtype, char* new_vname); // assumtpion: no name-conflict.
-gm_symtab_entry* gm_add_new_symbol_property(ast_sentblock* sb, int primtype, bool is_nodeprop, gm_symtab_entry* target_graph, char* new_vname); // assumtpion: no name-conflict.
-gm_symtab_entry* gm_add_new_symbol_nodeedge_type(ast_sentblock* sb, int nodeedge_type, gm_symtab_entry* target_graph, char* new_vname); // assumtpion: no name-conflict.
+extern gm_symtab_entry* gm_add_new_symbol_primtype(ast_sentblock* sb, int primtype, char* new_vname); // assumtpion: no name-conflict.
+extern gm_symtab_entry* gm_add_new_symbol_property(ast_sentblock* sb, int primtype, bool is_nodeprop, gm_symtab_entry* target_graph, char* new_vname); // assumtpion: no name-conflict.
+extern gm_symtab_entry* gm_add_new_symbol_nodeedge_type(ast_sentblock* sb, int nodeedge_type, gm_symtab_entry* target_graph, char* new_vname); // assumtpion: no name-conflict.
 
+//------------------------------------------------------------
+// Sentence block related
+//------------------------------------------------------------
 // returns sentblock that defines the given entry
-ast_sentblock* gm_find_defining_sentblock_up(ast_node* begin, gm_symtab_entry *e, bool is_property = false);
+extern ast_sentblock* gm_find_defining_sentblock_up(ast_node* begin, gm_symtab_entry *e, bool is_property = false);
+// Is the sentence block empty?   (nothing in there)
+extern bool gm_is_sentblock_empty(ast_sentblock* sb);
+// Is the sentence block trivial? (only one sentence, no definition)--  also returns the only sentence
+extern bool gm_is_sentblock_trivial(ast_sentblock* sb, ast_sent* &s);
+
+// get the trivivial sententce of s if s is a trivial sent-block. otherwise returns s itself
+extern ast_sent* gm_get_sentence_if_trivial_sentblock(ast_sent* s);
+
 
 //------------------------------------------------------------
 // Replace every symbol access
@@ -133,6 +151,7 @@ ast_expr* gm_new_bottom_symbol(int reduce_type, int lhs_type);
 // [the routine expects that there is only 1 instance of old_e inside target top expreesion]
 // note: symtab hierarchy is *not* re-validated by this routine
 // (thus be careful if new_e contains Sum/Product...)
+// (this method should be depricated; use replace_expr_general instead)
 extern bool gm_replace_subexpr(ast_expr* top, ast_expr* old_e, ast_expr* new_e);
 
 // implement following function 
@@ -159,6 +178,8 @@ extern bool gm_resolve_name_conflict(ast_sent *s, gm_symtab_entry *e, bool is_sc
 // [Assumption. e_new is a valid symbol entry that does not break scoping rule.]
 //---------------------------------------------------------------------------------------
 extern bool gm_replace_symbol_entry(gm_symtab_entry *e_old, gm_symtab_entry*e_new, ast_node* top);
+// replace symbol entry only for bounds 
+extern bool gm_replace_symbol_entry_bound(gm_symtab_entry *e_old, gm_symtab_entry *e_new, ast_node* top);
 
 //---------------------------------------------------------------
 // Merge subblock P,Q into P
diff --git a/src/opt/gm_flip_edges.cc b/src/opt/gm_flip_edges.cc
index 528032e..f470d25 100644
--- a/src/opt/gm_flip_edges.cc
+++ b/src/opt/gm_flip_edges.cc
@@ -216,13 +216,13 @@ static void do_flip_edges(std::list<ast_foreach*>& target) {
             ast_sent* body2 = if2->get_then();
 
             in->set_body(body2);
-            body2->set_parent(in);
+            //body2->set_parent(in);
 
             if2->set_then(body1);
-            body1->set_parent(if2);
+            //body1->set_parent(if2);
 
             out->set_body(if2);
-            if2->set_parent(out);
+            //if2->set_parent(out);
         }
 
         else if (if2 == NULL) {
@@ -230,21 +230,21 @@ static void do_flip_edges(std::list<ast_foreach*>& target) {
             ast_sent* body2 = in->get_body();
 
             in->set_body(if1);
-            if1->set_parent(in);
+            //if1->set_parent(in);
 
             if1->set_then(body2);
-            body2->set_parent(if1);
+            ///body2->set_parent(if1);
 
             out->set_body(in);
-            in->set_parent(out);
+            //in->set_parent(out);
         } else {
             // exchange conditions
             ast_expr* e1 = if1->get_cond();
             ast_expr* e2 = if2->get_cond();
             if1->set_cond(e2);
-            e2->set_parent(if1);
+            //e2->set_parent(if1);
             if2->set_cond(e1);
-            e1->set_parent(if2);
+            //e1->set_parent(if2);
         }
 
         if (dest->get_nodetype() == AST_ASSIGN) {
diff --git a/src/opt/gm_ind_opt.cc b/src/opt/gm_ind_opt.cc
index 4c4904b..6958b89 100644
--- a/src/opt/gm_ind_opt.cc
+++ b/src/opt/gm_ind_opt.cc
@@ -20,6 +20,8 @@ void gm_independent_optimize::init_steps() {
     LIST.push_back(GM_COMPILE_STEP_FACTORY(gm_ind_opt_flip_edges));
     LIST.push_back(GM_COMPILE_STEP_FACTORY(gm_ind_opt_loop_merge));
     LIST.push_back(GM_COMPILE_STEP_FACTORY(gm_ind_opt_nonconf_reduce));
+    LIST.push_back(GM_COMPILE_STEP_FACTORY(gm_ind_opt_propagate_trivial_writes));
+    LIST.push_back(GM_COMPILE_STEP_FACTORY(gm_ind_opt_remove_unused_scalar));
 }
 
 bool gm_independent_optimize::do_local_optimize() {
diff --git a/src/opt/gm_opt_nonconf_reduce.cc b/src/opt/gm_opt_nonconf_reduce.cc
index 1a71544..f9e8234 100644
--- a/src/opt/gm_opt_nonconf_reduce.cc
+++ b/src/opt/gm_opt_nonconf_reduce.cc
@@ -27,6 +27,9 @@ public:
         if (s->get_nodetype() == AST_ASSIGN) {
             ast_assign* a = (ast_assign*) s;
             if (a->is_reduce_assign()) {
+
+                if(a->is_target_map_entry()) return true;
+
                 assert(a->get_bound() != NULL);
                 gm_symtab_entry* bound = a->get_bound()->getSymInfo();
 
@@ -116,7 +119,7 @@ public:
         ast_assign* a = (ast_assign*) s;
         if (!a->is_reduce_assign())
             return true;
-        if (a->is_target_scalar()) 
+        if (a->is_target_scalar() || a->is_target_map_entry())
             return true;
 
         assert(a->get_bound() != NULL);
diff --git a/src/opt/gm_opt_propagate_trivial_writes.cc b/src/opt/gm_opt_propagate_trivial_writes.cc
new file mode 100644
index 0000000..faee4e3
--- /dev/null
+++ b/src/opt/gm_opt_propagate_trivial_writes.cc
@@ -0,0 +1,116 @@
+#include "gm_ind_opt.h"
+#include "gm_misc.h"
+#include "gm_traverse.h"
+#include "gm_transform_helper.h"
+#include "gm_rw_analysis.h"
+#include "gm_check_if_constant.h"
+
+//-------------------------------------------------------------------
+//e.g.
+//   { Int x = y;
+//     z = x + 3; }
+// ==>
+//   { z = y + 3; } // x optimized out
+//
+//  Rule
+//     (0) LHS is sclar, primitive or node/edge type
+//     (1) the variable is assigned only once
+//     (2) the rhs of assignment is trivial 
+//     (3) [temporary] if the type of rhs is node/edge compatiable type, they should be iterators
+//         (this is because for translation of random-write in GPS backend, you need explicit trivial writes)
+//-------------------------------------------------------------------
+//
+
+class gm_opt_propagate_trivial_write_t : public gm_apply {
+public:
+    gm_opt_propagate_trivial_write_t() {
+        set_for_sent(true);
+        set_for_lhs(true); 
+        _changed = false;
+    }
+    virtual bool apply_lhs(ast_id* i) {
+        gm_symtab_entry* z = i->getSymInfo(); 
+        assert(z!=NULL);
+        assign_cnt[z] ++;
+        return true;
+    }
+
+    virtual bool apply(ast_sent* s) {
+
+        if (s->get_nodetype() == AST_ASSIGN) {
+            ast_assign* a = (ast_assign*) s;
+            if (a->is_defer_assign() || a->is_reduce_assign()) 
+                return true;
+            if (!a->is_target_scalar()) 
+                return true;
+            ast_id* lhs = a->get_lhs_scala();
+            gm_symtab_entry* z = lhs->getSymInfo(); 
+            assert(z!=NULL);
+            if (!lhs->getTypeInfo()->is_primitive() && (!lhs->getTypeInfo()->is_node_edge_compatible()))
+               return true;
+
+            if (lhs->getSymInfo()->isArgument())
+                return true;
+
+            if (a->get_rhs()->is_id()) {
+                ast_id *id = a->get_rhs()->get_id();
+                assert(id->getSymInfo() != NULL);
+                ast_typedecl * t = id->getTypeInfo();
+                // temporary
+                if (t->is_primitive() || (t->is_node_edge_iterator())) {
+                    potential_assign[z] = a;
+                }
+            }
+        }
+        return true;
+    }
+
+    bool has_effect() {
+        return _changed;
+    }
+
+    void post_process() {
+        std::map<gm_symtab_entry* , ast_assign*>::iterator I;
+        for (I= potential_assign.begin(); I !=potential_assign.end(); I++)
+        {
+            gm_symtab_entry* lhs_sym = I->first;
+            ast_assign* a = I->second;
+            if (assign_cnt[lhs_sym] > 1) 
+                continue;
+
+            // now replace old symbol to rhs symbol
+            gm_symtab_entry* rhs_sym = I->second->get_rhs()->get_id()->getSymInfo();
+            ast_sentblock* sb = gm_find_defining_sentblock_up(a, lhs_sym);
+            assert(sb!=NULL);
+            gm_replace_symbol_entry(lhs_sym, rhs_sym, sb);
+
+            _changed = true;
+
+            // remove assignment
+            gm_ripoff_sent(a);
+            delete a;
+        }
+    }
+
+private:
+    std::map<gm_symtab_entry* , int> assign_cnt;
+    std::map<gm_symtab_entry* , ast_assign*> potential_assign;
+    bool _changed;
+
+};
+
+void gm_ind_opt_propagate_trivial_writes::process(ast_procdef* proc) {
+
+    bool changed;
+    do {
+        gm_opt_propagate_trivial_write_t T;
+        proc->traverse_pre(&T);
+        T.post_process();
+
+        changed = T.has_effect();
+
+    } while (changed);
+
+    // re-do rw_analysis
+    gm_redo_rw_analysis(proc->get_body());
+}
diff --git a/src/opt/gm_opt_remove_unused_scalar.cc b/src/opt/gm_opt_remove_unused_scalar.cc
new file mode 100644
index 0000000..87f2679
--- /dev/null
+++ b/src/opt/gm_opt_remove_unused_scalar.cc
@@ -0,0 +1,74 @@
+#include "gm_ind_opt.h"
+#include "gm_misc.h"
+#include "gm_traverse.h"
+#include "gm_transform_helper.h"
+#include "gm_rw_analysis.h"
+#include "gm_check_if_constant.h"
+
+//-------------------------------------------------------------------
+//  Remove unused scalar variables
+//  targets:
+//    type - primitive or node or edge
+//    is not iterator
+//    is not used at all
+//-------------------------------------------------------------------
+
+class gm_opt_check_used_t : public gm_apply {
+public:
+    gm_opt_check_used_t() {
+        set_for_id(true); 
+    }
+    virtual bool apply(ast_id* i) {
+        gm_symtab_entry* z = i->getSymInfo(); 
+        assert(z!=NULL);
+        used.insert(z);
+    }
+
+    std::set<gm_symtab_entry*> & get_used_set() {return used;}
+
+private:
+    std::set<gm_symtab_entry*> used;
+
+};
+
+class gm_opt_remove_unused_t : public gm_apply {
+public:
+    gm_opt_remove_unused_t(std::set<gm_symtab_entry*>& U) : used(U) {
+        set_for_symtab(true); 
+    }
+    virtual bool apply(gm_symtab* tab, int symtab_type) {
+        if (symtab_type != GM_SYMTAB_VAR) 
+            return true;
+
+        std::set<gm_symtab_entry*>::iterator I;
+        std::set<gm_symtab_entry*> to_remove;
+        std::set<gm_symtab_entry*> v = tab->get_entries();
+        for (I = v.begin(); I != v.end(); I++) {
+            gm_symtab_entry* z = *I;
+            if (!z->getType()->is_primitive() && !z->getType()->is_nodeedge()) 
+                continue;
+            if (used.find(z) == used.end()) {
+                to_remove.insert(z);
+            }
+        }
+        for (I = to_remove.begin(); I != to_remove.end(); I++) {
+            tab->remove_entry_in_the_tab(*I);
+        }
+
+        return true;
+    }
+
+private:
+    std::set<gm_symtab_entry*>& used;
+
+};
+
+
+void gm_ind_opt_remove_unused_scalar::process(ast_procdef* proc) {
+
+    gm_opt_check_used_t T;
+    proc->traverse_pre(&T);
+
+    gm_opt_remove_unused_t T2(T.get_used_set());
+    proc->traverse_pre(&T2);
+}
diff --git a/src/parse/gm_grammer.y b/src/parse/gm_grammer.y
index 52c38e2..4aace43 100644
--- a/src/parse/gm_grammer.y
+++ b/src/parse/gm_grammer.y
@@ -30,7 +30,8 @@
 
  /*  Reserved Words */
 %token T_PROC T_GRAPH T_NODE T_NODEPROP T_EDGE T_EDGEPROP T_LOCAL
-%token T_NSET T_NORDER T_NSEQ T_ITEMS T_QUEUE
+%token T_NSET T_NORDER T_NSEQ T_ITEMS T_COLLECTION
+%token T_MAP
 %token T_DFS T_POST 
 %token T_INT T_FLOAT T_BOOL T_DOUBLE  T_LONG
 %token T_RETURN
@@ -66,8 +67,8 @@
 %type <pair> bfs_reverse bfs_filters dfs_post
 %type <ival> from_or_semi
 %type <ptr> arg_decl typedecl property prim_type graph_type arg_target var_target
-%type <ptr> edge_type node_type nodeedge_type set_type optional_bind
-%type <ptr> scala field
+%type <ptr> edge_type node_type nodeedge_type set_type optional_bind key_type value_type map_type
+%type <ptr> scala field map_access
 %type <ptr> sent_argminmax_assignment
 %type <pair>  iterator1
 %type <ival> reduce_eq
@@ -134,6 +135,7 @@
             | property                 { $$ = $1;}
             | nodeedge_type            { $$ = $1;}
             | set_type                 { $$ = $1;}
+            | map_type				   { $$ = $1;}
 
 
   graph_type : T_GRAPH               { $$ = GM_graphtype_ref(GMTYPE_GRAPH); 
@@ -167,8 +169,16 @@
            |  T_NORDER '(' id ')'     { $$ = GM_settype_ref(GMTYPE_NORDER, $3);   GM_set_lineinfo($$,@1.first_line, @1.first_column);}
            |  T_NORDER                { $$ = GM_settype_ref(GMTYPE_NORDER, NULL); GM_set_lineinfo($$,@1.first_line, @1.first_column);}
            
-           |  T_QUEUE '<' set_type '>' '(' id ')'	  { $$ = GM_queuetype_ref($3, $6); 	  GM_set_lineinfo($$,@1.first_line, @1.first_column);}
-           |  T_QUEUE '<' set_type '>' 				  { $$ = GM_queuetype_ref($3, NULL);  GM_set_lineinfo($$,@1.first_line, @1.first_column);}
+           |  T_COLLECTION '<' set_type '>' '(' id ')'	  { $$ = GM_queuetype_ref($3, $6); 	  GM_set_lineinfo($$,@1.first_line, @1.first_column);}
+           |  T_COLLECTION '<' set_type '>'				  { $$ = GM_queuetype_ref($3, NULL);  GM_set_lineinfo($$,@1.first_line, @1.first_column);}
+           
+  key_type : nodeedge_type	{ $$ = $1; }
+  		   | prim_type		{ $$ = $1; }
+  		   
+  value_type : nodeedge_type { $$ = $1; }
+  			 | prim_type	 { $$ = $1; }
+           
+  map_type :  T_MAP '<' key_type ',' value_type '>' { $$ = GM_maptype_ref($3, $5); GM_set_lineinfo($$,@1.first_line, @1.first_column); }
            
 
   property : T_NODEPROP '<' prim_type '>'     '(' id ')'  { $$ = GM_nodeprop_ref($3, $6 ); GM_set_lineinfo($$,@1.first_line, @1.first_column);}
@@ -250,11 +260,11 @@
                   GM_set_lineinfo($$,@1.first_line, @1.first_column);} 
 
   dfs_post     :                               {$$.p1 = NULL; $$.p2 = NULL;}
-               | T_POST bfs_filter sent_block  {$$.p1 = $2;   $$.p2 = $3;  } 
+               | T_POST bfs_filter sent_block  {$$.p1 = $3;   $$.p2 = $2;  } 
                | T_POST sent_block             {$$.p1 = $2;   $$.p2 = NULL;  }
 
   bfs_reverse  :                               {$$.p1 = NULL; $$.p2 = NULL;}
-               | T_BACK bfs_filter sent_block  {$$.p1 = $2;   $$.p2 = $3;  } 
+               | T_BACK bfs_filter sent_block  {$$.p1 = $3;   $$.p2 = $2;  } 
                | T_BACK sent_block             {$$.p1 = $2;   $$.p2 = NULL;  }
 
   bfs_header_format :  '(' id ':' id opt_tp '.' T_NODES from_or_semi id ')' {
@@ -370,6 +380,7 @@ bfs_navigator :  '[' expr ']'              {$$ = $2;}
             | field                        {$$ = GM_expr_field_access($1);}
             | built_in                     {$$ = $1;}
             | expr_user                    {$$ = $1;}
+            | map_access				   { $$ = GM_expr_map_access($1, @1.first_line, @1.first_column); }
 
    /* cannot be distinguished by the syntax, until type is available. due to vars */
    bool_expr : expr                    {$$ = $1; }
@@ -391,6 +402,7 @@ bfs_navigator :  '[' expr ']'              {$$ = $2;}
 
   lhs : scala                             { $$ = $1; }
       | field                             { $$ = $1; }
+      | map_access						  { $$ = $1; }
 
   lhs_list : lhs                         { $$ = GM_single_lhs_list($1);}
            | lhs ',' lhs_list            { $$ = GM_add_lhs_list_front($1, $3);}
@@ -400,6 +412,8 @@ bfs_navigator :  '[' expr ']'              {$$ = $2;}
        /*| id T_RARROW id                  { $$ = GM_field($1, $3, true);  }*/
        | T_EDGE '('id ')' '.' id            { $$ = GM_field($3, $6, true);  }
 
+  map_access: id '[' expr ']'			{ $$ = GM_map_access($1, $3); }
+
   built_in : id '.' id arg_list            { $$ = GM_expr_builtin_expr($1, $3, $4);}
            | id arg_list                   { $$ = GM_expr_builtin_expr(NULL, $1, $2);}
            | field '.' id arg_list		   { $$ = GM_expr_builtin_field_expr($1, $3, $4);}
diff --git a/src/parse/gm_lex.l b/src/parse/gm_lex.l
index 9bbc7bc..b4ae80c 100644
--- a/src/parse/gm_lex.l
+++ b/src/parse/gm_lex.l
@@ -97,7 +97,8 @@ ALPHANUM    [a-zA-Z][a-zA-Z0-9_]*
 "Node_Seq"      {MarkToken(); return T_NSEQ;}
 "Node_Sequence" {MarkToken(); return T_NSEQ;}
 "N_Q"      {MarkToken(); return T_NSEQ;}
-"Queue"		{MarkToken(); return T_QUEUE;}
+"Collection"		{MarkToken(); return T_COLLECTION;}
+"Map"	{MarkToken(); return T_MAP;}
 "Int" {MarkToken(); return T_INT;}
 "Long" {MarkToken(); return T_LONG;}
 "Float" {MarkToken(); return T_FLOAT;}
