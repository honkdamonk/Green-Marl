<<<<<<< HEAD
diff --git a/src/frontend/gm_check_property_argument_usage.cc b/src/frontend/gm_check_property_argument_usage.cc
index 93316a5..d34b11a 100644
--- a/src/frontend/gm_check_property_argument_usage.cc
+++ b/src/frontend/gm_check_property_argument_usage.cc
@@ -39,7 +39,7 @@ public:
             condition_stack.push_back(s);
         } else if (s->get_nodetype() == AST_ASSIGN) {
             ast_assign* a = (ast_assign*) s;
-            if (!a->is_target_scalar()) {
+            if (!a->is_target_scalar() && !a->is_target_map_entry()) {
                 ast_field* f = a->get_lhs_field();
                 if (a->is_reduce_assign()) {  // this is read & write
                     property_is_read(f->get_second()->getSymInfo(), f->get_first()->getSymInfo(), true);
diff --git a/src/frontend/gm_expand_group_assignment.cc b/src/frontend/gm_expand_group_assignment.cc
index ab7a5d3..4c43992 100644
--- a/src/frontend/gm_expand_group_assignment.cc
+++ b/src/frontend/gm_expand_group_assignment.cc
@@ -53,7 +53,7 @@ public:
     virtual bool apply(ast_sent *s) {
         if (s->get_nodetype() != AST_ASSIGN) return true;
         ast_assign* a = (ast_assign*) s;
-        if (a->is_target_scalar()) return true;
+        if (a->is_target_scalar() || a->is_target_map_entry()) return true;
 
         ast_field* lhs = a->get_lhs_field();
         assert(lhs != NULL);
diff --git a/src/frontend/gm_new_typecheck_step1.cc b/src/frontend/gm_new_typecheck_step1.cc
index 5cd1548..a0c1924 100644
--- a/src/frontend/gm_new_typecheck_step1.cc
+++ b/src/frontend/gm_new_typecheck_step1.cc
@@ -133,6 +135,20 @@ private:
                 return -1;
         }
     }
+
+    void checkAndSetBoundGraphsForMap(ast_mapaccess* mapAccess) {
+        ast_maptypedecl* mapDecl = (ast_maptypedecl*) mapAccess->get_map_id()->getTypeInfo();
+        ast_typedecl* keyType = mapDecl->get_key_type();
+        ast_typedecl* valueType = mapDecl->get_value_type();
+        if (gm_has_target_graph_type(keyType->getTypeSummary())) {
+            gm_symtab_entry* keyGraph = keyType->get_target_graph_sym();
+            mapAccess->set_bound_graph_for_key(keyGraph);
+        }
+        if (gm_has_target_graph_type(valueType->getTypeSummary())) {
+            gm_symtab_entry* valueGraph = valueType->get_target_graph_sym();
+            mapAccess->set_bound_graph_for_value(valueGraph);
+        }
+    }
 };
 
 // check id1 and id2 have same target graph symbol
@@ -335,11 +362,19 @@ bool gm_check_type_is_well_defined(ast_typedecl* type, gm_symtab* SYM_V) {

         // copy graph_id
         //printf("copying graph id = %s\n", node->getTypeInfo()->get_target_graph_id()->get_orgname());
         type->set_target_graph_id(node->getTypeInfo()->get_target_graph_id()->copy(true));
+    } else if (type->is_map()) {
+        ast_maptypedecl* mapType = (ast_maptypedecl*) type;
+        if(gm_has_target_graph_type(mapType->getKeyTypeSummary())) {
+            if(!gm_check_graph_is_defined(mapType->get_key_type(), SYM_V)) return false;
+        }
+        if(gm_has_target_graph_type(mapType->getValueTypeSummary())) {
+            if(!gm_check_graph_is_defined(mapType->get_value_type(), SYM_V)) return false;
+        }
     } else {
         printf("%s", gm_get_type_string(type->getTypeSummary()));
         assert(false);
@@ -598,6 +644,11 @@ bool gm_typechecker_stage_1::apply(ast_sent* s) {
             if (a->is_target_scalar()) {
                 ast_id* id = a->get_lhs_scala();
                 is_okay = find_symbol_id(id);
+            } else if(a->is_target_map_entry()){
+                ast_assign_mapentry* mapAssign = (ast_assign_mapentry*)a;
+                ast_mapaccess* mapAccess = mapAssign->get_lhs_mapaccess();
+                is_okay = find_symbol_id(mapAccess->get_map_id());
+                checkAndSetBoundGraphsForMap(mapAccess);
             } else {
                 ast_field* f = a->get_lhs_field();
                 is_okay = find_symbol_field(f);
@@ -719,6 +770,12 @@ bool gm_typechecker_stage_1::apply(ast_expr* p) {
             is_okay = find_symbol_field(p->get_field());
             break;
         }
+        case GMEXPR_MAPACCESS: {
+            is_okay = find_symbol_id(p->get_id());
+            ast_mapaccess* mapAccess = ((ast_expr_mapaccess*) p)->get_mapaccess();
+            checkAndSetBoundGraphsForMap(mapAccess);
+            break;
+        }
         case GMEXPR_REDUCE: {
             ast_expr_reduce* r = (ast_expr_reduce*) p;
             int iter_type = r->get_iter_type();
diff --git a/src/frontend/gm_new_typecheck_step2.cc b/src/frontend/gm_new_typecheck_step2.cc
index 5af4e9a..34964db 100644
--- a/src/frontend/gm_new_typecheck_step2.cc
+++ b/src/frontend/gm_new_typecheck_step2.cc
@@ -41,7 +41,7 @@ public:
 
         if (s->get_nodetype() == AST_ASSIGN) {
             ast_assign *a = (ast_assign*) s;
-            if (!a->is_target_scalar()) {
+            if (!a->is_target_scalar() && !a->is_target_map_entry()) {
                 ast_field* f = a->get_lhs_field();
                 if (f->get_first()->getTypeInfo()->is_graph() || f->get_first()->getTypeInfo()->is_collection()) {
 
diff --git a/src/frontend/gm_new_typecheck_step3.cc b/src/frontend/gm_new_typecheck_step3.cc
index ede5036..df5f322 100644
--- a/src/frontend/gm_new_typecheck_step3.cc
+++ b/src/frontend/gm_new_typecheck_step3.cc
@@ -23,6 +23,18 @@ public:
     gm_typechecker_stage_3() {
         _is_okay = true;
         set_for_expr(true);
+        set_for_sent(true);
+    }
+
+    bool apply(ast_sent* s) {
+        if (s->get_nodetype() == AST_ASSIGN) {
+            ast_assign* a = (ast_assign*) s;
+            if (a->is_map_entry_assign()) {
+                ast_mapaccess* mapAccess = a->to_assign_mapentry()->get_lhs_mapaccess();
+                return check_boundGraphsForKeyAndValue(mapAccess, a->get_line(), a->get_col());
+            }
+        }
+        return true;
     }
 
     // post apply
@@ -38,6 +50,9 @@ public:
                         gm_symtab_entry * g = t->get_target_graph_sym();
                         assert(g != NULL);
                         e->set_bound_graph(g);
+                    } else if (t->is_map()) {
+                        ast_maptypedecl* mapDecl = (ast_maptypedecl*) t;
+                        e->set_type_summary(mapDecl->getValueTypeSummary());
                     }
                 }
                 break;
@@ -106,6 +121,10 @@ public:
                 e->set_type_summary(GMTYPE_FOREIGN_EXPR);
                 okay = true;
                 break;
+            case GMEXPR_MAPACCESS: {
+                okay = check_mapaccess((ast_expr_mapaccess*) e);
+            }
+                break;
             default:
                 assert(false);
                 break;
@@ -131,7 +150,12 @@ private:
     bool check_binary(ast_expr* e);
     bool check_ter(ast_expr* e);
     bool check_builtin(ast_expr_builtin* e);
+    bool resolveGenericOutputType(ast_expr_builtin* b);
+    int resolveGenericInputType(ast_expr_builtin* b, int argPosition);
     bool check_arguments(ast_expr_builtin* b);
+    bool check_mapaccess(ast_expr_mapaccess* mapAccessExpr);
+    bool check_boundGraphsForKeyAndValue(ast_mapaccess* mapAccess, int line, int column);
+    int tryResolveUnknownType(int type);
 
 public:
     // expression, dest-type
@@ -176,6 +200,59 @@ static bool check_special_case_inside_group_assign(ast_id* l_id, int alt_type_l,
     return true;
 }
 
+bool gm_typechecker_stage_3::check_mapaccess(ast_expr_mapaccess* mapAccessExpr) {
+    mapAccessExpr->set_type_summary(mapAccessExpr->get_id()->getTypeSummary());
+    ast_typedecl* t = mapAccessExpr->get_id()->getTypeInfo();
+    ast_maptypedecl* mapDecl = (ast_maptypedecl*) t;
+    mapAccessExpr->set_type_summary(mapDecl->getValueTypeSummary());
+
+    //check if key-type and key-expression-type are compatible
+    ast_mapaccess* mapAccess = mapAccessExpr->get_mapaccess();
+    ast_expr* keyExpr = mapAccess->get_key_expr();
+    int keyExprType = keyExpr->get_type_summary();
+
+    gm_symtab_entry* mapEntry = mapAccess->get_map_id()->getSymInfo();
+    assert(mapEntry != NULL);
+    assert(mapEntry->getType()->is_map());
+    ast_maptypedecl* mapTypeDecl = (ast_maptypedecl*) mapEntry->getType();
+    int keyType = mapTypeDecl->getKeyTypeSummary();
+
+    int dummy;
+    bool warning;
+    bool isOkay = gm_is_compatible_type_for_assign(keyType, keyExprType, dummy, warning);
+    int line = mapAccessExpr->get_line();
+    int column = mapAccessExpr->get_col();
+    if (!isOkay) {
+        gm_type_error(GM_ERROR_KEY_MISSMATCH, line, column, gm_get_type_string(keyType), gm_get_type_string(keyExprType));
+    } else if (warning) {
+        printf("warning: implicit type conversion %s->%s\n", gm_get_type_string(keyType), gm_get_type_string(keyExprType));
+    }
+
+    isOkay &= check_boundGraphsForKeyAndValue(mapAccess, line, column);
+    return isOkay;
+}
+
+bool gm_typechecker_stage_3::check_boundGraphsForKeyAndValue(ast_mapaccess* mapAccess, int line, int column) {
+    //check if target graphs for key are the same
+    int keyType = mapAccess->get_key_expr()->get_type_summary();
+    if (gm_has_target_graph_type(keyType)) {
+        gm_symtab_entry* keyGraph = mapAccess->get_bound_graph_for_key();
+        ast_expr* keyExpr = mapAccess->get_key_expr();
+        int keyExprType = keyExpr->get_type_summary();
+        gm_symtab_entry* keyExprGraph = keyExpr->get_bound_graph();
+        if (keyExprGraph == NULL) {
+            assert(gm_is_nil_type(keyExprType) || gm_is_foreign_expr_type(keyExprType));
+        } else {
+            if (keyGraph != keyExprGraph) {
+                gm_type_error(GM_ERROR_TARGET_MISMATCH, line, column);
+                return false;
+            }
+        }
+    }
+    return true;
+}
+;
+
 // comparison (eq, neq and less)
 bool gm_typechecker_stage_3::check_binary(ast_expr* e) {
     int op_type = e->get_optype();
@@ -287,6 +364,33 @@ static bool gm_is_compatible_type_collection_of_collection(int shouldbeType, int
     return true;
 }
 
+int gm_typechecker_stage_3::resolveGenericInputType(ast_expr_builtin* b, int argPosition) {
+
+    gm_builtin_def* def = b->get_builtin_def();
+    ast_id* driver = b->get_driver();
+    assert(driver->getTypeSummary() == GMTYPE_MAP);
+    // we only support maps atm
+    ast_typedecl* typeDecl = driver->getTypeInfo();
+    ast_maptypedecl* mapTypeDecl = (ast_maptypedecl*) typeDecl;
+    if (def->genericArgumentTypeIsKeyType(argPosition))
+        return mapTypeDecl->getKeyTypeSummary();
+    else
+        return mapTypeDecl->getValueTypeSummary();
+}
+
+int gm_typechecker_stage_3::tryResolveUnknownType(int type) {
+    switch (type) {
+        case GMTYPE_COLLECTIONITER_SET:
+            return GMTYPE_NSET;
+        case GMTYPE_COLLECTIONITER_ORDER:
+            return GMTYPE_NORDER;
+        case GMTYPE_COLLECTIONITER_SEQ:
+            return GMTYPE_NSEQ;
+        default:
+            return type;
+    }
+}
+
 bool gm_typechecker_stage_3::check_arguments(ast_expr_builtin* b) {
 
     bool okay = true;
@@ -299,17 +403,23 @@ bool gm_typechecker_stage_3::check_arguments(ast_expr_builtin* b) {
         ast_expr* e = *iter;
         int currentType = e->get_type_summary();
         int def_type = def->get_arg_type(position);
-        if (gm_is_unknown_type(currentType)) {
+        if (def_type == GMTYPE_GENERIC) {
+            def_type = (int) resolveGenericInputType(b, position);
+        } else if (gm_is_unknown_type(currentType)) {
             okay = false;
             continue;
         }
+
+        currentType = tryResolveUnknownType(currentType);
+
         bool warning;
         int coerced_type;
         bool isCompatible;
@@ -329,6 +439,10 @@ bool gm_typechecker_stage_3::check_builtin(ast_expr_builtin* b) {
     bool okay = check_arguments(b);
     gm_builtin_def* def = b->get_builtin_def();
     int fun_ret_type = def->get_result_type_summary();
+
+    if (fun_ret_type == GMTYPE_GENERIC) {
+        return resolveGenericOutputType(b);
+    }
     b->set_type_summary(fun_ret_type);
 
     if (gm_has_target_graph_type(fun_ret_type)) {
@@ -342,6 +456,33 @@ bool gm_typechecker_stage_3::check_builtin(ast_expr_builtin* b) {
     return okay;
 }
 
+bool gm_typechecker_stage_3::resolveGenericOutputType(ast_expr_builtin* b) {
+    gm_builtin_def* def = b->get_builtin_def();
+    ast_id* driver = b->get_driver();
+    assert(driver->getTypeSummary() == GMTYPE_MAP);
+    ast_typedecl* typeDecl = driver->getTypeInfo();
+    assert(typeDecl->is_map());
+    ast_maptypedecl* mapTypeDecl = (ast_maptypedecl*) typeDecl;
+    int funcReturnType;
+    if (def->genericTypeIsKeyType())
+        funcReturnType = mapTypeDecl->getKeyTypeSummary();
+    else
+        funcReturnType = mapTypeDecl->getValueTypeSummary();
+
+    b->set_type_summary(funcReturnType);
+
+    if (gm_has_target_graph_type(funcReturnType)) {
+        gm_symtab_entry* graph;
+        if (def->genericTypeIsKeyType())
+            graph = mapTypeDecl->get_key_type()->get_target_graph_sym();
+        else
+            graph = mapTypeDecl->get_value_type()->get_target_graph_sym();
+        b->set_bound_graph(graph);
+    }
+
+    return true;
+}
+
 // type resolve for u-op
 bool gm_typechecker_stage_3::check_uop(ast_expr* e) {
     int op_type = e->get_optype();
diff --git a/src/frontend/gm_new_typecheck_step4.cc b/src/frontend/gm_new_typecheck_step4.cc
index 7813e59..0e8ed13 100644
--- a/src/frontend/gm_new_typecheck_step4.cc
+++ b/src/frontend/gm_new_typecheck_step4.cc
@@ -36,6 +36,10 @@ public:
             int lhs_type;
             if (a->is_target_scalar()) {
                 lhs_type = a->get_lhs_scala()->getTypeSummary();
+            } else if (a->is_target_map_entry()) {
+                ast_mapaccess* mapAccess = a->to_assign_mapentry()->get_lhs_mapaccess();
+                ast_maptypedecl* mapDecl = (ast_maptypedecl*)mapAccess->get_map_id()->getTypeInfo();
+                lhs_type = mapDecl->getValueTypeSummary();
             } else {
                 lhs_type = a->get_lhs_field()->getTargetTypeSummary();
             }
diff --git a/src/frontend/gm_new_typecheck_step5.cc b/src/frontend/gm_new_typecheck_step5.cc
index 5bf220c..4a1d107 100644
--- a/src/frontend/gm_new_typecheck_step5.cc
+++ b/src/frontend/gm_new_typecheck_step5.cc
@@ -124,6 +124,24 @@ public:
                 gm_type_error(GM_ERROR_READONLY, l);
                 return false;
             }
+        } else if (lhs->get_nodetype() == AST_MAPACCESS) {
+            ast_mapaccess* mapAccess = (ast_mapaccess*) lhs;
+            ast_maptypedecl* mapDecl = (ast_maptypedecl*) mapAccess->get_map_id()->getTypeInfo();
+            l_sym = mapAccess->get_bound_graph_for_value();
+            summary_lhs = mapDecl->getValueTypeSummary();
+
+            int keyType = mapDecl->getKeyTypeSummary();
+            int keyExprType = mapAccess->get_key_expr()->get_type_summary();
+            int dummy;
+            bool warning;
+            bool isOkay = gm_is_compatible_type_for_assign(keyType, keyExprType, dummy, warning);
+            if (!isOkay) {
+                gm_type_error(GM_ERROR_KEY_MISSMATCH, l, c, gm_get_type_string(keyType), gm_get_type_string(keyExprType));
+                return false;
+            } else if (warning) {
+                printf("warning: implicit type conversion %s->%s\n", gm_get_type_string(keyType), gm_get_type_string(keyExprType));
+            }
+
         } else {
             // target type (e.g. N_P<Int> -> Int)
             ast_field* f = (ast_field*) lhs;
@@ -132,11 +150,11 @@ public:
             if (f->getTargetTypeInfo()->has_target_graph()) {
                 l_sym = f->getTargetTypeInfo()->get_target_graph_sym();
             }
-
         }
 
         // check assignable
         summary_rhs = rhs->get_type_summary();
+        summary_rhs = tryResolveIfUnknown(summary_rhs);
 
         bool warn;
         int coed;
@@ -150,16 +168,14 @@ public:
         }
 
         if (gm_has_target_graph_type(summary_lhs)) {
-            gm_symtab_entry* r_sym = rhs->get_bound_graph();
-            assert(l_sym != NULL);
-            if (r_sym == NULL) {
-                assert(gm_is_nil_type(summary_rhs) || gm_is_foreign_expr_type(summary_rhs));
+            gm_symtab_entry* r_sym;
+            if (rhs->is_mapaccess()) {
+                ast_mapaccess* mapAccess = ((ast_expr_mapaccess*) rhs)->get_mapaccess();
+                r_sym = mapAccess->get_bound_graph_for_value();
             } else {
-                if (l_sym != r_sym) {
-                    gm_type_error(GM_ERROR_TARGET_MISMATCH, l, c);
-                    return false;
-                }
+                r_sym = rhs->get_bound_graph();
             }
+            return checkGraphs(l_sym, r_sym, summary_rhs, l, c);
         }
 
         return true;
@@ -173,11 +189,15 @@ public:
         if (a->is_target_scalar()) {
             okay = check_assign_lhs_rhs(a->get_lhs_scala(), a->get_rhs(), l, c);
             summary_lhs = a->get_lhs_scala()->getTypeSummary();
+        } else if (a->is_target_map_entry()) {
+            ast_mapaccess* mapAccess = a->to_assign_mapentry()->get_lhs_mapaccess();
+            okay = check_assign_lhs_rhs(mapAccess, a->get_rhs(), l, c);
+            ast_maptypedecl* mapDecl = (ast_maptypedecl*) mapAccess->get_map_id()->getTypeInfo();
+            summary_lhs = mapDecl->getValueTypeSummary();
         } else {
             okay = check_assign_lhs_rhs(a->get_lhs_field(), a->get_rhs(), l, c);
             summary_lhs = a->get_lhs_field()->get_second()->getTargetTypeSummary();
         }
-
         // check body of reduce
         if (a->is_reduce_assign()) {
 
@@ -236,6 +256,31 @@ private:
     bool _is_okay;
     ast_typedecl* ret;
 
+    bool checkGraphs(gm_symtab_entry* l_sym, gm_symtab_entry* r_sym, int summary_rhs, int line, int column) {
+        assert(l_sym != NULL);
+        if (r_sym == NULL) {
+            assert(gm_is_nil_type(summary_rhs) || gm_is_foreign_expr_type(summary_rhs));
+        } else {
+            if (l_sym != r_sym) {
+                gm_type_error(GM_ERROR_TARGET_MISMATCH, line, column);
+                return false;
+            }
+        }
+        return true;
+    }
+
+    int tryResolveIfUnknown(int type) {
+        switch (type) {
+            case GMTYPE_PROPERTYITER_SET:
+                return GMTYPE_NSET;
+            case GMTYPE_PROPERTYITER_SEQ:
+                return GMTYPE_NSEQ;
+            case GMTYPE_PROPERTYITER_ORDER:
+                return GMTYPE_NORDER;
+        }
+        return type;
+    }
+
 public:
     std::map<ast_expr*, int> coercion_targets;
 };
diff --git a/src/frontend/gm_rw_analysis.cc b/src/frontend/gm_rw_analysis.cc
index 6766930..944f4c2 100644
--- a/src/frontend/gm_rw_analysis.cc
+++ b/src/frontend/gm_rw_analysis.cc
@@ -344,6 +344,11 @@ void traverse_expr_for_readset_adding(ast_expr* e, gm_rwinfo_map& rset, temp_map
         case GMEXPR_FIELD:
             traverse_expr_for_readset_adding_field(e, rset, DrvMap);
             break;
+        case GMEXPR_MAPACCESS: {
+            ast_mapaccess* mapAccess = ((ast_expr_mapaccess*) e)->get_mapaccess();
+            traverse_expr_for_readset_adding(mapAccess->get_key_expr(), rset, DrvMap);//TODO
+        }
+            break;
         case GMEXPR_UOP:
         case GMEXPR_LUOP:
             traverse_expr_for_readset_adding(e->get_left_op(), rset, DrvMap);
@@ -489,7 +494,7 @@ bool gm_rw_analysis::apply_assign(ast_assign *a) {
     gm_rwinfo_map& D = sets->reduce_set;
 
     // (1) LHS
-    bool is_reduce = (a->is_reduce_assign() || a->is_defer_assign());
+    bool is_reduce = (a->is_reduce_assign() || a->is_defer_assign()) && !a->is_map_entry_assign();
     gm_symtab_entry* bound_sym = NULL;
     int bound_op = GMREDUCE_NULL;
     if (is_reduce) {
@@ -505,6 +510,10 @@ bool gm_rw_analysis::apply_assign(ast_assign *a) {
     if (a->get_lhs_type() == GMASSIGN_LHS_SCALA) {
         target_sym = a->get_lhs_scala()->getSymInfo();
         new_entry = gm_rwinfo::new_scala_inst(a->get_lhs_scala(), bound_op, bound_sym);
+    } else if (a->get_lhs_type() == GMASSIGN_LHS_MAP) {
+        ast_mapaccess* mapAccess = a->to_assign_mapentry()->get_lhs_mapaccess();
+        target_sym = mapAccess->get_map_id()->getSymInfo();
+        new_entry = gm_rwinfo::new_scala_inst(mapAccess->get_map_id(), bound_op, bound_sym);//TODO
     } else {
         target_sym = a->get_lhs_field()->get_second()->getSymInfo();
         gm_symtab_entry* iter_sym = a->get_lhs_field()->get_first()->getSymInfo();
@@ -990,8 +999,7 @@ static bool cleanup_iterator_access_reduce(ast_id* iter, gm_rwinfo_map& D_temp,
                     if (cp->access_range != GM_RANGE_SINGLE) {
                         cp->access_range = GM_RANGE_RANDOM; // scalar access becomes random access
                     }
-                }
-                else if (!cp->driver->getType()->is_node_edge_iterator()) {
+                } else if (!cp->driver->getType()->is_node_edge_iterator()) {
                     cp->access_range = GM_RANGE_RANDOM;
                     cp->driver = NULL;
                 }
diff --git a/src/inc/gm_ast.h b/src/inc/gm_ast.h
index 319459b..a54f1c0 100644
--- a/src/inc/gm_ast.h
+++ b/src/inc/gm_ast.h
@@ -875,6 +880,10 @@ public:
         return gm_is_sequential_collection_type(type_id);
     }
 
+    virtual bool is_map() {
+        return false;
+    }
+
     virtual void reproduce(int id_level);
     virtual void dump_tree(int id_level);
 
@@ -1402,62 +1496,85 @@ public:
     bool is_foreign() {
         return expr_class == GMEXPR_FOREIGN;
     }
 
+    virtual bool is_mapaccess() {
+        return false;
+    }
+
     //-----------------------------------------------
     // type is set after type-checker execution
     //-----------------------------------------------
     int get_type_summary() {
         return type_of_expression;
     }
+
     void set_type_summary(int t) {
         type_of_expression = t;
     } // set by type checker
 
     gm_symtab_entry* get_bound_graph() {
+        if (bound_graph_sym == NULL && is_id())
+            return id1->getTypeInfo()->get_target_graph_sym();
+        else
         return bound_graph_sym;
     }
+
     void set_bound_graph(gm_symtab_entry*e) {
         bound_graph_sym = e;
     }
@@ -1874,11 +2129,14 @@ enum gm_assignment_t
 {
     GMASSIGN_NORMAL, GMASSIGN_REDUCE, GMASSIGN_DEFER, GMASSIGN_INVALID
 };
+
 enum gm_assignment_location_t
 {
-    GMASSIGN_LHS_SCALA, GMASSIGN_LHS_FIELD, GMASSIGN_LHS_END
+    GMASSIGN_LHS_SCALA, GMASSIGN_LHS_FIELD, GMASSIGN_LHS_MAP, GMASSIGN_LHS_END
 };
 
+class ast_assign_mapentry;
+
 class ast_assign: public ast_sent
 {
 public:
@@ -1946,28 +2209,40 @@ public:
     bool is_reduce_assign() {
         return assign_type == GMASSIGN_REDUCE;
     }
+
     bool is_defer_assign() {
         return assign_type == GMASSIGN_DEFER;
     }
-    bool is_target_scalar() {
+
+    virtual bool is_target_scalar() {
         return get_lhs_type() == GMASSIGN_LHS_SCALA;
     }
+
+    virtual bool is_target_map_entry() {
+        return false;
+    }
+
     void set_rhs(ast_expr* r) {
         rhs = r;
         rhs->set_parent(this);
@@ -2005,24 +2280,105 @@ public:
         if (new_id != NULL) lhs_type = GMASSIGN_LHS_FIELD;
     }
 
-private:
+    virtual bool is_map_entry_assign() {
+        return false;
+    }
+
+    virtual ast_assign_mapentry* to_assign_mapentry() {
+        assert(false);
+        return NULL;
+    }
+
+    void set_is_reference(bool is_ref) {
+        isReference = is_ref;
+    }
+
+    bool is_reference() {
+        return isReference;
+    }
+
+protected:
     ast_assign() :
-            ast_sent(AST_ASSIGN), lhs_scala(NULL), lhs_field(NULL), rhs(NULL), bound(NULL), arg_minmax(false), lhs_type(0), assign_type(0), reduce_type(0) {
+            ast_sent(AST_ASSIGN), lhs_scala(NULL), lhs_field(NULL), rhs(NULL), bound(NULL), arg_minmax(false), lhs_type(0), assign_type(0), reduce_type(0), isReference(false) {
     }
 
+private:
     int assign_type; // normal, deferred, reduce
     int lhs_type; // scalar, field
     int reduce_type; // add, mult, min, max
     ast_id* lhs_scala;
     ast_field* lhs_field;
-    ast_expr* rhs;
+
     ast_id* bound;  // bounding iterator
 
     bool arg_minmax;
+    bool isReference;
 
     std::list<ast_node*> l_list;
     std::list<ast_expr*> r_list;
 
+protected:
+    ast_expr* rhs;
+
+};
=======
>>>>>>> 2ca3a11179000e72f18fad33599d2f9e47801e25
+
diff --git a/src/inc/gm_backend_cpp.h b/src/inc/gm_backend_cpp.h
index 59eae0c..ea28fd3 100644
--- a/src/inc/gm_backend_cpp.h
+++ b/src/inc/gm_backend_cpp.h
@@ -56,15 +56,63 @@ public:
     virtual void generate_expr_builtin_field(ast_expr_builtin_field* builtinExpr, gm_code_writer& body);
     const char* get_function_name_graph(int methodId);
     const char* get_function_name_nset(int methodId, bool in_parallel = false);
     const char* get_function_name_nseq(int methodId);
     const char* get_function_name_norder(int methodId);
+    const char* get_function_name_map(int methodId, bool in_parallel = false);
+    const char* get_function_name_map_seq(int methodId);
+    const char* get_function_name_map_par(int methodId);
     void add_arguments_and_thread(gm_code_writer& body, ast_expr_builtin* builtinExpr, bool addThreadId);
+    const char* getMapDefaultValueForType(int type);
+    const char* getMapTypeString(int mapType);
+    const char* getAdditionalMapParameters(int mapType);
+
