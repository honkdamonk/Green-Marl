diff --git a/src/backend_cpp/gm_cpp_gen_foreach.cc b/src/backend_cpp/gm_cpp_gen_foreach.cc
index 9e2fdaf..6a0ecd3 100644
--- a/src/backend_cpp/gm_cpp_gen_foreach.cc
+++ b/src/backend_cpp/gm_cpp_gen_foreach.cc
@@ -26,8 +26,7 @@ bool gm_cpplib::need_up_initializer(ast_foreach* f) {
     int iter_type = f->get_iter_type();
     if (gm_is_iteration_on_collection(iter_type))
         return true;
-    else if (gm_is_common_nbr_iter_type(iter_type))
-        return true;
+    else if (gm_is_common_nbr_iter_type(iter_type)) return true;
     return false;
 }
 
@@ -99,8 +98,11 @@ void gm_cpplib::generate_down_initializer(ast_foreach* f, gm_code_writer& Body)
         else
             type_name = source->getTypeInfo()->is_node_collection() ? NODE_T : EDGE_T;
 
-        sprintf(str_buf, "const %s& %s = %s.get_next();", type_name, f->get_iterator()->get_genname(), lst_iter_name);
-        //sprintf(str_buf, "%s %s = %s.get_next();", type_name, f->get_iterator()->get_genname(), lst_iter_name);
+        if(gm_is_collection_of_collection_iter_type(iter_type)) {
+            sprintf(str_buf, "%s& %s = %s.get_next();", type_name, f->get_iterator()->get_genname(), lst_iter_name);
+        } else {
+            sprintf(str_buf, "%s %s = %s.get_next();", type_name, f->get_iterator()->get_genname(), lst_iter_name);
+        }
         Body.pushln(str_buf);
     } else if (gm_is_iteration_on_neighbors_compatible(iter_type)) {
         const char* alias_name = f->find_info_string(CPPBE_INFO_NEIGHBOR_ITERATOR);
@@ -149,8 +151,7 @@ void gm_cpplib::generate_foreach_header(ast_foreach* fe, gm_code_writer& Body) {
         }
         char* it_name = iter->get_genname();
         sprintf(str_buf, "for (%s %s = 0; %s < %s.%s(); %s ++) ", get_type_string(type), it_name, it_name, graph_name,
-                gm_is_iteration_on_nodes(type) ? NUM_NODES : NUM_EDGES,
-                it_name);
+                gm_is_iteration_on_nodes(type) ? NUM_NODES : NUM_EDGES, it_name);
 
         Body.pushln(str_buf);
     } else if (gm_is_common_nbr_iter_type(type)) {
diff --git a/src/common/gm_transform_helper.cc b/src/common/gm_transform_helper.cc
index 5b1dce3..a07b305 100644
--- a/src/common/gm_transform_helper.cc
+++ b/src/common/gm_transform_helper.cc
@@ -20,7 +20,7 @@ static void find_enclosing_scope(ast_node* n, gm_scope* s) {
         fe->get_this_scope(s);
         return;
     } else if (n->get_nodetype() == AST_SENTBLOCK) {
-        ast_foreach* sb = (ast_foreach*) n;
+        ast_sentblock* sb = (ast_sentblock*) n;
         sb->get_this_scope(s);
         return;
     } else if (n->get_nodetype() == AST_PROCDEF) {
diff --git a/src/opt/gm_hoist_normal_sent.h b/src/opt/gm_hoist_normal_sent.h
index 3fac44b..1544e5e 100644
--- a/src/opt/gm_hoist_normal_sent.h
+++ b/src/opt/gm_hoist_normal_sent.h
@@ -24,7 +24,7 @@ public:
             // find target assign sentence
             //--------------------------------------
             ast_sent* target = *i_out;
-            if (!check_target((ast_assign*) target)) continue;
+            if (target->get_nodetype() != AST_ASSIGN || !check_target((ast_assign*) target)) continue;
 
             std::list<ast_sent*>& sents2 = sb->get_sents(); // most up-to-date list
             std::list<ast_sent*> stack;
